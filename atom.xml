<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>might&#39;s room</title>
  <icon>https://mightcoder.com/icon.png</icon>
  <subtitle>Hope you can find something useful here.</subtitle>
  <link href="https://mightcoder.com/atom.xml" rel="self"/>
  
  <link href="https://mightcoder.com/"/>
  <updated>2023-11-01T13:33:47.439Z</updated>
  <id>https://mightcoder.com/</id>
  
  <author>
    <name>might</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>effective modern c++</title>
    <link href="https://mightcoder.com/2023/11/02/effective%20modern%20c++/"/>
    <id>https://mightcoder.com/2023/11/02/effective%20modern%20c++/</id>
    <published>2023-11-02T13:01:37.000Z</published>
    <updated>2023-11-01T13:33:47.439Z</updated>
    
    <content type="html"><![CDATA[<h1 id="条款一：类型推导"><a href="#条款一：类型推导" class="headerlink" title="条款一：类型推导"></a>条款一：类型推导</h1><p>1.参数类型是指针或引用，但不是万能引用</p><p>忽略掉指针和引用符号，对类型进行对应，如果形参无const，根据实参有没有const决定推导类型有没有const，如果形参有const，无论实参有没有const推导类型都有const</p><p>2.参数类型是万能引用</p><p>万能引用即右值引用<code>T&amp;&amp;</code>，如果实参是左值，则被推导成左值引用，注意即使实参不是引用也会被推到成左值引用，如果是右值，则为右值，是不是引用取决于实参。  保留const</p><p>3.参数类型既不是指针也不是引用</p><p>按值传递，直接推导类型，忽略const和volatile和引用。</p><p>数组的推导：由于数组和指针的混淆性，若不加引用号的话，数组会被推导成指针，若加了引用号，则会被推导成数组，并且可以获取数组大小，利用这一特性可以在编译期获取数组大小。</p><h3 id="条款二：auto"><a href="#条款二：auto" class="headerlink" title="条款二：auto"></a>条款二：auto</h3><p>auto的类型推导和函数参数的类型推导同理</p><p>但是当auto声明的变量是大括号括起时，推导类型属于<code>initializer_list&lt;T&gt;</code>，特别注意只有auto能推导出大括号括起的初始化表达式，这也是auto和参数推导的唯一区别。</p><p>c++14支持auto推导函数返回值和auto推导lambda函数参数，这些时候auto适用于参数（模板）类型推导。</p><h3 id="条款三：decltype"><a href="#条款三：decltype" class="headerlink" title="条款三：decltype"></a>条款三：decltype</h3><p>decltype的类型推导很简单，只会原原本本的返回其类型，保留const、引用等修饰。</p><p>decltype的主要用途：</p><p><strong>返回值型别尾序语法</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container,<span class="keyword">typename</span> Index&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">authAndAccess</span><span class="params">(Container&amp; c,Index i)</span></span></span><br><span class="line"><span class="function">-&gt;<span class="title">decltype</span><span class="params">(c[i])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里auto的之前的auto没有关系，只是说明这里用了返回值型别尾序语法，这个语法的作用是可以在返回值中用到函数形参。</p><p>c++11不支持auto作为函数返回值，而c++14支持，但是使用auto作为返回值经常会发生问题，例如将引用类型省略掉，这是非常致命的，可以用<code>decltype(auto)</code>解决这个问题。</p><p>在c++14中上述代码可以写成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename Container,typename Index&gt;</span><br><span class="line">decltype(auto) authAndAccess(Container&amp; c,Index i)</span><br><span class="line">&#123;</span><br><span class="line">    return c[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代码还有改动的余地，因为参数只支持左值引用，可以用万能引用解决这个问题，但是要注意是注意使用万能引用要搭配完美转发</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//c++11</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container,<span class="keyword">typename</span> Index&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">authAndAccess</span><span class="params">(Container&amp;&amp; c,Index i)</span></span></span><br><span class="line"><span class="function">-&gt;<span class="title">decltype</span><span class="params">(c[i])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::forward&lt;Container&gt;(c)[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于decltype还需要注意的一点是 int x&#x3D;10 中，x是int类型，但是(x)是int&amp;类型，需要注意</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">decltype</span>(x)<span class="comment">//int</span></span><br><span class="line"><span class="keyword">decltype</span>((x))<span class="comment">//int&amp;</span></span><br></pre></td></tr></table></figure><h3 id="条款四：查看类型推导的方法"><a href="#条款四：查看类型推导的方法" class="headerlink" title="条款四：查看类型推导的方法"></a>条款四：查看类型推导的方法</h3><p>typeid(x).name()</p><p>boost::typeindex::type_id</p><h3 id="条款五：优先选用auto，而非显式型别声明"><a href="#条款五：优先选用auto，而非显式型别声明" class="headerlink" title="条款五：优先选用auto，而非显式型别声明"></a>条款五：优先选用auto，而非显式型别声明</h3><p>auto优点</p><ul><li>显式型别声明未初始化不会报错，但可能会导致未定义行为，auto未初始化会报错 </li><li>使用auto可以表示复杂类型或编译器知道的类型，比如函数闭包(性能显著优于std::function)</li><li>避免错误的类型转换：从函数返回值到显式声明的类型有类型转换，这可能会造成问题</li></ul><blockquote><p>闭包：c++中闭包(Closure)通常指一个能捕获其所在作用域内变量的函数对象，比如lambda函数</p></blockquote><h3 id="条款六：当auto推导的型别不符合要求时，使用带显式型别的初始化物习惯用法"><a href="#条款六：当auto推导的型别不符合要求时，使用带显式型别的初始化物习惯用法" class="headerlink" title="条款六：当auto推导的型别不符合要求时，使用带显式型别的初始化物习惯用法"></a>条款六：当auto推导的型别不符合要求时，使用带显式型别的初始化物习惯用法</h3><blockquote><p>隐形代理：代理模式的应用，有些容器返回的不是基本类型，而是一种代理，比如<code>vector&lt;bool&gt;</code>返回的是<code>std::vector&lt;bool&gt;::reference</code>类型</p></blockquote><p>当有隐形代理时使用auto不会得到想要的类型，此时除了使用显式的类型声明，还可以使用<code>带显式型别的初始化物习惯用法</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> highPriority = <span class="built_in">static_cast</span>&lt;<span class="type">bool</span>&gt;(<span class="built_in">features</span>(w)[<span class="number">5</span>])</span><br></pre></td></tr></table></figure><p>相较于显示类型声明的优点：更加直观的表现了类型转换。</p><h3 id="条款七：在创建对象时注意-和"><a href="#条款七：在创建对象时注意-和" class="headerlink" title="条款七：在创建对象时注意()和{}"></a>条款七：在创建对象时注意()和{}</h3><p>相较于小括号初始化，大括号初始化可应用的语境最广泛，可以阻止隐式窄化形型别转换，还对最令人苦恼的解析语法免疫。</p><p>如果要自己写使用大括号初始化的函数，要注意在构造函数重载期间，只要有任何可能，大括号初始化物就会与带有<code>std::initializer_list</code>型别的形参相匹配，即使其他重载版本有更加匹配的形参表。</p><h3 id="条款八：优先使用nullptr，而非0或NULL"><a href="#条款八：优先使用nullptr，而非0或NULL" class="headerlink" title="条款八：优先使用nullptr，而非0或NULL"></a>条款八：优先使用nullptr，而非0或NULL</h3><p>0和NULL都不是指针类型，而nullptr可以视为指针，因为其可以隐式转换成所有指针类型。</p><p>在使用模板时，nullptr的优势展现出来，0和NULL会被类型推导为整形而非函数，这可能与某些函数的参数类型不符，从而报错，而nullptr则不会发生这种情况。</p><h3 id="条款九：优先使用别名，而非typedef"><a href="#条款九：优先使用别名，而非typedef" class="headerlink" title="条款九：优先使用别名，而非typedef"></a>条款九：优先使用别名，而非typedef</h3><p>using可以声明模板别名，而typedef不能</p><p>通过typedef声明的模板别名以type成员的形式出现，如果要在模板内使用时还必须加typename修饰</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyAllocList</span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> std::list&lt;T,MyAlloc&lt;T&gt;&gt; type;</span><br><span class="line">&#125;;</span><br><span class="line">MyAllocList&lt;Widget&gt;::type ls;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">typename</span> MyAllocList&lt;Widget&gt;::type ls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>c++型别转换：在<code>&lt;type_traits&gt;</code>中给出接口，在c++11中是通过嵌套在struct中的typedef实现的，使用时需调用<code>std::remove_const&lt;T&gt;::type</code>，在c++14中又通过using实现了等效的接口<code>std::remove_const_t&lt;T&gt;</code></p></blockquote><h3 id="条款十：优先选用限定作用域的枚举类型，而非不限作用域的枚举类型"><a href="#条款十：优先选用限定作用域的枚举类型，而非不限作用域的枚举类型" class="headerlink" title="条款十：优先选用限定作用域的枚举类型，而非不限作用域的枚举类型"></a>条款十：优先选用限定作用域的枚举类型，而非不限作用域的枚举类型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">UserInfo</span>&#123;name,email,reputation&#125;;<span class="comment">//不限作用域的枚举类型</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">UserInfo</span>&#123;name,email,reputation&#125;;<span class="comment">//限定作用域的枚举类型</span></span><br></pre></td></tr></table></figure><p>两者的主要区别是</p><ul><li>限定作用域的枚举类型其枚举变量名只在内部可见，可以降低名字空间污染，而不限定作用域的枚举类型其变量名不能在相同作用域下重复使用</li><li>不限定作用域的枚举类型可隐式转换到整数类型，进而可转换到浮点数类型，这可能会造成某些错误，而限定作用域的枚举类型的类型转换需要通过<code> static_cast&lt;size_t&gt;(c)</code></li><li>限定作用域的枚举类型总是可以前置声明，而不限定作用域的枚举类型必须在指定默认底层型别的前提下才能进行前置声明。</li></ul><h3 id="条款十一：优先选用删除函数，而非private未定义函数"><a href="#条款十一：优先选用删除函数，而非private未定义函数" class="headerlink" title="条款十一：优先选用删除函数，而非private未定义函数"></a>条款十一：优先选用删除函数，而非private未定义函数</h3><p>如果你编写了某个函数，但是想阻止程序员调用某个特定函数的话，在C++98中，通常的方法是将其声明为private并不定义它们，这样就阻止了调用或者在链接阶段因为缺少函数定义而失败。</p><p>在c++11中使用<code>=delete</code>可以实现同样的效果，而且98的方法只能针对成员函数，并且无法阻止特化模板函数（因为其无法被声明为private），11的做法可以删除任何函数。</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="条款十二：为意在改写的函数添加override声明"><a href="#条款十二：为意在改写的函数添加override声明" class="headerlink" title="条款十二：为意在改写的函数添加override声明"></a>条款十二：为意在改写的函数添加override声明</h3><blockquote><p>关于重载重写(覆盖)和隐藏：</p><p>（1）函数重载发生在相同作用域；</p><p>（2）函数隐藏发生在不同作用域；</p><p>（3）函数覆盖就是函数重写。准确地叫作虚函数覆盖和虚函数重写，也是函数隐藏的特例。</p><p>关于三者的对比，李健老师在《编写高质量代码：改善C++程序的150个建议》给出了较为详细的总结，如下表所示：</p><table><thead><tr><th>三者</th><th>作用域</th><th>有无virtual</th><th>函数名</th><th>形参列表</th><th>返回值类型</th></tr></thead><tbody><tr><td>重载</td><td>相同</td><td>可有可无</td><td>相同</td><td>不同</td><td>可同可不同</td></tr><tr><td>隐藏</td><td>不同</td><td>可有可无</td><td>相同</td><td>可同可不同</td><td>可同可不同</td></tr><tr><td>重写</td><td>不同</td><td>有</td><td>相同</td><td>相同</td><td>相同（协变）</td></tr></tbody></table></blockquote><p>为什么要加override？因为函数重载重写的混淆性，很多时候想要实现重写但由于某些错误没有实现，但是这时编译器不会报错，反而会顺利编译通过，无法达到我们想要的效果。在派生类中加上override以后，编译器就会吹毛求疵的检查函数是否为重写，</p><p> 再详细的补充一下函数重写的规则</p><ul><li>基类中的函数是虚函数</li><li>基类和派生类中的函数名必须完全相同</li><li>基类和派生类中函数形参型别必须完全想让</li><li>基类和派生类的常量性必须相同(constness)</li><li>基类和派生类的返回值必须相同或协变（即派生类返回的类型是基类返回类型的子类型）</li></ul><p>c++11的新规则还规定</p><ul><li>基类和子类的函数引用饰词相同</li></ul><blockquote><p>关于函数引用饰词：用于表示调用这个函数的引用类型应该是左值还是右值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dowork</span><span class="params">()</span> &amp;</span>;<span class="comment">//这个版本仅在*this是左值时使用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dowork</span><span class="params">()</span> &amp;&amp;</span>;<span class="comment">//这个版本仅在*this是右值时使用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引用修饰符在括号里面表示参数的引用类型，在函数后面表示调用者的引用类型。</p></blockquote>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;条款一：类型推导&quot;&gt;&lt;a href=&quot;#条款一：类型推导&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    
    <category term="hpc" scheme="https://mightcoder.com/tags/hpc/"/>
    
    <category term="c++" scheme="https://mightcoder.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>CXL</title>
    <link href="https://mightcoder.com/2023/11/01/CXL/"/>
    <id>https://mightcoder.com/2023/11/01/CXL/</id>
    <published>2023-11-01T12:31:37.000Z</published>
    <updated>2023-11-01T12:31:33.373Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CXL简介："><a href="#CXL简介：" class="headerlink" title="CXL简介："></a>CXL简介：</h1><p><a href="../%E6%96%B9%E5%90%91%E5%AD%A6%E4%B9%A0/cxl/CXL%E8%AE%BA%E6%96%87.md#%5Ea4c00f">CXL论文</a></p><p>Panmnesia<br><a href="../%E6%97%A5%E8%AE%B0/2023-09-18.md#%5E3471f6">2023-09-18</a></p><p>CXL-SSD<br><a href="https://dl.acm.org/doi/abs/10.1145/3538643.3539745">Hello bytes, bye blocks | Proceedings of the 14th ACM Workshop on Hot Topics in Storage and File Systems</a></p><h1 id="An-Introduction-to-the-Compute-Express-LinkTM-CXLTM-Interconnect"><a href="#An-Introduction-to-the-Compute-Express-LinkTM-CXLTM-Interconnect" class="headerlink" title="An Introduction to the Compute Express LinkTM (CXLTM) Interconnect"></a>An Introduction to the Compute Express LinkTM (CXLTM) Interconnect</h1><h2 id="INTRODUCTION"><a href="#INTRODUCTION" class="headerlink" title="INTRODUCTION"></a>INTRODUCTION</h2><p>没有CXL的PCIe连接存在的挑战：</p><ol><li>无法实现对系统和设备内存的一致性访问，设备内存无法映射到可缓存的系统地址空间<br>（有没有人做基于CXL的CPUGPU统一地址空间？）</li><li>内存可拓展性差：PCIe带宽不错，但是不支持一致性的内存空间，所以无法直接做内存拓展</li><li>由于资源闲置导致的内存和计算资源的浪费</li><li>分布式系统经常细粒度同步，通信延迟高导致需要数据共享</li></ol><p>CXL能做的<br>缓存一致性、可拓容、内存池、共享内存</p><h2 id="CXL1-1"><a href="#CXL1-1" class="headerlink" title="CXL1.1"></a>CXL1.1</h2><h3 id="CXL-68-byte-Flit"><a href="#CXL-68-byte-Flit" class="headerlink" title="CXL 68 byte Flit"></a>CXL 68 byte Flit</h3><p>CXL协议的传输单元：Flit (FlowControl Unit).1.0 1.1 2.0是68字节，3.0引入了256字节<br>2字节协议ID，64字节负载，2字节的CRC<br>协议 ID 描述了不同类型的数据包，并具有内置冗余来检测和纠正这 2 个字节内的多个位翻转。<br><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/20230920164915.png" alt="image.png"></p><h3 id="CXL-IO-protocol"><a href="#CXL-IO-protocol" class="headerlink" title="CXL IO protocol"></a>CXL IO protocol</h3><p>描述了IO协议定义的事务顺序</p><h3 id="CXL-cache-protocol"><a href="#CXL-cache-protocol" class="headerlink" title="CXL cache protocol"></a>CXL cache protocol</h3><p>host管理一致性，由H2D请求来改变设备的状态，这种请求叫snooping(snp)</p><p>CXL cache使设备能缓存主机内存，cache line是64字节,MESI协议。host管理所有peer cache的一致性而设备不交互。<br>两个方向三个通道 H2D D2H 请求、响应、数据通道。流通道可以独立地在每个方向上进行数据传输，但有一个例外情况：当主机在H2D请求通道中发送一个Snoop消息时，必须在H2D响应通道中推送一个先前的全局观察（GO）消息，用于同一个缓存行地址。GO消息向设备指示一致性协议和一致性承诺点<br>设备使用的是主机的物理地址，设备需要实现设备快表DTLB来缓存页表，使用PCIe(CXL io)的之地转换服务(ATS)来获取虚拟到物理的转换以及访问控制。DTLB是非一致的，所以需要主机跟踪DTLB中挂起的条码，并发起无效操作</p><blockquote><p>PCIe的ATS代表Address Translation Services（地址转换服务）。ATS是PCIe规范中引入的一项功能，用于提高虚拟化环境中设备的性能和可扩展性。<br>在传统的PCIe架构中，设备通过物理地址进行内存访问。然而，在虚拟化环境中，多个虚拟机共享同一个物理设备时，每个虚拟机可能拥有自己的虚拟地址空间。这就需要一种机制来进行物理地址到虚拟地址的转换，以确保每个虚拟机都可以正确地访问其分配的内存。<br>ATS提供了这种地址转换的服务。当设备支持ATS时，它可以向系统报告其支持的地址转换功能。主机通过ATS命令将虚拟地址发送给设备，并由设备执行地址转换，将虚拟地址映射到物理地址。这样，每个虚拟机都可以独立地进行内存访问，而不会干扰其他虚拟机或主机系统。<br>通过使用ATS，虚拟化环境中的设备可以更高效地进行内存访问，减少了主机系统的干预，提高了设备性能和整体系统的可扩展性。它为虚拟化环境中的设备提供了更好的隔离性和灵活性。</p></blockquote><h4 id="D2H-请求"><a href="#D2H-请求" class="headerlink" title="D2H 请求"></a>D2H 请求</h4><p>15个命令分为四类：Read,Read0,Read0-Write,Write</p><ul><li>Read:设备请求一致性状态和数据。 得到的响应是H2D 的response中的一致性状态和H2D数据</li><li>Read0:仅请求0数据(地址无效或者未分配)，意味着不需要数据。作用是升级缓存中的现有数据(S-&gt;E)或在预计写入整个缓存行时进入 E 状态。得到的响应是一致性状态</li><li>Read0-Write:直接将数据写入主机，无需在发出前有任何一致性状态。当主机准备好接受 D2H 数据时，H2D 响应将指示“WritePull”，并且主机将在指示系统“全局观察”(GO) 数据之前解决一致性问题。</li><li>Write：用于设备从设备缓存中逐出数据。这些请求可以针对脏数据（M 状态）或干净数据（E 或 S 状态）。当设备需要提供数据时，主机会指示“WritePull”，并指示 GO</li></ul><h4 id="H2D请求"><a href="#H2D请求" class="headerlink" title="H2D请求"></a>H2D请求</h4><p>H2D请求用于主机改变设备中的一致性状态，这种请求被称为Snooping（snp）。设备根据snp的要求更新缓存，并在缓存状态为M时将数据写回主机</p><p>一致性协议的一个关键组成部分是它如何处理同一地址的冲突访问。有两种情况需要重点强调：(1) 请求到窥探，以及 (2) 驱逐到窥探。对于设备的 Req-to-Snoop 确定如何响应，H2D 响应通道上的 GO 消息必须排在任何未来到相同缓存行地址的 Snoop 之前。其原因如图 8A 所示，其中必须在稍后的侦听之前观察从主机发送的 GO 消息，以便设备知道它具有该地址的独占所有权并可以正确处理侦听。图 8B 是相反顺序的情况，其中主机首先处理探听，并将停止未来的请求，直到探听完成，因此设备在 GO 之前观察探听会导致在缓存处于无效状态时处理探听。对于 Evict-to-Snoop，图 8C 显示了当 DirtyEvict 未完成时监听到达的情况，并且设备必须使用当前 M 状态数据回复监听。稍后的 GO_WritePull 仍必须返回数据，但包括数据是伪造的（意味着可能已过时）的指示，因此主机必须删除数据，因为其他代理中可能存在更新的数据。</p><h3 id="CXL-mem-Protocol"><a href="#CXL-mem-Protocol" class="headerlink" title="CXL mem Protocol"></a>CXL mem Protocol</h3><p>mem协议允许设备暴露Host-managed Device Memory(HDM)。允许主机像访问DDR一样访问HDM。mem协议独立于所使用的介质，使用一组简单的读取和写入主机物理地址，要求设备在内部转换为设备的介质地址空间。对于还希望缓存该内存的加速器设备，提供了高级语义以使设备能够直接缓存该内存，依赖于该设备来跟踪该内存的主机缓存。</p><p>两个方向，两个通道：Master-to-Subordinate (M2S) and Subordinate-toMaster (S2M).<br>M2S提供Request channel,Request-with-Data(RwD) channel.S2M 提供Non-Data-Response (NDR) channel and Data-ReSponse (DRS) channel.为了实现简单&#x2F;低延迟的实现，通道之间没有顺序。</p><p>mem的两个用途：主机内存拓展、暴露给主机的加速器内存。为了区分，使用不同的修饰符表示，HDM-H表示host-only coherent，不包含一致性协议，用于type3设备，HDM-D表示Device-managed coherent， 包含缓存状态和缓存监听属性，用于type2设备。HDM-D 还需要一种将存储器的所需缓存状态从设备传输到主机的方法，称为“偏置翻转”流</p><p>HDM-H 可选择为每个缓存行提供 2 位meta value以供主机使用。没看出在这有啥用，应该是后面版本一致性问题用到的</p><p>HDM-D 一致性模型允许设备使用 CXL.cache 请求更改主机的状态来实现此目的。 CXL.cache 是执行此操作的自然方法，因为 HDM-D 仅针对 Type-2 设备定义，以便可以使用 CXL.cache 协议。<br>具体来说就是H2S的snp指明主机一致性状态，rsp更新主机的一致性状态</p><p>Device Coherence (Dcoh) agent：描述设备中的代理管理&#x2F;跟踪设备和主机的一致性</p><h3 id="协议层次"><a href="#协议层次" class="headerlink" title="协议层次"></a>协议层次</h3><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/20231024172417.png" alt="image.png"></p><p>cache协议是device如图cpu的core一样，都连接在LLC上，mem协议在home agent之后，CPU通过mem协议访问HDM如图访问DRAM一样。</p><p>home agent解决主机间的缓存一致性问题（被BI替代）</p><h2 id="CXL2-0"><a href="#CXL2-0" class="headerlink" title="CXL2.0"></a>CXL2.0</h2><p>特点：支持池化，在运行时重新分配资源、单层switch、QoS、热插拔、全局持久刷新(GPF)</p><p>为了支持switch，每个主机将 CXL 拓扑表示为虚拟层次结构 (VH)，包括主机端口的交换机和虚拟网桥以及具有设备资源的每个端口，每个主机都会看到一个单独的 VCS（虚拟 CXL 交换机）其中包括分配给该主机的设备的网桥，这将 CXL 2.0 限制为有向树拓扑，每个主机和设备之间最多有一条路径。此外，跟踪交换机中每个 VH 地址映射的需要限制了单交换机级别的可扩展性，CXL 3.0 克服了这一限制（第 5.3 节）。</p><p>SLD:一个设备分配给一个主机<br>MLD:一个设备分配给多个主机<br>MLD中的逻辑设备LD由标识符 (LD-ID) 标识。此扩展仅在交换机和设备之间的链路上可见，对主机不可见。主机将 LD-ID 字段留空。 CXL 交换机根据主机的端口将 LD-ID 标签应用于主机的 CXL.io 和 CXL.mem 事务。</p><p>switch的存在会带来服务质量问题，比如一台设备的低性能可能会导致使用该交换机的所有代理发生拥塞。为了缓解此问题，CXL 2.0 在 CXL.mem 响应消息中引入了 DevLoad 字段，以通知主机在其正在访问的设备中观察到的负载。主机应使用此负载信息来降低向该设备发送 CXL 请求的速率。 CXL 规范定义了一个参考模型，以便在高负载或临界负载时降低注入速率，直到达到标称负载，而在轻负载时，主机可以增加注入速率，直到达到标称负载。</p><h3 id="池管理"><a href="#池管理" class="headerlink" title="池管理"></a>池管理</h3><p>CXL Fabric Manager (FM) 来进行管理，FM是逻辑概念，可以是在主机上运行的软件、嵌入底板管理控制器 (BMC) 或 CXL 交换机内的固件，或者是专用设备。</p><p>主机的设备分配由 FM 通过 bind 命令完成，该命令采用四个参数：CXL 交换机 ID、虚拟网桥 ID、物理端口 ID 和逻辑设备 ID（对于 SLD 为空）。FM 将此命令发送到指定的交换机，该交换机检查该物理端口当前是否未绑定。如果未绑定，交换机会更新其内部状态以执行绑定。然后向主机发送热添加指示，最后通知 FM 绑定成功。虚拟网桥和关联设备现在出现在主机的虚拟层次结构中。</p><p>对于 MLD，FM 可能需要首先通过 Set-LD 命令配置逻辑设备。。创建LD后，FM可以使用bind命令和相应的LD-ID将它们分配给主机。要撤消设备分配，FM 使用 unbind 命令，该命令采用三个参数：CXL 交换机 ID、虚拟网桥 ID 和取消绑定选项。 </p><p>除了此处描述的三个命令之外，FM 还支持其他 19 个命令。它们包括 QoS 控制，例如 MLD 内逻辑设备之间的带宽分配。这些命令还包括识别交换机端口和设备以及查询和配置其状态的方法</p><h3 id="主机软件支持"><a href="#主机软件支持" class="headerlink" title="主机软件支持"></a>主机软件支持</h3><p>尽管 CXL 的大部分是在主机外部的硬件和软件（例如 FM）中实现的，但主机软件在支持 CXL 方面发挥着重要作用。在较高级别上，系统固件枚举并配置启动时存在的 CXL 资源。操作系统 (OS) 枚举并配置在运行时附加和分离的 CXL 资源，例如热添加和热删除的内存地址范围。因此，操作系统在支持 CXL 2.0 方面发挥着重要作用。<br>CXL 2.0 引入了一致设备属性表 (CDAT)，它描述了内部 NUMA 域、内存范围、带宽、延迟和内存使用建议 [47, 48]。当在运行时热添加内存（逻辑）设备时，主机读取关联的 CDAT 寄存器，操作系统分配空闲的 HPA 范围并对 HDM 解码器进行编程。</p><h2 id="CXL-3-0"><a href="#CXL-3-0" class="headerlink" title="CXL 3.0"></a>CXL 3.0</h2><p>特点</p><ul><li>拓展了内存池化，更多的设备，更大的flit，低延迟大带宽</li><li>多级switch，支持网状拓扑，这可实现更低的延迟、更高的二等分带宽和故障转移功能</li><li>支持点对点访问HDM，不涉及host</li><li>跨主机共享一致性内存和消息传递</li><li>近内存处理允许在内存附近执行计算，以获得更好的性能和能耗。</li></ul><h3 id="支持64GT-s的Flit"><a href="#支持64GT-s的Flit" class="headerlink" title="支持64GT&#x2F;s的Flit"></a>支持64GT&#x2F;s的Flit</h3><p>3.0拓展了Flit的格式，使其变为256B，支持PCIe6.0的64GT&#x2F;s速率<br>任何设备都支持32GT&#x2F;s的速率，如果 CXL 设备支持 64.0 GT&#x2F;s 数据速率，则它还必须通告 256B Flit 模式</p><h3 id="点对点通信和映射大块本地内存"><a href="#点对点通信和映射大块本地内存" class="headerlink" title="点对点通信和映射大块本地内存"></a>点对点通信和映射大块本地内存</h3><p>实现原理：Unordered I&#x2F;O(UIO)和Back-Invalidation(BI)</p><p>由于PCIe Ordering规则的限制，只允许存在非树形拓扑结构，也就是说在任意两个节点（主机或设备）之间只存在一条路径。<br>CXL 3.0（以及PCIe）通过在一个或多个独立的虚拟通道（VCs）上引入”unordered”读&#x2F;写&#x2F;完成事务，并将顺序强制转移到源节点来解决了这个挑战</p><p>CXL 3.0 在 CXL.mem 中引入了带有两个新通道：S2M方向的Back-Invalidate (BI)，M2S方向的BI-Rsp。实现了三种用途：</p><ol><li>通过 CXL.io UIO 访问 HDM-DB 内存的 CXL&#x2F;PCIe 设备之间的直接对等通信（如图 17 所示）</li><li>Type-2 设备实现监听的能力-过滤大块本地内存并将其映射到HDM-DB区域（如图18a所示）</li><li>以及跨多个独立主机的硬件强制一致共享内存（图18b）。</li></ol><p>在 CXL.mem 中包含 BI 的理由是确保不存在避免死锁所需的其他依赖项</p><h4 id="点对点通信"><a href="#点对点通信" class="headerlink" title="点对点通信"></a>点对点通信</h4><p>如果是CXL2.0，当与switch连接的device需要访问HDM-D的内存，休要经过host，这包括主机从内存中获取数据并在完成访问之前解决一致性流程。</p><p>在CXL 3.0流程中（图17c），设备可以直接使用UIO VC中的CXl.io发送相同的内存读写事务。开关不会将这些UIO事务路由到主机。在某些缓存行状态下，UIO事务可以直接从内存中服务。</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/20231024154103.png" alt="image.png"></p><ul><li>如果UIO读取的缓存行状态为I（无效）或S（共享），或者UIO写入的状态为I，那么UIO事务将直接从内存服务。</li><li>如有需要，内存控制器会使用BI流程进行反向监控主机处理器。这比传统方法更具带宽效率，传统方法是将所有请求发送到主机，导致更多的流量和额外的延迟。</li></ul><h4 id="设备监听能力"><a href="#设备监听能力" class="headerlink" title="设备监听能力"></a>设备监听能力</h4><h4 id="跨host缓存一致性"><a href="#跨host缓存一致性" class="headerlink" title="跨host缓存一致性"></a>跨host缓存一致性</h4><p>BI机制还能够实现跨多个主机的共享和硬件强制的一致性内存，如图18b所示。在这里，内存设备（GFD&#x2F;MLD）维护一个目录（或Snoop Filter），以跟踪一致性共享内存中缓存行的所有权。因此，当Host 1以共享副本的形式获取缓存行X的所有权时，它将目录从“I”状态更新为“S”状态，并将Host 1标记为共享者。当Host 3以相同的共享状态请求相同的缓存行X时，它提供数据并更新X的目录以指示Host 1和Host 3都已共享。当Host 4请求独占副本时，它向Host 1和Host 3发出Back Invalidate，等待两者的响应以确保Host 1和Host 3已失效其对X的副本，并在发送数据和所有权给Host 4之前，将其目录更新为Host 4标记的“E”状态。这个内存设备可以是多逻辑设备（MLD）或GFD设<br><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/20231024154852.png" alt="image.png"></p><h3 id="Port-Base-Routing-PBR-基于端口的路由"><a href="#Port-Base-Routing-PBR-基于端口的路由" class="headerlink" title="Port Base Routing (PBR) 基于端口的路由"></a>Port Base Routing (PBR) 基于端口的路由</h3><p>目的：能够拓展到4096的端点和非树网络拓扑</p><p>分层路由要求交换机了解每个主机的虚拟分层结构和地址映射。CXL 3.0 继续对大多数端点和第一台交换机之间的链路使用标准 CXL 2.0 消息，连接到设备或主机的第一个交换机端口称为“边缘端口”，因为它在标准消息 (HBR) 和 PBR 消息之间转换方面具有特殊作用。 </p><p>然后详细介绍了这个算法的具体内容</p><h1 id="CXL-缓存一致性"><a href="#CXL-缓存一致性" class="headerlink" title="CXL 缓存一致性"></a>CXL 缓存一致性</h1><p>ex1<br>多个host共享访问内存，其中一个host独占请求<br>其他host正常请求响应，独占请求的host需要DOCH发BIreq，然后其他host无效化，再返回BIres，这个开销是额外的开销</p><p>ex2<br>多个host共享访问内存，当一个host独占请求，且该内容已经被修改，需要修改的host flush回cxlmem 再返回独占host</p><p>ex3<br>无cache访问，类似stream_load</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;CXL简介：&quot;&gt;&lt;a href=&quot;#CXL简介：&quot; class=&quot;headerlink&quot; title=&quot;CXL简介：&quot;&gt;&lt;/a&gt;CXL简介：&lt;/h1&gt;&lt;p&gt;&lt;a</summary>
        
      
    
    
    
    
    <category term="cxl" scheme="https://mightcoder.com/tags/cxl/"/>
    
    <category term="存储" scheme="https://mightcoder.com/tags/%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title>性能优化技巧总结</title>
    <link href="https://mightcoder.com/2023/10/25/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/"/>
    <id>https://mightcoder.com/2023/10/25/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/</id>
    <published>2023-10-25T13:01:37.000Z</published>
    <updated>2023-10-25T04:00:29.488Z</updated>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0.前言"></a>0.前言</h2><p>本文是我的性能优化经验的一点总结，主要是通过各种优化竞赛积累下的经验，有些方法也适用于工程中。写这篇文章本意是作为自己的备忘录，如果能够给初学者朋友们一点帮助那就更好了。</p><p>本文应该会持续更新，我会把学到的优化方法和技巧都记录下来。</p><h2 id="1-使用工具分析程序，找到热点"><a href="#1-使用工具分析程序，找到热点" class="headerlink" title="1.使用工具分析程序，找到热点"></a>1.使用工具分析程序，找到热点</h2><p>优化的前提是抓住重点，找到程序热点。</p><blockquote><p>工欲善其事，必先利其器</p></blockquote><ul><li>vtune：intel平台的话vtune已经十分好用了</li><li>gperftools：谷歌的性能优化工具集</li><li>perf：linux内核性能分析工具</li><li>nsight compute\system：cuda性能分析</li><li>返璞归真，手动插桩</li></ul><h2 id="2-预处理（减少重复计算）"><a href="#2-预处理（减少重复计算）" class="headerlink" title="2.预处理（减少重复计算）"></a>2.预处理（减少重复计算）</h2><p>首先应当仔细阅读代码，理清代码结构，尽可能的通过预处理等手段减少不必要的计算，比如将循环中多次计算提前一次性算出等。这一步是很有必要的，因为大多数情况下程序的baseline都有许多重复计算，同时这一步也是后续优化的基础。</p><h2 id="3-优化算法，降低时间复杂度"><a href="#3-优化算法，降低时间复杂度" class="headerlink" title="3.优化算法，降低时间复杂度"></a>3.优化算法，降低时间复杂度</h2><p>优化计算密集型程序最有效的方法就是降低时间复杂度了，当然这一步是相当困难的，但有些算法或者算法的某个部分是可以降低时间复杂度的。针对算法的优化虽然困难，但是成效通常是显著的，在很多比赛中是否优化算法往往是胜负的关键。</p><h2 id="4-合适的并行策略"><a href="#4-合适的并行策略" class="headerlink" title="4.合适的并行策略"></a>4.合适的并行策略</h2><p>并行不是简单的<code>#pragma omp parallel for</code>就可以的，这部分值得单独写好几篇文章，简单的提几点技巧，在并行过程中要尽量保证：</p><ul><li>增大并行粒度，充分利用硬件资源</li><li>保证负载均衡，避免某个核心计算工作工作过多而其他的核心空闲的情况</li><li>尽可能减少通信开销，可以采用局部变量这种空间换时间的方法</li></ul><p>另外，根据情况选择合适的并行模型也很重要，很多情况下openmp已经够用，但多节点的情况下，MPI显然更适合，而std::thread能够更灵活的解决问题。</p><h2 id="5-访存优化"><a href="#5-访存优化" class="headerlink" title="5.访存优化"></a>5.访存优化</h2><p>访存优化：访存优化实在太常见也太重要了，其内容可以展开写一系列文章，这里只提供一些简单的思路和技巧</p><p>理解cache的重要性：访问cache的时延远远小于访问RAM的时延。<br>利用时间局部性和空间局部性来充分利用cache。</p><ul><li>保证数组的访存连续，这是最基本要做到的，一般是在循环中保证数组是行访问（cpp）。</li><li>AOS转SOA：将array of struct 转换为struct of array，这样会有利于进行向量化</li><li>循环分块：将循环数据切分成小的块，提高cache命中率。</li><li>数据对齐：从内存中访问对齐的数据效率要高一些。</li><li>计算与访存重合overlap，隐藏访问延迟</li></ul><h2 id="6-向量化"><a href="#6-向量化" class="headerlink" title="6.向量化"></a>6.向量化</h2><p>向量化也是性能优化的常用手段，通常编译器会自动进行向量化，但是往往很难达到256&#x2F;512位向量化。在比赛中为了极限压榨性能，可以手动进行256或者512位向量化。</p><p><a href="https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#techs=AVX,AVX2&ig_expand=5997,5997,6596,4604&text=max">Intel® Intrinsics Guide</a></p><h2 id="7-线程绑定"><a href="#7-线程绑定" class="headerlink" title="7.线程绑定"></a>7.线程绑定</h2><p>CPU绑定是对进程或线程设置相应的CPU Affinity，确保进程或线程只会在设置有相应标志位的CPU上运行，进而提高应用程序对CPU的使用效率。如果应用进程可以在多个CPU上运行，操作系统会在CPU之间频繁切换应用，引起CPU缓存失效，降低缓存的命中率，导致CPU使用效率下降。使用CPU绑定技术可以在一定程度上会避免CPU Cache失效，提升系统性能。</p><p>比如如果使用openmp并行，可以使用以下命令进行绑定<code>export OMP_PROC_BIND=true</code>。</p><p><a href="https://lab.cs.tsinghua.edu.cn/hpc/doc/faq/binding/">https://lab.cs.tsinghua.edu.cn/hpc/doc/faq/binding/</a></p><p> <a href="......%5CPAC%E8%B5%84%E6%96%99%5Copenmp_document.pdf">openmp_document.pdf</a> </p><h2 id="8-编译器优化"><a href="#8-编译器优化" class="headerlink" title="8.编译器优化"></a>8.编译器优化</h2><p>c++编译器种类有很多，除了gcc外，还有icpc（intel）、aocc（amd）等，但是要注意icc和aocc虽然针对自己的架构有优化，但是其性能<strong>未必</strong>会比gcc快，需要尝试找出最快的编译器。</p><p>另外，不同版本的gcc的性能也会不同，可以考虑替换比赛平台较老的编译器为版本较新的编译器。</p><p>除了直接更换编译器外，还可以通过编译选项来提高程序性能，虽然除了-O3意外可能效果聊胜于无。这里推荐一个大佬总结的帖子<a href="http://home.ustc.edu.cn/~shaojiemike/posts/gcccompileroption/">gcc Compiler Option &#x2F;&#x2F; 谭邵杰的计算机奇妙旅程 (ustc.edu.cn)</a></p><p><a href="https://zhuanlan.zhihu.com/p/496435946">GCC编译器高效利用cache的原理和参数 - 知乎 (zhihu.com)</a></p><h2 id="9-框架版本"><a href="#9-框架版本" class="headerlink" title="9.框架版本"></a>9.框架版本</h2><p>同一个框架的不同版本也会有性能差异，比如我曾经遇到过不同版本的MPI，其init时间相差极大，从几十毫秒到几秒，多尝试几个版本直到找到最快的版本。</p><h2 id="10-循环优化"><a href="#10-循环优化" class="headerlink" title="10.循环优化"></a>10.循环优化</h2><p>循环交换<br>循环预处理<br>循环合并<br>循环拆分<br>循环展开（手动）<br>向量化<br>循环分块</p><h2 id="11-混合精度"><a href="#11-混合精度" class="headerlink" title="11.混合精度"></a>11.混合精度</h2><p>降低精度需要对代码分析来判断降低精度或者转换精度是否对结果有影响，最常见的是用单精度甚至半精度来替换双精度浮点数。也可以在计算的某个步骤降低精度，其他步骤保留原来精度，避免结果有较大误差。</p><h2 id="12-量化"><a href="#12-量化" class="headerlink" title="12.量化"></a>12.量化</h2><p>用低精度的定点数（4、8、16位）来代表浮点数，降低存储，加速计算。</p><p>量化会降低精度，要AI模型不在意精度很适合，但是HPC应用要注意计算误差，恢复误差。</p><p><a href="https://www.bilibili.com/video/BV1YF411y7tg/?spm_id_from=333.999.0.0">PAC大讲堂 并行计算进阶课程 2&#x2F;7并行程序的插装分析 精度量化和误差分析_哔哩哔哩_bilibili</a></p><h2 id="13-跨NUMA访存优化"><a href="#13-跨NUMA访存优化" class="headerlink" title="13.跨NUMA访存优化"></a>13.跨NUMA访存优化</h2><p>当优化到后期，由于跨NUMA的访存问题，导致性能下降，尽可能使计算在一个NUMA节点下。可以将进程限制在一个NUMA node上。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numactl --cpunodebind=0 --membind=0 &lt;command&gt;</span><br></pre></td></tr></table></figure><h2 id="14-循环、算子融合"><a href="#14-循环、算子融合" class="headerlink" title="14.循环、算子融合"></a>14.循环、算子融合</h2><p>kernel fusion(算子融合)是异构计算中的概念，指将不同的kernel合并成一个kernel，这样的话后面的kernel能够利用前面kernel访问到的数据或者计算的结果，减少访存，并且消除kernel间的通信。kernel融合还有可能提高并行度，充分利用计算资源。</p><p>循环融合就是合并迭代空间相同的循环，之所以跟kernel fusion放在一起是这两个都是利用了局部性，有相似性。</p><h2 id="15-位运算"><a href="#15-位运算" class="headerlink" title="15.位运算"></a>15.位运算</h2><ul><li>位运算代替算术运算和逻辑运算，速度更快</li><li>位存储节省空间，加速访存</li></ul><p><a href="https://www.zhihu.com/question/38206659">(2 封私信 &#x2F; 2 条消息) 位运算有什么奇技淫巧？ - 知乎 (zhihu.com)</a></p><h2 id="16-使用高性能的算法库、数学库"><a href="#16-使用高性能的算法库、数学库" class="headerlink" title="16.使用高性能的算法库、数学库"></a>16.使用高性能的算法库、数学库</h2><p>intel：OneAPI系列 mkl<br>nvdia：cuBLAS  cuFFT  cuSOLVER<br>amd：rocblas </p><p>BLAS LAPACK </p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;0-前言&quot;&gt;&lt;a href=&quot;#0-前言&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    
    <category term="hpc" scheme="https://mightcoder.com/tags/hpc/"/>
    
    <category term="竞赛" scheme="https://mightcoder.com/tags/%E7%AB%9E%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>Cmake</title>
    <link href="https://mightcoder.com/2023/05/28/cmake/"/>
    <id>https://mightcoder.com/2023/05/28/cmake/</id>
    <published>2023-05-28T13:39:37.000Z</published>
    <updated>2023-05-26T10:50:21.566Z</updated>
    
    <content type="html"><![CDATA[<h2 id="cmake步骤"><a href="#cmake步骤" class="headerlink" title="cmake步骤"></a>cmake步骤</h2><ol><li><p>编写源代码</p></li><li><p>编写<code>CMakeList.txt</code></p></li><li><pre><code class="makefile">cmake [`CMakeList.txt`所在的目录]<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   这将生成makefile</span><br><span class="line"></span><br><span class="line">4. ```makefile</span><br><span class="line">   make [makefile所在的目录]</span><br></pre></td></tr></table></figure>编译完成</code></pre></li></ol><h2 id="cmake关键字"><a href="#cmake关键字" class="headerlink" title="cmake关键字"></a>cmake关键字</h2><h3 id="PROJECT关键字"><a href="#PROJECT关键字" class="headerlink" title="PROJECT关键字"></a>PROJECT关键字</h3><p>可以用来指定工程的名字和支持的语言，默认支持所有语言</p><p>PROJECT (HELLO)   指定了工程的名字，并且支持所有语言—建议</p><p>PROJECT (HELLO CXX)      指定了工程的名字，并且支持语言是C++</p><p>PROJECT (HELLO C CXX)      指定了工程的名字，并且支持语言是C和C++</p><p>该指定隐式定义了两个CMAKE的变量</p><p><projectname>_BINARY_DIR，本例中是 HELLO_BINARY_DIR</p><p><projectname>_SOURCE_DIR，本例中是 HELLO_SOURCE_DIR</p><p>MESSAGE关键字就可以直接使用者两个变量，当前都指向当前的工作目录，后面会讲外部编译</p><p>问题：如果改了工程名，这两个变量名也会改变</p><p>解决：又定义两个预定义变量：PROJECT_BINARY_DIR和PROJECT_SOURCE_DIR，这两个变量和HELLO_BINARY_DIR，HELLO_SOURCE_DIR是一致的。所以改了工程名也没有关系</p><h3 id="SET关键字"><a href="#SET关键字" class="headerlink" title="SET关键字"></a>SET关键字</h3><p>用来显示的指定变量的</p><p>SET(SRC_LIST main.cpp)    SRC_LIST变量就包含了main.cpp</p><p>也可以 SET(SRC_LIST main.cpp t1.cpp t2.cpp)</p><h3 id="MESSAGE关键字"><a href="#MESSAGE关键字" class="headerlink" title="MESSAGE关键字"></a>MESSAGE关键字</h3><p>向终端输出用户自定义的信息</p><p>主要包含三种信息：</p><ul><li>SEND_ERROR，产生错误，生成过程被跳过。</li><li>SATUS，输出前缀为—的信息。</li><li>FATAL_ERROR，立即终止所有 cmake 过程.</li></ul><h3 id="ADD-EXECUTABLE关键字"><a href="#ADD-EXECUTABLE关键字" class="headerlink" title="ADD_EXECUTABLE关键字"></a>ADD_EXECUTABLE关键字</h3><p>生成可执行文件</p><p>ADD_EXECUTABLE(hello ${SRC_LIST})     生成的可执行文件名是hello，源文件读取变量SRC_LIST中的内容</p><p>也可以直接写 ADD_EXECUTABLE(hello main.cpp)</p><p>上述例子可以简化的写成</p><p>PROJECT(HELLO)<br>ADD_EXECUTABLE(hello main.cpp)</p><p>注意：工程名的 HELLO 和生成的可执行文件 hello 是没有任何关系的</p><h2 id="cmake-语法"><a href="#cmake-语法" class="headerlink" title="cmake 语法"></a>cmake 语法</h2><ul><li><p>变量使用${}方式取值，但是在 IF 控制语句中是直接使用变量名</p></li><li><p>指令(参数 1 参数 2…) 参数使用括弧括起，参数之间使用空格或分号分开。 以上面的 ADD_EXECUTABLE 指令为例，如果存在另外一个 func.cpp 源文件</p><p>就要写成：ADD_EXECUTABLE(hello main.cpp func.cpp)或者ADD_EXECUTABLE(hello main.cpp;func.cpp)</p></li><li><p>指令是大小写无关的，参数和变量是大小写相关的。但，推荐你全部使用大写指令</p></li></ul><h3 id="语法注意事项"><a href="#语法注意事项" class="headerlink" title="语法注意事项"></a>语法注意事项</h3><ul><li>SET(SRC_LIST main.cpp) 可以写成 SET(SRC_LIST “main.cpp”)，如果源文件名中含有空格，就必须要加双引号</li><li>ADD_EXECUTABLE(hello main) 后缀可以不行，他会自动去找.c和.cpp，最好不要这样写，可能会有这两个文件main.cpp和main</li></ul><h2 id="内部构建和外部构建"><a href="#内部构建和外部构建" class="headerlink" title="内部构建和外部构建"></a>内部构建和外部构建</h2><p>上面的例子就是内部构建，生产的临时晚间特别多，不方便清理</p><p>外部构建，就会把生成的临时文件放在build目录下，推荐使用外部构建</p><ol><li><p>在项目根目录下创建build目录</p></li><li><pre><code class="shell">cd ./buildbuild ..<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   此时的&lt;projectname&gt;_BINARY_DIR变量变为`\root\project\build`</span><br><span class="line"></span><br><span class="line">   &lt;projectname&gt;_SOURCE_DIR变为`\root\project`</span><br><span class="line"></span><br><span class="line">3. 直接在build目录下make</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">## 工程化的cmake（父子`CMakeList`）</span><br><span class="line"></span><br><span class="line">在父目录下的`CMakeList`中添加`ADD_SUBDIRECTORY(src bin)`</span><br><span class="line"></span><br><span class="line">意思是src目录下源码生成的二进制文件都会放到bin目录下，如果不加bin，那么编译结果（包括中间结果）都将存放在build/src目录</span><br><span class="line"></span><br><span class="line">在src这个子目录下`CMakeList`的主要语句是`ADD_EXECUTABLE(hello main.cpp)`</span><br><span class="line"></span><br><span class="line">## 使用cmake安装</span><br><span class="line"></span><br><span class="line">### 安装文件COPYRIGHT和README</span><br><span class="line"></span><br><span class="line">INSTALL(FILES COPYRIGHT README DESTINATION share/doc/cmake/)</span><br><span class="line"></span><br><span class="line">FILES：文件</span><br><span class="line"></span><br><span class="line">DESTINATION：</span><br><span class="line"></span><br><span class="line">1、写绝对路径</span><br><span class="line"></span><br><span class="line">2、可以写相对路径，相对路径实际路径是：$&#123;CMAKE_INSTALL_PREFIX&#125;/&lt;DESTINATION 定义的路径&gt;</span><br><span class="line"></span><br><span class="line">CMAKE_INSTALL_PREFIX  默认是在 /usr/local/</span><br><span class="line"></span><br><span class="line">cmake -DCMAKE_INSTALL_PREFIX=/usr    在cmake的时候指定CMAKE_INSTALL_PREFIX变量的路径</span><br><span class="line"></span><br><span class="line">### 安装脚本</span><br><span class="line"></span><br><span class="line">PROGRAMS：非目标文件的可执行程序安装(比如脚本之类)</span><br><span class="line"></span><br><span class="line">INSTALL(PROGRAMS runhello.sh DESTINATION bin)</span><br><span class="line"></span><br><span class="line">说明：实际安装到的是 /usr/bin</span><br><span class="line"></span><br><span class="line">### 安装 doc 中的 文件</span><br><span class="line"></span><br><span class="line">- 一、是通过在 doc 目录建立CMakeLists.txt ，通过install下的file</span><br><span class="line"></span><br><span class="line">- 二、是直接在工程目录通过</span><br><span class="line"></span><br><span class="line">  INSTALL(DIRECTORY doc/ DESTINATION share/doc/cmake)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DIRECTORY 后面连接的是所在 Source 目录的相对路径</span><br><span class="line"></span><br><span class="line">注意：abc 和 abc/有很大的区别</span><br><span class="line"></span><br><span class="line">目录名不以/结尾：这个目录将被安装为目标路径下的</span><br><span class="line"></span><br><span class="line">目录名以/结尾：将这个目录中的内容安装到目标路径</span><br><span class="line"></span><br><span class="line">### 安装过程</span><br><span class="line"></span><br><span class="line">cmake ..</span><br><span class="line"></span><br><span class="line">make</span><br><span class="line"></span><br><span class="line">make install</span><br><span class="line"></span><br><span class="line">## 静态库和动态库的构建</span><br><span class="line"></span><br><span class="line">需要创建lib目录，在lib目录下创建`CMakeList`，内容为</span><br><span class="line"></span><br><span class="line">```cmake</span><br><span class="line">SET(LIBHELLO_SRC hello.cpp)</span><br><span class="line">ADD_LIBRARY(hello SHARED $&#123;LIBHELLO_SRC&#125;)</span><br></pre></td></tr></table></figure></code></pre></li></ol><h3 id="同时构建静态和动态库"><a href="#同时构建静态和动态库" class="headerlink" title="同时构建静态和动态库"></a>同时构建静态和动态库</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 如果用这种方式，只会构建一个动态库，不会构建出静态库，虽然静态库的后缀是.a</span><br><span class="line"><span class="keyword">ADD_LIBRARY</span>(hello SHARED <span class="variable">$&#123;LIBHELLO_SRC&#125;</span>)</span><br><span class="line"><span class="keyword">ADD_LIBRARY</span>(hello STATIC <span class="variable">$&#123;LIBHELLO_SRC&#125;</span>)</span><br><span class="line"></span><br><span class="line">// 修改静态库的名字，这样是可以的，但是我们往往希望他们的名字是相同的，只是后缀不同而已</span><br><span class="line"><span class="keyword">ADD_LIBRARY</span>(hello SHARED <span class="variable">$&#123;LIBHELLO_SRC&#125;</span>)</span><br><span class="line"><span class="keyword">ADD_LIBRARY</span>(hello_static STATIC <span class="variable">$&#123;LIBHELLO_SRC&#125;</span>)</span><br></pre></td></tr></table></figure><h3 id="SET-TARGET-PROPERTIES"><a href="#SET-TARGET-PROPERTIES" class="headerlink" title="SET_TARGET_PROPERTIES"></a>SET_TARGET_PROPERTIES</h3><p>这条指令可以用来设置输出的名称，对于动态库，还可以用来指定动态库版本和 API 版本</p><p>同时构建静态和动态库</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span>(LIBHELLO_SRC hello.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD_LIBRARY</span>(hello_static STATIC <span class="variable">$&#123;LIBHELLO_SRC&#125;</span>)</span><br><span class="line"></span><br><span class="line">//对hello_static的重名为hello</span><br><span class="line"><span class="keyword">SET_TARGET_PROPERTIES</span>(hello_static PROPERTIES  OUTPUT_NAME <span class="string">&quot;hello&quot;</span>)</span><br><span class="line">//cmake 在构建一个新的<span class="keyword">target</span> 时，会尝试清理掉其他使用这个名字的库，因为，在构建 libhello.so 时， 就会清理掉 libhello.a</span><br><span class="line"><span class="keyword">SET_TARGET_PROPERTIES</span>(hello_static PROPERTIES CLEAN_DIRECT_OUTPUT <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD_LIBRARY</span>(hello SHARED <span class="variable">$&#123;LIBHELLO_SRC&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET_TARGET_PROPERTIES</span>(hello PROPERTIES  OUTPUT_NAME <span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="keyword">SET_TARGET_PROPERTIES</span>(hello PROPERTIES CLEAN_DIRECT_OUTPUT <span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="动态库的版本号"><a href="#动态库的版本号" class="headerlink" title="动态库的版本号"></a>动态库的版本号</h3><p>一般动态库都有一个版本号的关联</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">libhello.so.<span class="number">1.2</span></span><br><span class="line">libhello.so -&gt;libhello.so.<span class="number">1</span></span><br><span class="line">libhello.so.<span class="number">1</span>-&gt;libhello.so.<span class="number">1.2</span></span><br></pre></td></tr></table></figure><p>CMakeLists.txt 插入如下</p><p><code>SET_TARGET_PROPERTIES(hello PROPERTIES VERSION 1.2 SOVERSION 1)</code></p><p>VERSION 指代动态库版本，SOVERSION 指代 API 版本。</p><h3 id="安装共享库和头文件"><a href="#安装共享库和头文件" class="headerlink" title="安装共享库和头文件"></a>安装共享库和头文件</h3><p>本例中我们将 hello 的共享库安装到<prefix>&#x2F;lib目录，</p><p>将 hello.h 安装到<prefix>&#x2F;include&#x2F;hello 目录</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件放到该目录下</span></span><br><span class="line"><span class="built_in">INSTALL</span>(FILES hello.h DESTINATION include/hello)</span><br><span class="line"></span><br><span class="line"><span class="comment">//二进制，静态库，动态库安装都用TARGETS</span></span><br><span class="line"><span class="comment">//ARCHIVE 特指静态库，LIBRARY 特指动态库，RUNTIME 特指可执行目标二进制。</span></span><br><span class="line"><span class="built_in">INSTALL</span>(TARGETS hello hello_static LIBRARY DESTINATION lib ARCHIVE DESTINATION lib)</span><br></pre></td></tr></table></figure><p>注意：</p><p>安装的时候，指定一下路径，放到系统下</p><p><code>cmake -DCMAKE_INSTALL_PREFIX=/usr ..</code></p><h3 id="使用外部共享库和头文件"><a href="#使用外部共享库和头文件" class="headerlink" title="使用外部共享库和头文件"></a>使用外部共享库和头文件</h3><p>准备工作，新建一个目录来使用外部共享库和头文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@MiWiFi-R4CM-srv cmake3]<span class="meta"># tree</span></span><br><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">└── src</span><br><span class="line">    ├── CMakeLists.txt</span><br><span class="line">    └── main.cpp</span><br></pre></td></tr></table></figure><p>main.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;hello.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">HelloFunc</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果报错找不到<code>hello.h</code>：使用关键字：INCLUDE_DIRECTORIES    这条指令可以用来向工程添加多个特定的头文件搜索路径，路径之间用空格分割。在CMakeLists.txt中加入头文件搜索路径INCLUDE_DIRECTORIES(&#x2F;usr&#x2F;include&#x2F;hello)</p><p>如果报错找不到引用(undefined reference to xxx )：</p><p>使用关键字：LINK_DIRECTORIES     添加非标准的共享库搜索路径。指定第三方库所在路径，LINK_DIRECTORIES(&#x2F;home&#x2F;myproject&#x2F;libs)</p><p>使用关键字：TARGET_LINK_LIBRARIES    添加需要链接的共享库，TARGET_LINK_LIBRARIES的时候，只需要给出动态链接库的名字就行了。</p><p>在CMakeLists.txt中插入链接共享库，主要要插在executable的后面<code>TARGET_LINK_LIBRARIES(main libhello.so)</code>（）</p><p>可以通过<code>ldd</code>来确定可执行文件链接的共享库，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@MiWiFi-R4CM-srv bin]# ldd main </span><br><span class="line">linux-vdso.so.1 =&gt;  (0x00007ffedfda4000)</span><br><span class="line">libhello.so =&gt; /lib64/libhello.so (0x00007f41c0d8f000)</span><br><span class="line">libstdc++.so.6 =&gt; /lib64/libstdc++.so.6 (0x00007f41c0874000)</span><br><span class="line">libm.so.6 =&gt; /lib64/libm.so.6 (0x00007f41c0572000)</span><br><span class="line">libgcc_s.so.1 =&gt; /lib64/libgcc_s.so.1 (0x00007f41c035c000)</span><br><span class="line">libc.so.6 =&gt; /lib64/libc.so.6 (0x00007f41bff8e000)</span><br><span class="line">/lib64/ld-linux-x86-64.so.2 (0x00007f41c0b7c000)</span><br></pre></td></tr></table></figure><p>链接静态库</p><p><code>TARGET_LINK_LIBRARIES(main libhello.a)</code></p><h3 id="特殊的环境变量-CMAKE-INCLUDE-PATH-和-CMAKE-LIBRARY-PATH"><a href="#特殊的环境变量-CMAKE-INCLUDE-PATH-和-CMAKE-LIBRARY-PATH" class="headerlink" title="特殊的环境变量 CMAKE_INCLUDE_PATH 和 CMAKE_LIBRARY_PATH"></a>特殊的环境变量 CMAKE_INCLUDE_PATH 和 CMAKE_LIBRARY_PATH</h3><p>注意：这两个是环境变量而不是 cmake 变量，可以在linux的bash中进行设置</p><p>我们上面例子中使用了绝对路径INCLUDE_DIRECTORIES(&#x2F;usr&#x2F;include&#x2F;hello)来指明include路径的位置</p><p>我们还可以使用另外一种方式，使用环境变量export CMAKE_INCLUDE_PATH&#x3D;&#x2F;usr&#x2F;include&#x2F;hello</p><p>补充：生产debug版本的方法：<br>cmake .. -DCMAKE_BUILD_TYPE&#x3D;debug</p><h2 id="遇到的cmake知识补充"><a href="#遇到的cmake知识补充" class="headerlink" title="遇到的cmake知识补充"></a>遇到的cmake知识补充</h2><p><code>FIND_PACKAGE</code>:搜包命令，找到系统目录下该包的头文件和库文件，并将其加入cmake变量</p><p><code>cmake_minimum_required(VERSION 3.16)</code>：指定cmake版本，可以指定最高版本和最低版本</p><p><code>ctest</code>：cmake的测试工具，主要由<code>enable_test</code> <code>add_test</code>语句组成，使用ctest命令执行测试。</p><p>1.enable_testing()</p><p>​    使用 enable_testing() 命令可以启用测试。一定要在根目录下的 CMakeLists.txt 中开启，不然执行 make test 时会报错。</p><p>2.add_test()</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_test</span>(NAME &lt;name&gt; <span class="keyword">COMMAND</span> &lt;<span class="keyword">command</span>&gt; [&lt;arg&gt;...]</span><br><span class="line">         [CONFIGURATIONS &lt;config&gt;...]</span><br><span class="line">         [WORKING_DIRECTORY &lt;dir&gt;]</span><br><span class="line">         [COMMAND_EXPAND_LISTS])</span><br></pre></td></tr></table></figure><p>add_test 用来添加新测试：</p><ul><li>NAME：指定本测试的名称，可以随意命名。</li><li>COMMAND：指定测试命令行。如果 <command> 指定了一个可执行目标（由 add_executable（）创建），它将自动替换为生成时创建的可执行文件的位置。</li><li>CONFIGURATIONS ：Debug&#x2F;Release 选项可以控制在不同的编译版本下是否进行测试。</li><li>WORKING_DIRECTORY：指定要在其中执行测试的工作目录。如果未指定，测试将在当前工作目录设置为与当前源目录对应的生成目录的情况下运行。</li><li>COMMAND_EXPAND_LISTS：3.16 版新增。命令参数中的列表将展开，包括使用生成器表达式创建的列表。</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_test</span>(</span><br><span class="line">NAME mytest </span><br><span class="line"><span class="keyword">COMMAND</span> $&lt;TARGET_FILE:mytest&gt; <span class="comment">#&lt;TARGET_FILE:mytest&gt; 指代mytest这个目标的完整路径。</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>​     $&lt;TARGET_FILE:mytest&gt; 是生成器表达式，它是在生成构建系统生成时的表达式。生成器表达式在测试时非常方便，因为不必显式地将可执行程序的位置和名称，可以<a href="https://so.csdn.net/so/search?q=%E7%A1%AC%E7%BC%96%E7%A0%81&spm=1001.2101.3001.7020">硬编码</a>到测试中。</p><p>3.ctest 命令</p><p>​    CTest 遵循的标准约定是：返回零意味着成功，非零返回意味着失败。可以返回零或非零的脚本都可以做测试用例。（Windows 端使用 VS 编译时要保证安装 “用于 Windows 的 C++ CMake 工具”）</p><p> 使用 ctest 命令时，必须加上编译类型 <strong>-C <config></strong> 参数 ，才可以正确执行。默认情况下只有 <strong>Passed&#x2F;Failed</strong> 提示信息，此外，我们可以添加以下命令：</p><ul><li>–output-on-failure：将测试程序生成的任何内容打印到屏幕上，以免测试失败。</li><li>-v：将启用测试的详细输出。</li><li>-vv：启用更详细的输出。</li></ul><p><a href="https://blog.csdn.net/qq26983255/article/details/83303606">cmake的基本参数和用法_亚古兽要进化的博客-CSDN博客_cmake参数</a></p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h2 id=&quot;cmake步骤&quot;&gt;&lt;a href=&quot;#cmake步骤&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    
    <category term="c++" scheme="https://mightcoder.com/tags/c/"/>
    
    <category term="cmake" scheme="https://mightcoder.com/tags/cmake/"/>
    
  </entry>
  
  <entry>
    <title>open mlsys</title>
    <link href="https://mightcoder.com/2023/05/28/open%20mlsys/"/>
    <id>https://mightcoder.com/2023/05/28/open%20mlsys/</id>
    <published>2023-05-28T13:39:37.000Z</published>
    <updated>2023-05-26T10:52:48.950Z</updated>
    
    <content type="html"><![CDATA[<h2 id="编程接口"><a href="#编程接口" class="headerlink" title="编程接口"></a>编程接口</h2><p>编程接口：python等脚本语言作为上层接口，c&#x2F;c++等底层语言来保证性能。</p><h3 id="机器学习工作流"><a href="#机器学习工作流" class="headerlink" title="机器学习工作流"></a>机器学习工作流</h3><ul><li>数据处理</li><li>模型定义：定义神经网络结构</li><li>定义损失函数和优化器</li><li>训练及保存模型</li><li>测试和验证</li></ul><p>神经网络层</p><p>全连接(Full Connected,FC)：当前层每个节点都和上一层节点一一连接，本质上是特征空间的线性变换。</p><p>卷积(Convolution)：</p><ol><li><p>先定义一个卷积核，通常是N*M的张量，NM通常是奇数，以便让卷积核有一个中心点，</p></li><li><p>将卷积核对准特征图的某个位置计算卷积。</p></li><li><p>卷积操作是将卷积核中的值与输入图像或特征图中的对应位置的像素值相乘并将所有成绩相加得到一个单一的值，这个值就是卷积核在当前位置的输出值</p></li><li><p>将卷积核在输入图像或特征图上沿x和y轴滑动，直到覆盖完整个输入图像或特征图。每次滑动都会计算出一个卷积核的输出值，最终得到一个新的输出图像或特征图。</p><p>在卷积神经网络中，通常会将多个卷积核组合在一起使用，以提取不同的特征。这些卷积核可以并行进行卷积操作，产生多个特征图，然后将这些特征图合并在一起，以进一步提高模型的表达能力。</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/single_channel_conv.svg" alt="../_images/single_channel_conv.svg"></p></li></ol><p>池化(Pooling)：</p><p>常见的降维操作，有最大池化和平均池化。池化操作和卷积的执行类似，通过池化核、步长、填充决定输出；最大池化是在池化核区域范围内取最大值，平均池化则是在池化核范围内做平均。与卷积不同的是池化核没有训练参数；池化层的填充方式也有所不同，平均池化填充的是0，最大池化填充的是−inf。 <a href="https://openmlsys.github.io/chapter_programming_interface/neural_network_layer.html#pooling">图3.3.5</a>是对4×4的输入进行2×2区域池化，步长为2，不填充；图左边是最大池化的结果，右边是平均池化的结果。</p><p><a href="https://openmlsys.github.io/_images/pooling.svg"><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/pooling.svg" alt="../_images/pooling.svg"></a></p><p><em>图3.3.5</em> 池化操作</p><h3 id="定义深度神经网络"><a href="#定义深度神经网络" class="headerlink" title="定义深度神经网络"></a>定义深度神经网络</h3><p>对于用户来说，需要定义的是每个神经网络层的参数和计算方式，以及每层之间的连接方式。</p><p>机器学习系统将神经网络层抽象出一个基类，所有的神经网络层都继承基类来实现，用户也可以定义自己的神经网络层。</p><p>以MindSpore为例，要定义神经网络层，继承Cell后，需要重写<code>__init__</code> <code>__call__</code>两个方法，<code>__init__</code>定义本层的属性，<code>__call__</code>定义计算方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 接口定义：</span></span><br><span class="line">卷积层的接口：convolution(<span class="built_in">input</span>, filters, stride, padding)</span><br><span class="line">变量：Variable(value, trainable=<span class="literal">True</span>)</span><br><span class="line">高斯分布初始化方法：random_normal(shape)</span><br><span class="line">神经网络模型抽象方法：Cell</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义卷积层</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Conv2D</span>(<span class="title class_ inherited__">Cell</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, in_channels, out_channels, ksize, stride, padding</span>):</span><br><span class="line">        <span class="comment"># 卷积核大小为 ksize x ksize x inchannels x out_channels</span></span><br><span class="line">        filters_shape = (out_channels, in_channels, ksize, ksize)</span><br><span class="line">        self.stride = stride</span><br><span class="line">        self.padding = padding</span><br><span class="line">        self.filters = Variable(random_normal(filters_shape))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, inputs</span>):</span><br><span class="line">        outputs = convolution(inputs, self.filters, self.stride, self.padding)</span><br></pre></td></tr></table></figure><p>要定义神经网络模型也是继承Cell后重写<code>__init__</code> <code>__call__</code>两个方法，<code>__init__</code>定义所有的神经网络层，<code>__call__</code>定义计算层与层之间的计算方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用Cell子类构建的神经网络层接口定义：</span></span><br><span class="line"><span class="comment"># 构建卷积神经网络的组件接口定义：</span></span><br><span class="line">全连接层接口：Dense(in_channel, out_channel)</span><br><span class="line">卷积层的接口：Conv2D(in_channel, out_channel, filter_size, stride, padding)</span><br><span class="line">最大池化接口：MaxPool2D(pool_size, stride, padding)</span><br><span class="line">张量平铺：Flatten()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用SubClass方式构建卷积模型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CNN</span>(<span class="title class_ inherited__">Cell</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.conv1 = Conv2D(in_channel=<span class="number">3</span>, out_channel=<span class="number">16</span>, filter_size=<span class="number">3</span>, stride=<span class="number">1</span>, padding=<span class="number">0</span>)</span><br><span class="line">        self.maxpool1 = MaxPool2D(pool_size=<span class="number">3</span>, stride=<span class="number">1</span>, padding=<span class="number">0</span>)</span><br><span class="line">        self.conv2 = Conv2D(in_channel=<span class="number">16</span>, out_channel=<span class="number">32</span>, filter_size=<span class="number">3</span>, stride=<span class="number">1</span>, padding=<span class="number">0</span>)</span><br><span class="line">        self.maxpool2 = MaxPool2D(pool_size=<span class="number">3</span>, stride=<span class="number">1</span>, padding=<span class="number">0</span>)</span><br><span class="line">        self.flatten = Flatten()</span><br><span class="line">        self.dense1 = Dense(in_channels=<span class="number">768</span>, out_channel=<span class="number">128</span>)</span><br><span class="line">        self.dense2 = Dense(in_channels=<span class="number">128</span>, out_channel=<span class="number">64</span>)</span><br><span class="line">        self.dense3 = Dense(in_channels=<span class="number">64</span>, out_channel=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, inputs</span>):</span><br><span class="line">        z = self.conv1(inputs)</span><br><span class="line">        z = self.maxpool1(z)</span><br><span class="line">        z = self.conv2(z)</span><br><span class="line">        z = self.maxpool2(z)</span><br><span class="line">        z = self.flatten(z)</span><br><span class="line">        z = self.dense1(z)</span><br><span class="line">        z = self.dense2(z)</span><br><span class="line">        z = self.dense3(z)</span><br><span class="line">        <span class="keyword">return</span> z</span><br><span class="line">net = CNN()</span><br></pre></td></tr></table></figure><h3 id="C-C-编程接口"><a href="#C-C-编程接口" class="headerlink" title="C&#x2F;C++编程接口"></a>C&#x2F;C++编程接口</h3><p>如何在PYTHON中调用c&#x2F;c++函数</p><p>现代机器学习框架（包括TensorFlow，PyTorch和MindSpore）主要依赖Pybind11来将底层的大量C和C++函数自动生成对应的Python函数，这一过程一般被称为Python绑定（ Binding）。</p><p>添加c++编写的自定义算子</p><p>以MindSpore为例，实现一个GPU算子需要如下步骤：</p><ol><li>Primitive注册：算子原语是构建网络模型的基础单元，用户可以直接或者间接调用算子原语搭建一个神经网络模型。</li><li>GPU Kernel实现：GPU Kernel用于调用GPU实现加速计算。</li><li>GPU Kernel注册：算子注册用于将GPU Kernel及必要信息注册给框架，由框架完成对GPU Kernel的调用。</li></ol><p>以mindscope为例：</p><p><strong>1.注册算子原语</strong> 算子原语通常包括算子名、算子输入、算子属性（初始化时需要填的参数，如卷积的stride、padding）、输入数据合法性校验、输出数据类型推导和维度推导。假设需要编写加法算子，主要内容如下：</p><ul><li>算子名：TensorAdd</li><li>算子属性：构造函数__init__中初始化属性，因加法没有属性，因此__init__不需要额外输入。</li><li>算子输入输出及合法性校验：infer_shape方法中约束两个输入维度必须相同，输出的维度和输入维度相同。infer_dtype方法中约束两个输入数据必须是float32类型，输出的数据类型和输入数据类型相同。</li><li>算子输出</li></ul><p>MindSpore中实现注册TensorAdd代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mindspore/ops/operations/math_ops.py</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TensorAdd</span>(<span class="title class_ inherited__">PrimitiveWithInfer</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Adds two input tensors element-wise.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">    @prim_attr_register</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.init_prim_io_names(inputs=[<span class="string">&#x27;x1&#x27;</span>, <span class="string">&#x27;x2&#x27;</span>], outputs=[<span class="string">&#x27;y&#x27;</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">infer_shape</span>(<span class="params">self, x1_shape, x2_shape</span>):</span><br><span class="line">        validator.check_integer(<span class="string">&#x27;input dims&#x27;</span>, <span class="built_in">len</span>(x1_shape), <span class="built_in">len</span>(x2_shape), Rel.EQ, self.name)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(x1_shape)):</span><br><span class="line">            validator.check_integer(<span class="string">&#x27;input_shape&#x27;</span>, x1_shape[i], x2_shape[i], Rel.EQ, self.name)</span><br><span class="line">        <span class="keyword">return</span> x1_shape</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">infer_dtype</span>(<span class="params">self, x1_dtype, x2_type</span>):</span><br><span class="line">        validator.check_tensor_type_same(&#123;<span class="string">&#x27;x1_dtype&#x27;</span>: x1_dtype&#125;, [mstype.float32], self.name)</span><br><span class="line">        validator.check_tensor_type_same(&#123;<span class="string">&#x27;x2_dtype&#x27;</span>: x2_dtype&#125;, [mstype.float32], self.name)</span><br><span class="line">        <span class="keyword">return</span> x1_dtype</span><br></pre></td></tr></table></figure><p>在mindspore&#x2F;ops&#x2F;operations&#x2F;math_ops.py文件内注册加法算子原语后，需要在mindspore&#x2F;ops&#x2F;operations&#x2F;__init__中导出，方便python导入模块时候调用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mindspore/ops/operations/__init__.py</span></span><br><span class="line"><span class="keyword">from</span> .math_ops <span class="keyword">import</span> (Abs, ACos, ..., TensorAdd)</span><br><span class="line">__all__ = [</span><br><span class="line">  <span class="string">&#x27;ReverseSequence&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;CropAndResize&#x27;</span>,</span><br><span class="line">  ...,</span><br><span class="line">  <span class="string">&#x27;TensorAdd&#x27;</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>2.GPU算子开发</strong>继承GPUKernel，实现加法使用类模板定义TensorAddGpuKernel，需要实现以下方法：</p><ul><li>Init(): 用于完成GPU Kernel的初始化，通常包括记录算子输入&#x2F;输出维度，完成Launch前的准备工作；因此在此记录Tensor元素个数。</li><li>GetInputSizeList():向框架反馈输入Tensor需要占用的显存字节数；返回了输入Tensor需要占用的字节数，TensorAdd有两个Input，每个Input占用字节数为element_num∗sizeof(T)。</li><li>GetOutputSizeList():向框架反馈输出Tensor需要占用的显存字节数；返回了输出Tensor需要占用的字节数，TensorAdd有一个output，占用element_num∗sizeof(T)字节。</li><li>GetWorkspaceSizeList():向框架反馈Workspace字节数，Workspace是用于计算过程中存放临时数据的空间；由于TensorAdd不需要Workspace，因此GetWorkspaceSizeList()返回空的std::vector<size_t>。</li><li>Launch(): 通常调用CUDA kernel(CUDA kernel是基于Nvidia GPU的并行计算架构开发的核函数)，或者cuDNN接口等方式，完成算子在GPU上加速；Launch()接收input、output在显存的地址，接着调用TensorAdd完成加速。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mindspore/ccsrc/backend/kernel_compiler/gpu/math/tensor_add_v2_gpu_kernel.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TensorAddGpuKernel</span> : <span class="keyword">public</span> GpuKernel &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">TensorAddGpuKernel</span>() : <span class="built_in">element_num_</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">  ~<span class="built_in">TensorAddGpuKernel</span>() <span class="keyword">override</span> = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Init</span><span class="params">(<span class="type">const</span> CNodePtr &amp;kernel_node)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> shape = AnfAlgo::<span class="built_in">GetPrevNodeOutputInferShape</span>(kernel_node, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; shape.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      element_num_ *= shape[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">InitSizeLists</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">const</span> std::vector&lt;<span class="type">size_t</span>&gt; &amp;<span class="title">GetInputSizeList</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> input_size_list_; &#125;</span><br><span class="line">  <span class="function"><span class="type">const</span> std::vector&lt;<span class="type">size_t</span>&gt; &amp;<span class="title">GetOutputSizeList</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> output_size_list_; &#125;</span><br><span class="line">  <span class="function"><span class="type">const</span> std::vector&lt;<span class="type">size_t</span>&gt; &amp;<span class="title">GetWorkspaceSizeList</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> workspace_size_list_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Launch</span><span class="params">(<span class="type">const</span> std::vector&lt;AddressPtr&gt; &amp;inputs, <span class="type">const</span> std::vector&lt;AddressPtr&gt; &amp;,</span></span></span><br><span class="line"><span class="params"><span class="function">              <span class="type">const</span> std::vector&lt;AddressPtr&gt; &amp;outputs, <span class="type">void</span> *stream_ptr)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    T *x1 = <span class="built_in">GetDeviceAddress</span>&lt;T&gt;(inputs, <span class="number">0</span>);</span><br><span class="line">    T *x2 = <span class="built_in">GetDeviceAddress</span>&lt;T&gt;(inputs, <span class="number">1</span>);</span><br><span class="line">    T *y = <span class="built_in">GetDeviceAddress</span>&lt;T&gt;(outputs, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">TensorAdd</span>(element_num_, x1, x2, y, <span class="built_in">reinterpret_cast</span>&lt;cudaStream_t&gt;(stream_ptr));</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">InitSizeLists</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    input_size_list_.<span class="built_in">push_back</span>(element_num_ * <span class="built_in">sizeof</span>(T));</span><br><span class="line">    input_size_list_.<span class="built_in">push_back</span>(element_num_ * <span class="built_in">sizeof</span>(T));</span><br><span class="line">    output_size_list_.<span class="built_in">push_back</span>(element_num_ * <span class="built_in">sizeof</span>(T));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">size_t</span> element_num_;</span><br><span class="line">  std::vector&lt;<span class="type">size_t</span>&gt; input_size_list_;</span><br><span class="line">  std::vector&lt;<span class="type">size_t</span>&gt; output_size_list_;</span><br><span class="line">  std::vector&lt;<span class="type">size_t</span>&gt; workspace_size_list_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>TensorAdd中调用了CUDA kernelTensorAddKernel来实现element_num个元素的并行相加:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mindspore/ccsrc/backend/kernel_compiler/gpu/math/tensor_add_v2_gpu_kernel.h</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"> <span class="function">__global__ <span class="type">void</span> <span class="title">TensorAddKernel</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> element_num, <span class="type">const</span> T* x1, <span class="type">const</span> T* x2, T* y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = blockIdx.x * blockDim.x + threadIdx.x; i &lt; element_num; i += blockDim.x * gridDim.x) &#123;</span><br><span class="line">    y[i] = x1[i] + x2[i];</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">TensorAdd</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> &amp;element_num, <span class="type">const</span> T* x1, <span class="type">const</span> T* x2, T* y, cudaStream_t stream)</span></span>&#123;</span><br><span class="line">    <span class="type">size_t</span> thread_per_block = <span class="number">256</span>;</span><br><span class="line">    <span class="type">size_t</span> block_per_grid = (element_num + thread_per_block - <span class="number">1</span> ) / thread_per_block;</span><br><span class="line">    TensorAddKernel&lt;&lt;&lt;block_per_grid, thread_per_block, <span class="number">0</span>, stream&gt;&gt;&gt;(element_num, x1, x2, y);</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">template</span> <span class="type">void</span> <span class="title">TensorAdd</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> &amp;element_num, <span class="type">const</span> <span class="type">float</span>* x1, <span class="type">const</span> <span class="type">float</span>* x2, <span class="type">float</span>* y, cudaStream_t stream)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>3.GPU算子注册</strong>算子信息包含1.Primive；2.Input dtype, output dtype；3.GPU Kernel class； 4.CUDA内置数据类型。框架会根据Primive和Input dtype, output dtype，调用以CUDA内置数据类型实例化GPU Kernel class模板类。如下代码中分别注册了支持float和int的TensorAdd算子。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mindspore/ccsrc/backend/kernel_compiler/gpu/math/tensor_add_v2_gpu_kernel.cc</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">MS_REG_GPU_KERNEL_ONE</span>(TensorAddV2, <span class="built_in">KernelAttr</span>()</span><br><span class="line">                                    .<span class="built_in">AddInputAttr</span>(kNumberTypeFloat32)</span><br><span class="line">                                    .<span class="built_in">AddInputAttr</span>(kNumberTypeFloat32)</span><br><span class="line">                                    .<span class="built_in">AddOutputAttr</span>(kNumberTypeFloat32),</span><br><span class="line">                      TensorAddV2GpuKernel, <span class="type">float</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">MS_REG_GPU_KERNEL_ONE</span>(TensorAddV2, <span class="built_in">KernelAttr</span>()</span><br><span class="line">                                    .<span class="built_in">AddInputAttr</span>(kNumberTypeInt32)</span><br><span class="line">                                    .<span class="built_in">AddInputAttr</span>(kNumberTypeInt32)</span><br><span class="line">                                    .<span class="built_in">AddOutputAttr</span>(kNumberTypeInt32),</span><br><span class="line">                      TensorAddV2GpuKernel, <span class="type">int</span>)</span><br></pre></td></tr></table></figure><p>完成上述三步工作后，需要把MindSpore重新编译，在源码的根目录执行bash build.sh -e gpu，最后使用算子进行验证。</p><h2 id="计算图"><a href="#计算图" class="headerlink" title="计算图"></a>计算图</h2><h3 id="计算图的基本构成"><a href="#计算图的基本构成" class="headerlink" title="计算图的基本构成"></a>计算图的基本构成</h3><p>张量(Tensor)和基本运算单元算子。在计算图中通常使用节点来表示算子，节点间的有向边（Directed Edge）来表示张量状态，同时也描述了计算间的依赖关系。</p><p><img src="https://openmlsys.github.io/_images/simpledag.png" alt="../_images/simpledag.png"></p><p>张量即多维数据的统称，使用秩来表示张量的轴数或维度。标量为零秩张量，包含单个数值，没有轴；向量为一秩张量，拥有一个轴；拥有RGB三个通道的彩色图像即为三秩张量，包含三个轴。</p><p><img src="https://openmlsys.github.io/_images/tensor.png" alt="../_images/tensor.png"></p><table><thead><tr><th align="right">张量属性</th><th align="right">功能</th></tr></thead><tbody><tr><td align="right">形状(shape)</td><td align="right">存储张量的每个 维度的长度，如[3,3,3]</td></tr><tr><td align="right">秩或维数（dim）</td><td align="right">表 示张量的轴数或者维数 ，标量为0，向量为1。</td></tr><tr><td align="right">数据类型(dtype)</td><td align="right">表示存储的数据类型 ，如bool、uint8、int1 6、float32、float64等</td></tr><tr><td align="right">存储位置(device)</td><td align="right">创建张 量时可以指定存储的设 备位置，如CPU、GPU等</td></tr><tr><td align="right">名字(name)</td><td align="right">张量的标识符</td></tr></tbody></table><p>算子类型：</p><ul><li>张量操作算子：张量的结构操作和数学运算；张量的形状、维度调整以及张量合并等；矩阵乘法、计算范数、行列式和特征值计算等。</li><li>神经网络算子：包括特征提取、激活函数、损失函数、优化算法等</li><li>数据流算子：包括数据的预处理与数据载入等相关算子</li><li>控制流算子：控制计算图中的数据流向，有条件运算符和循环运算符。</li></ul><h4 id="计算依赖"><a href="#计算依赖" class="headerlink" title="计算依赖"></a>计算依赖</h4><p>算子之间存在依赖关系，计算图应当是有向无环图。如果形成循环依赖则不正确。机器学习框架中，表示循环关系通常以展开机制实现，即循环N次则将对应的计算子图复制N次，这些复制的所有张量和运算符会被赋予新的标识符。</p><h4 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h4><p>目前主流机器学习语言使用两种方式来提供控制流</p><p>- </p><ul><li>前端语言控制流：使用前端语言例如python进行控制决策，这种方式编程简单快捷，但是由于机器学习框架的数据计算运行在后端硬件，造成控制流和数据流之间的分离，计算图不能完整的运行在后算计算硬件上。这种方法称为图外方法</li><li>机器学习框架控制原语：在内部设计低级别细粒度的控制原语运算符，能够直接执行在计算硬件上，整体在后端运算，这种实现方式被称为图内方法。</li></ul><p>前者能快速将算法转换为模型代码，后者高性能</p><h3 id="计算图的生成"><a href="#计算图的生成" class="headerlink" title="计算图的生成"></a>计算图的生成</h3><ul><li>静态图：根据前端语言描述网络结构及参数遍历等信息构建一份固定的计算图</li><li>动态图：每一次执行神经网络模型都根据前端语言动态生成临时计算图。</li></ul><h4 id="静态生成"><a href="#静态生成" class="headerlink" title="静态生成"></a>静态生成</h4><p>静态计算图可以通过优化策略转换为等价的更加高效的结构。</p><p><img src="https://openmlsys.github.io/_images/static.png" alt="../_images/static.png"></p><p>静态计算图的两大优势</p><ul><li>计算性能：可以进行图优化，kernel fusion</li><li>直接部署：机器学习框架可以将静态计算图转换为支持不同计算硬件直接调用的代码。</li></ul><p>缺点：</p><ul><li>难以调试，出错时难以直接找到错误信息</li></ul><h4 id="动态生成"><a href="#动态生成" class="headerlink" title="动态生成"></a>动态生成</h4><p>相较于静态图整个程序都在后端代码中执行，动态图是前端语言调用后端框架的算子，每个算子执行完后再将结果返回前端语言执行后面的操作。</p><p><img src="https://openmlsys.github.io/_images/eager-gen.png" alt="../_images/eager-gen.png"></p><p>优点：</p><ul><li>便于调试，对初学者友好，提高了算法开发和迭代的效率</li></ul><p>缺点：</p><ul><li>难以进行模型优化以提高计算效率</li></ul><table><thead><tr><th align="right">特性</th><th align="right">静态图</th><th align="right">动态图</th></tr></thead><tbody><tr><td align="right">即时获取中间结果</td><td align="right">否</td><td align="right">是</td></tr><tr><td align="right">代码调试难易</td><td align="right">难</td><td align="right">易</td></tr><tr><td align="right">控制流实现方式</td><td align="right">特定的语法</td><td align="right">前端语言语法</td></tr><tr><td align="right">性能</td><td align="right">优化策略多，性能更佳</td><td align="right">图优化受限，性能较差</td></tr><tr><td align="right">内存占用</td><td align="right">内存占用少</td><td align="right">内存占用相对较多</td></tr><tr><td align="right">内存占用</td><td align="right">可直接部署</td><td align="right">不可直接部署</td></tr></tbody></table><p>目前TensorFlow、MindSpore、PyTorch、PaddlePaddle等主流机器学习框架都具备动态图转静态图的功能。</p><h2 id="AI编译和前端技术"><a href="#AI编译和前端技术" class="headerlink" title="AI编译和前端技术"></a>AI编译和前端技术</h2><p><img src="https://openmlsys.github.io/_images/LLVM%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84.png" alt="../_images/LLVM%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84.png"></p><p>LLVM包含前端，IR，和后端三个部分。前端将高级语言转换成IR，后端将IR转化成目标硬件上的机器指令。</p><p>IR作为桥梁在前后端之间进行基于IR的各种优化。</p><p>IR可以是单层的，也可以是多层的， LLVM IR是典型的单层IR，其前后端优化都基于相同的LLVM IR进行。</p><p>AI编译器一般采用多层级IR设计。 <a href="https://openmlsys.github.io/chapter_frontend_and_ir/ai_compiler_design_principle.html#tf-multi-ir">图6.1.2</a>展示了TensorFlow利用MLIR实现多层IR设计的例子（被称为TensorFlow-MLIR）。其包含了三个层次的IR，即TensorFlow Graph IR， XLA（Accelerated Linear Algebra，加速线性代数）、HLO（High Level Operations，高级运算）以及特定硬件的LLVM IR 或者TPU IR。</p><p><img src="https://openmlsys.github.io/_images/TensorFlow-IR.png" alt="../_images/TensorFlow-IR.png"></p><p>多层级IR的优势是IR表达上更加地灵活，可以在不同层级的IR上进行合适的PASS优化，更加便捷和高效。 但是多层级IR也存在一些劣势。首先，多层级IR需要进行不同IR之间的转换，而IR转换要做到完全兼容是非常困难的，工程工作量很大，还可能带来信息的损失。上一层IR优化掉某些信息之后，下一层需要考虑其影响，因此IR转换对优化执行的顺序有着更强的约束。其次，多层级IR有些优化既可以在上一层IR进行，也可以在下一层IR进行，让框架开发者很难选择。最后，不同层级IR定义的算子粒度大小不同，可能会给精度带来一定的影响。为了解决这一问题，机器学习框架如MindSpore采用统一的IR设计（MindIR）。 <a href="https://openmlsys.github.io/chapter_frontend_and_ir/ai_compiler_design_principle.html#ms-compiler">图6.1.3</a>展示了MindSpore的AI编译器内部的运行流程。其中，编译器前端主要指图编译和硬件无关的优化，编译器后端主要指硬件相关优化、算子选择等。</p><p><img src="https://openmlsys.github.io/_images/%E7%BC%96%E8%AF%91%E5%99%A8%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B.png" alt="../_images/%E7%BC%96%E8%AF%91%E5%99%A8%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B.png"></p><h2 id="编译器后端和运行时"><a href="#编译器后端和运行时" class="headerlink" title="编译器后端和运行时"></a>编译器后端和运行时</h2><p>后端主要负责计算图优化、算子选择和内存分配的任务。</p><p>计算图优化方面</p><ul><li>一个算子就能实现几个计算节点的功能，此时可以将这些IR节点合并成一个计算节点，该过程成为算子融合</li><li>对于复杂计算，后端没有直接对应的算子，可以将几个基本运算的算子组合达到相同的计算效果。</li></ul><p>算子选择方面，本质上是一个模式匹配问题，用户代码产生的IR往往可以映射成多种不同的硬件算子。这些算子的效率有很大的差别，如何根据IR选择硬件算子是问题所在。</p><p>现有编译器一般对每一个IR节点提供多个候选算子，要选择最优的算子作为最终执行在设备上的算子。</p><p><img src="https://openmlsys.github.io/_images/compiler-backend-architecture.png" alt="../_images/compiler-backend-architecture.png"></p><h3 id="计算图优化"><a href="#计算图优化" class="headerlink" title="计算图优化"></a>计算图优化</h3><h4 id="通用优化"><a href="#通用优化" class="headerlink" title="通用优化"></a>通用优化</h4><p>通用优化与硬件无关，优化的核心是子图的等价变化，即将目标子图等价替换成对硬件更友好的子图结构。</p><p>比如：算子融合，将计算密集型和访存密集型的算子融合，减少内存访问延时和带宽压力</p><ul><li>计算密集型：卷积，全连接</li><li>访存密集型：大部分是Element-Wise算子，例如 ReLU、Element-Wise Sum</li></ul><p>例如：“Conv + Conv + Sum + ReLU”的融合，从 <a href="https://openmlsys.github.io/chapter_backend_and_runtime/graph_optimizer.html#conv-sum-relu">图7.2.1</a>中可以看到融合后的算子减少了两个内存的读和写的操作，优化了Conv的输出和Sum的输出的读和写的操作。</p><p><a href="https://openmlsys.github.io/_images/conv_sum_relu.png"><img src="https://openmlsys.github.io/_images/conv_sum_relu.png" alt="../_images/conv_sum_relu.png"></a></p><p>除了对于特定类型算子的融合优化，还有自动算子生成技术，通过算子拆解、算子聚合、算子重建三阶段融合算子，减少低效的内存访问。</p><p><img src="https://openmlsys.github.io/_images/graph_kernel.png" alt="../_images/graph_kernel.png"></p><h4 id="特定硬件优化"><a href="#特定硬件优化" class="headerlink" title="特定硬件优化"></a>特定硬件优化</h4><p>针对某些硬件的限制，比如硬件指令的限制，硬件要求数据格式的限制进行优化。</p><h3 id="算子选择"><a href="#算子选择" class="headerlink" title="算子选择"></a>算子选择</h3><p>根据哪些方面选择算子？</p><ul><li>数据排布格式：如NCHW和NHWC</li><li>计算精度：fp32 fp16 int32</li></ul><h4 id="数据排布格式"><a href="#数据排布格式" class="headerlink" title="数据排布格式"></a>数据排布格式</h4><p>NCHW类型和NHWC类型。其中N代表了数据输入的批大小，C代表了图像的通道，H和W分别代表图像输入的高和宽</p><p><img src="https://openmlsys.github.io/_images/data_format.png" alt="../_images/data_format.png"></p><p>但是计算机的存储并不能够直接将这样的矩阵放到内存中，需要将其展平成1维后存储，这样就涉及逻辑上的索引如何映射成为内存中的索引，即如何根据逻辑数据索引来映射到内存中的1维数据索引。</p><p>对于NCHW的数据是先取W轴方向数据，再取H轴方向数据，再取C轴方向，最后取N轴方向。其中物理存储与逻辑存储的之间的映射关系为</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20230514191009217.png" alt="image-20230514191009217"></p><p>NHWC批次优先适合CPU NCHW通道优先适合GPU（参考行主序列主序）</p><p>除此之外还有比如oneDNN上的nChw16c 和nChw8c 格式，以及Ascend芯片的5HD等格式。</p><h4 id="数据精度"><a href="#数据精度" class="headerlink" title="数据精度"></a>数据精度</h4><p><img src="https://openmlsys.github.io/_images/floatdtype.png" alt="../_images/floatdtype.png"></p><p> 其中bfloat16并不属于一个通用的数据类型，是Google提出的一种特殊的类型，现在一般只在一些TPU上训练使用，其指数位数与float32位数保持一致，可以较快的与float32进行数据转换。由于bfloat16并不是一种通用类型，IEEE中也并没有提出该类型的标准。</p><h3 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h3><p>随着深度学习的发展，深度神经网络的模型越来越复杂，AI芯片上的内存很可能无法容纳一个大型网络模型。因此，对内存进行复用是一个重要的优化手段。此外，通过连续内存分配和 In-Place内存分配还可以提高某些算子的执行效率。</p><p>内存分配的流程</p><ul><li>首先根据数据类型和张量形状算出所需内存</li><li>对内存进行对齐</li></ul><p><img src="https://openmlsys.github.io/_images/memory_allocate.png" alt="../_images/memory_allocate.png"></p><p>如图所示一般有三种类型的内存，整张图的输入张量、算子权重、算子的输出。</p><p>为了避免频繁申请释放内存的开销，使用内存池来管理内存。</p><p>mindspore的申请方法：双游标法</p><p><img src="https://openmlsys.github.io/_images/device_malloc.png" alt="../_images/device_malloc.png"></p><p>从首地址开始为算子权重分配内存，声明周期长，从末尾开始为算子输出分配内存，声明周期短，若后续无需使用，即可通过移动指针放弃该部分内存。</p><h4 id="内存复用"><a href="#内存复用" class="headerlink" title="内存复用"></a>内存复用</h4><p>内存复用即是若之前数据不再被需要，重用这部分内存。</p><p>内存复用策略的求解是一个NP完全的问题。许多深度学习框架通常采用贪心的策略去分配内存。</p><h4 id="常用内存分配优化手段"><a href="#常用内存分配优化手段" class="headerlink" title="常用内存分配优化手段"></a>常用内存分配优化手段</h4><ul><li>内存融合：其实也是算子融合的一种，比如AllReduce算子，在分布式集群下通信往往是性能瓶颈，可以将多个通信算子融合成一个，减少通信次数。</li><li>In-Place算子：in-place计算减少内存申请。</li></ul><h3 id="计算调度与执行"><a href="#计算调度与执行" class="headerlink" title="计算调度与执行"></a>计算调度与执行</h3><p>根据是否将算子编译成计算图，计算分为单算子调度和计算图调度。</p><p>单算子调度由python运行时直接调度，便于调试。但是难以进行性能的优化，一般使用计算图调度。</p><p>根据是否一次性将子图下发到硬件分为交互式执行和下沉式执行。</p><p>交互式执行host和device之间有交互，下沉式执行避免了这种交互从而获得更好的性能，但是在动态shape算子、复杂的控制流等场景下会面临较大的技术挑战。</p><h3 id="算子编译器"><a href="#算子编译器" class="headerlink" title="算子编译器"></a>算子编译器</h3><p>将动态语言描述的张量技算输出为特定硬件上的可执行文件</p><ul><li>子策略组合优化：比如通过平铺（Tile），循环移序（Reorder）和切分（Split）的调度策略优化矩阵乘</li><li>调度空间算法优化：比如使用多面体模型编译（Polyhedral Compilation）来优化编译</li><li>芯片指令集适配：</li></ul><h2 id="硬件加速器"><a href="#硬件加速器" class="headerlink" title="硬件加速器"></a>硬件加速器</h2><p>和传统CPU和GPU芯片相比，深度学习硬件加速器有更高的性能和更低的能耗。</p><p>两个设计重要指标</p><ul><li>能效</li><li>通用性</li></ul><p>华为昇腾AI芯片达芬奇架构</p><p><img src="https://openmlsys.github.io/_images/davinci_architecture.svg" alt="../_images/davinci_architecture.svg"></p><p>编程接口的层次</p><ul><li><strong>算子库层级</strong>：如cuBLAS基本矩阵与向量运算库，cuDNN深度学习加速库，均通过Host端调用算子库提供的核函数使能张量计算核心；</li><li><strong>编程原语层级</strong>：如基于CUDA的WMMA API编程接口。同算子库相比，需要用户显式调用计算各流程，如矩阵存取至寄存器、张量计算核心执行矩阵乘累加运算、张量计算核心累加矩阵数据初始化操作等；</li><li><strong>指令层级</strong>：如PTX ISA MMA指令集，提供更细粒度的mma指令，便于用户组成更多种形状的接口，通过CUDA Device端内联编程使能张量计算核心。</li></ul><p>cuda的一种gemm实现</p><p><a href="https://openmlsys.github.io/chapter_accelerator/accelerator_practise.html">8.4. 加速器实践 — 机器学习系统：设计和实现 1.0.0 documentation (openmlsys.github.io)</a></p><h2 id="数据处理框架"><a href="#数据处理框架" class="headerlink" title="数据处理框架"></a>数据处理框架</h2><p>数据处理的核心组件</p><ul><li>**数据加载组件(Load)**：负责从存储设备中加载读取数据集，需要同时考虑存储设备的多样性（如本地磁盘&#x2F;内存，远端磁盘和内存等）和数据集格式的多样性（如csv格式，txt格式等）。根据机器学习任务的特点，AI框架也提出了统一的数据存储格式（如谷歌TFRecord, 华为MindRecord等）以提供更高性能的数据读取。</li><li>**数据混洗组件(Shuffle)**：负责将输入数据的顺序按照用户指定方式随机打乱，以提升模型的鲁棒性。</li><li>**数据变换组件(Map)**：负责完成数据的变换处理，内置面向各种数据类型的常见预处理算子，如图像中的尺寸缩放和翻转，音频中的随机加噪和变调、文本处理中的停词去除和随机遮盖(Mask)等。</li><li>**数据组装组件(Batch)**：负责组装构造一个批次(mini-batch)的数据发送给训练&#x2F;推理。</li><li>**数据发送组件(Send)**：负责将处理后的数据发送到GPU&#x2F;华为昇腾Ascend等加速器中以进行后续的模型计算和更新。高性能的数据模块往往选择将数据向设备的搬运与加速器中的计算异步执行，以提升整个训练的吞吐率。</li></ul><p><a href="https://openmlsys.github.io/_images/pipeline.png"><img src="https://openmlsys.github.io/_images/pipeline.png" alt="../_images/pipeline.png"></a></p><p>这些组件应当具有：</p><ul><li>易用性</li><li>高效性</li><li>保序性：机器学习模型训练对数据输入顺序敏感。为了帮助用户更好的调试和确保不同次实验的可复现性，我们需要在系统中设计相应机制使得数据最终送入模型的顺序由数据混洗组件的数据输出顺序唯一确定，不会由于并行数据变换而带来最终数据模块的数据输出顺序不确定。</li></ul><h3 id="高效性设计"><a href="#高效性设计" class="headerlink" title="高效性设计"></a>高效性设计</h3><p>深度学习模型执行流程分为数据加载、数据处理、芯片计算三个过程。为了追求最高的训练吞吐率，一般将这三个步骤异步并行执行。</p><p><img src="https://openmlsys.github.io/_images/async_data_process.png" alt="../_images/async_data_process.png"></p><p>通常情况下我们希望G &lt; min(F, P)，此时加速芯片不会因为等待数据而阻塞。然而现实情况下，我们常常要么因为数据加载速率F过低(称为I&#x2F;O Bound)，要么因为数据预处理速率P过低(称为CPU Bound)导致G&gt;min(F, P)而使得芯片无法被充分利用。</p><p>TODO</p><h2 id="模型部署"><a href="#模型部署" class="headerlink" title="模型部署"></a>模型部署</h2><p>模型部署的过程：将训练好的模型和参数持久化成文件，但是不同训练框架导出的模型文件中存储的数据结构不同，这就为模型的推理系统带来了不便。推理系统为了支持不同的训练框架的模型，需要将模型文件中的数据转换成统一的数据结构。此外，在训练模型转换成推理模型的过程中，需要进行一些如算子融合、常量折叠等模型的优化以提升推理的性能。</p><p>模型压缩：为了满足不同硬件设备的限制，在边缘设备或者低功耗的微控制器上只能部署简单的机器学习模型。为了满足这些硬件的限制，在有些场景下要对训练好的模型进行压缩，降低其复杂度或数据的精度，减少模型参数。</p><p>常见方法：</p><ul><li><strong>算子融合</strong></li></ul><p>通过表达式简化、属性融合等方式将多个算子合并为一个算子的技术，融合可以降低模型的计算复杂度及模型的体积。</p><ul><li><strong>常量折叠</strong></li></ul><p>将符合条件的算子在离线阶段提前完成前向计算，从而降低模型的计算复杂度和模型的体积。常量折叠的条件是算子的所有输入在离线阶段均为常量。</p><ul><li><strong>模型压缩</strong></li></ul><p>通过量化、剪枝等手段减小模型体积以及计算复杂度的技术，可以分为需要重训的压缩技术和不需要重训的压缩技术两类。</p><ul><li><strong>数据排布</strong></li></ul><p>根据后端算子库支持程度和硬件限制，搜索网络中每层的最优数据排布格式，并进行数据重排或者插入数据重排算子，从而降低部署时的推理时延</p><ul><li><strong>模型混淆</strong></li></ul><p>对训练好的模型进行混淆操作，主要包括新增网络节点和分支、替换算子名的操作，攻击者即使窃取到混淆后的模型也不能理解原模型的结构。此外，混淆后的模型可以直接在部署环境中以混淆态执行，保证了模型在运行过程中的安全性。</p><h3 id="训练模型到推理模型的转换及优化"><a href="#训练模型到推理模型的转换及优化" class="headerlink" title="训练模型到推理模型的转换及优化"></a>训练模型到推理模型的转换及优化</h3><h4 id="模型转换"><a href="#模型转换" class="headerlink" title="模型转换"></a>模型转换</h4><p>ONNX（Open Neural Network Exchange）开放神经网络交换协议支持将不同的训练框架定义的数据结构转换成统一的数据结构上。</p><p>完成模型转换后，会进行一些不依赖输入的工作，如常量折叠、算子融合、算子替换、算子重排等一些优化手段。</p><h4 id="算子融合"><a href="#算子融合" class="headerlink" title="算子融合"></a>算子融合</h4><p>推理阶段的算子融合：在推理阶段某些算子的中的符号是常量，可以进行融合，但是在训练过程中是参数，如果融合会导致模型参数的缺少。因此有些算子融合只能在推理阶段进行。</p><h4 id="算子替换"><a href="#算子替换" class="headerlink" title="算子替换"></a>算子替换</h4><p>算子替换，即将模型中某些算子替换计算逻辑一致但对于在线部署更友好的算子。算子替换的原理是通过合并同类项、提取公因式等数学方法，将算子的计算公式加以简化，并将简化后的计算公式映射到某类算子上。算子替换可以达到降低计算量、降低模型大小的效果。</p><p>同样，算子替换优化策略只能在部署阶段进行，因为一方面在部署阶段Batchnorm计算公式中被认为是常量的符号，在训练时是参数并非常量。另一方面该优化策略会降低模型的参数量，改变模型的结构，降低模型的表达能力，影响训练收敛时模型的准确率。</p><h4 id="算子重排"><a href="#算子重排" class="headerlink" title="算子重排"></a>算子重排</h4><p>算子重排是指将模型中算子的拓扑序按照某些规则进行重新排布，在不降低模型的推理精度的前提下，降低模型推理的计算量。常用的算子重排技术有针对于Slice算子、StrideSlice算子、Crop算子等裁切类算子的前移、Reshape算子和Transpose算子的重排、BinaryOp算子的重排等。</p><p><a href="https://openmlsys.github.io/_images/crop-reorder.png"><img src="https://openmlsys.github.io/_images/crop-reorder.png" alt="../_images/crop-reorder.png"></a></p><p><em>图10.2.4</em> Crop算子重排 </p><p>如 <a href="https://openmlsys.github.io/chapter_model_deployment/model_converter_and_optimizer.html#ch08-fig-crop-reorder">图10.2.4 </a>，Crop算子是从输入的特征图中裁取一部分作为输出，经过Crop算子后，特征图的大小就降低了。如果将这个裁切的过程前移，提前对特征图进行裁切，那么后续算子的计算量也会相应地减少，从而提高模型部署时的推理性能。Crop算子前移带来的性能提升跟Crop算子的参数有关。但是Crop算子一般只能沿着的element wise类算子前移。</p><h3 id="模型压缩"><a href="#模型压缩" class="headerlink" title="模型压缩"></a>模型压缩</h3><h4 id="量化"><a href="#量化" class="headerlink" title="量化"></a>量化</h4><p>将连续取值的浮点型权重（通常为float32或者大量可能的离散值）近似为有限多个离散值（通常为int8）的过程.</p><p>工业界最常用的量化位数是8比特</p><p>根据量化数据表示的原始数据范围是否均匀，还可以将量化方法分为线性量化和非线性量化。实际的深度神经网络的权重和激活值通常是不均匀的，因此理论上使用非线性量化导致的精度损失更小，但在实际推理中非线性量化的计算复杂度较高，通常使用线性量化。下面着重介绍线性量化的原理。</p><p>假设r表示量化前的浮点数，量化后的整数q可以表示为：</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20230515171753778.png" alt="image-20230515171753778">(10.3.1)</p><p>round和clip分别表示取整和截断操作，q<del>min</del>和q<del>max</del>是量化后的最小值和最大值。s是数据量化的间隔，z是表示数据偏移的偏置，z为0的量化被称为对称（Symmetric）量化，不为0的量化称为非对称（Asymmetric）量化。对称量化可以避免量化算子在推理中计算z相关的部分，降低推理时的计算复杂度；非对称量化可以根据实际数据的分布确定最小值和最小值，可以更加充分的利用量化数据信息，使得量化导致的损失更低。</p><p>根据量化参数s和z的共享范围，量化方法可以分为逐层量化和逐通道量化。逐层量化以一层网络为量化单位，每层网络的一组量化参数；逐通道量化以一层网络的每个量化通道为单位，每个通道单独使用一组量化参数。逐通道量化由于量化粒度更细，能获得更高的量化精度，但计算也更复杂。</p><p>根据量化过程中是否需要训练，可以将模型量化分为量化感知训练（Quantization Aware Training, QAT）和训练后量化（Post Training Quantization, PTQ）两种,其中感知量化训练是指在模型训练过程中加入伪量化算子，通过训练时统计输入输出的数据范围可以提升量化后模型的精度，适用于对模型精度要求较高的场景；训练后量化指对训练后的模型直接量化，只需要少量校准数据，适用于追求高易用性和缺乏训练资源的场景。</p><p>量化落地的三大挑战</p><p>精度挑战：</p><p>- </p><ul><li>量化方法：线性量化对数据分布的描述不准确</li><li>低比特：比特数越低，精度损失越大</li><li>任务：任务越复杂，精度损失越大</li><li>大小：模型越小，精度损失越大</li></ul><p>硬件支持程度：</p><ul><li>不同硬件支持低比特指令不同</li><li>不同硬件提供不同的低比特指令计算方式不同</li><li>不同硬件体系结构kernel优化方式不同</li></ul><p>量化是否真的有效：</p><ul><li>混合精度需要量化与反量化，cast转换会影响性能</li><li>模型参数效，压缩比高，不代表执行内存占用少</li></ul><p>量化方法</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20230515174146367.png" alt="image-20230515174146367"></p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20230515174505313.png" alt="image-20230515174505313"></p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20230515174523917.png" alt="image-20230515174523917"></p><p>量化建立数据映射关系</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20230515175334164.png" alt="image-20230515175334164"></p><p>对称量化和非对称量化</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20230515175151923.png" alt="image-20230515175151923"></p><p>量化原理</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20230515175534004.png" alt="image-20230515175534004"></p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20230515175633887.png" alt="image-20230515175633887"></p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h2 id=&quot;编程接口&quot;&gt;&lt;a href=&quot;#编程接口&quot; class=&quot;headerlink&quot; title=&quot;编程接口&quot;&gt;&lt;/a&gt;编程接口&lt;/h2&gt;&lt;p&gt;编程接口：python等脚本语言作为上层接口，c&amp;#x2F;c++等底层语言来保证性能。&lt;/p&gt;
&lt;h3</summary>
        
      
    
    
    
    
    <category term="hpc" scheme="https://mightcoder.com/tags/hpc/"/>
    
    <category term="mlsys" scheme="https://mightcoder.com/tags/mlsys/"/>
    
    <category term="ai" scheme="https://mightcoder.com/tags/ai/"/>
    
  </entry>
  
  <entry>
    <title>Kokkos编程指南</title>
    <link href="https://mightcoder.com/2023/05/27/kokkos/"/>
    <id>https://mightcoder.com/2023/05/27/kokkos/</id>
    <published>2023-05-27T13:39:37.000Z</published>
    <updated>2023-05-26T10:48:42.437Z</updated>
    
    <content type="html"><![CDATA[<h1 id="KOKKOS编程指南"><a href="#KOKKOS编程指南" class="headerlink" title="KOKKOS编程指南"></a>KOKKOS编程指南</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p>相比于其他并行编程模型的特点：可移植性</p><h2 id="2-machine-model"><a href="#2-machine-model" class="headerlink" title="2.machine model"></a>2.machine model</h2><p>为了实现跨架构的可移植性，并保证性能，kokkos有两个重要组件</p><ul><li>内存空间：可以在其中分配数据结构</li><li>执行空间：使用一个或多个内存空间的暑假执行并行操作</li></ul><p>kokkos抽象机器模型</p><p><img src="https://kokkos.github.io/kokkos-core-wiki/_images/kokkos-node-doc.png" alt="节点"></p><h3 id="执行空间"><a href="#执行空间" class="headerlink" title="执行空间"></a>执行空间</h3><p>执行空间用来描述一组并行执行资源，不同的执行空间可以队形不同的计算资源，例如多核CPU、GPU、加速器。Kokkos 模型抽象了为不同执行空间编译代码和将内核调度到实例的方法。这使得应用程序程序员无需使用特定于硬件的语言编写算法。</p><h3 id="内存空间"><a href="#内存空间" class="headerlink" title="内存空间"></a>内存空间</h3><p>计算节点中多种类型的内存由kokkos通过内存空间抽象。</p><p>内存空间的实例为程序员提供了一种请求数据存储分配的具体方法，可以用多个内存空间对应不同种类的内存。</p><p>原子访问：对于race conditions，可以使用锁， critical regions， 原子操作来避免。</p><p>kokkos中的内存一致性问题：kokkos中 内存一致性极弱，程序员应当显示编程保证内存操作的顺序正确，kokkos提供了fence来达到这一点。</p><h2 id="3-编程模型"><a href="#3-编程模型" class="headerlink" title="3.编程模型"></a>3.编程模型</h2><p>kokkos编程模型6个核心抽象：执行空间，执行模式，执行策略，内存空间，内存布局，内存特征</p><p><img src="https://kokkos.github.io/kokkos-core-wiki/_images/kokkos-abstractions-doc.png" alt="抽象"></p><h3 id="3-1-执行空间"><a href="#3-1-执行空间" class="headerlink" title="3.1 执行空间"></a>3.1 执行空间</h3><p>包括CPU内核GPU内核，甚至存内计算以及一个异构CPU上的不同内核类型</p><h3 id="3-2-执行模式"><a href="#3-2-执行模式" class="headerlink" title="3.2 执行模式"></a>3.2 执行模式</h3><ul><li><a href="https://kokkos.github.io/kokkos-core-wiki/API/core/parallel-dispatch/parallel_for.html"><code>parallel_for（）</code></a>：以不确定的顺序执行一个函数指定的次数，</li><li><a href="https://kokkos.github.io/kokkos-core-wiki/API/core/parallel-dispatch/parallel_reduce.html"><code>parallel_reduce（）</code></a>：将执行与归约操作相结合，<code>parallel_for()</code></li><li><a href="https://kokkos.github.io/kokkos-core-wiki/API/core/parallel-dispatch/parallel_scan.html"><code>parallel_scan（）</code></a>：将操作与每个操作的输出值的前缀或后缀扫描相结合，以及<code>parallel_for()</code></li><li><code>task</code>：执行依赖于其他函数的单个函数。</li></ul><h3 id="3-3-执行策略"><a href="#3-3-执行策略" class="headerlink" title="3.3 执行策略"></a>3.3 执行策略</h3><h4 id="3-3-1-range-policies"><a href="#3-3-1-range-policies" class="headerlink" title="3.3.1 range policies"></a>3.3.1 range policies</h4><p>range对该范围的每个元素执行一次操作，没有执行顺序或并发的规定</p><h4 id="3-3-2-team-policies"><a href="#3-3-2-team-policies" class="headerlink" title="3.3.2 team policies"></a>3.3.2 team policies</h4><p>用于实现分层并行性（多层并行），为此，kokkos将线程分组到teams，称为thread team线程组。</p><p>team中的线程可以通过barrier进行同步，并共享一个可用于临时存储的暂存器内存。</p><p>暂存盘scratch pad memory与cuda中共享内存对应。league&#x2F;team来源于openmp。</p><h3 id="3-4-内存空间"><a href="#3-4-内存空间" class="headerlink" title="3.4 内存空间"></a>3.4 内存空间</h3><p>指定数据的物理位置以及某些访问特性。不同的逻辑内存空间允许cuda编程中的UVM内存等概念</p><h3 id="3-5-内存布局"><a href="#3-5-内存布局" class="headerlink" title="3.5 内存布局"></a>3.5 内存布局</h3><p>布局表示从逻辑索引到数据分配地址偏移量的映射，通过该神布局可以优化给定算法中数据访问模式。如果实现提供多态布局（即数据结构可以在编译或运行时使用不同的布局实例化），则可以执行依赖于体系结构的优化。</p><h3 id="3-6-内存特征"><a href="#3-6-内存特征" class="headerlink" title="3.6 内存特征"></a>3.6 内存特征</h3><p>内存特征指定如何在算法中访问数据结构。特征表示使用场景，例如原子访问、随机访问和流加载或存储。通过将这些属性放在数据结构上，编程模型的实现可以插入最佳加载和存储操作。如果编译器实现了编程模型，它可以推理访问模式并使用它来通知代码转换。</p><h2 id="4-编译"><a href="#4-编译" class="headerlink" title="4.编译"></a>4.编译</h2><p>略过</p><h2 id="5-初始化"><a href="#5-初始化" class="headerlink" title="5.初始化"></a>5.初始化</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Kokkos_Core.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">  Kokkos::<span class="built_in">initialize</span>(argc,argv);</span><br><span class="line"></span><br><span class="line">  Kokkos::<span class="built_in">finalize</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-view"><a href="#6-view" class="headerlink" title="6.view"></a>6.view</h2><h3 id="6-1-创建和使用view"><a href="#6-1-创建和使用view" class="headerlink" title="6.1 创建和使用view"></a>6.1 创建和使用view</h3><p>每个view在编译时决定将数据存储在哪个内存空间中。</p><p>view中有betadata和data两个概念，metadata存储数据地址和其他的属性，data存数据，metadata在hostmemoryspace中，所以我们在host可以知道view的属性，data在view的内存空间中，如下图所示。</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20230224164610648.png" alt="image-20230224164610648"></p><p>上图view的内存空间是cudaspace，创建后metadata和data如图所示，当view在parallel中被访问时，变为下图</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20230224164737138.png" alt="image-20230224164737138"></p><p>metadata复制到cudamemory中，所以GPU可以访问view的属性</p><p>再举一个例子，如下图所示，在parallel中访问host的属性可以成功，但是访问host的数据将会失败</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20230224164939486.png" alt="image-20230224164939486"></p><h4 id="6-1-1-建造view"><a href="#6-1-1-建造view" class="headerlink" title="6.1.1 建造view"></a>6.1.1 建造view</h4><p>view使用数组的维数代表view数据的维数，各个维度的大小可以在运行时确定，也可以在编译期确定</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//运行时确定</span></span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> N0 = ...;</span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> N1 = ...;</span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> N2 = ...;</span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> N3 = ...;</span><br><span class="line"><span class="function">Kokkos::View&lt;<span class="type">int</span>****&gt; <span class="title">a</span> <span class="params">(<span class="string">&quot;some label&quot;</span>, N0, N1, N2, N3)</span></span>;</span><br><span class="line"><span class="comment">//两维 第一维是运行时确定，第二维是编译时确定</span></span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> N = ...;</span><br><span class="line"><span class="function">Kokkos::View&lt;<span class="type">double</span>*[3]&gt; <span class="title">b</span> <span class="params">(<span class="string">&quot;another label&quot;</span>, N)</span></span>;</span><br></pre></td></tr></table></figure><p>view最多可以有8个维度，运行时维度（如果有）应当在编译时维度的前面</p><h4 id="6-1-2-访问条目"><a href="#6-1-2-访问条目" class="headerlink" title="6.1.2 访问条目"></a>6.1.2 访问条目</h4><p>可以使用括号来访问view的条目</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">size_t</span> N = ...;</span><br><span class="line"><span class="function">Kokkos::View&lt;<span class="type">double</span>*[3][4]&gt; <span class="title">a</span> <span class="params">(<span class="string">&quot;some label&quot;</span>, N)</span></span>;</span><br><span class="line"><span class="comment">// KOKKOS_LAMBDA macro includes capture-by-value specifier [=].</span></span><br><span class="line">Kokkos::<span class="built_in">parallel_for</span> (N, <span class="built_in">KOKKOS_LAMBDA</span> (<span class="type">const</span> <span class="type">ptrdiff_t</span> i) &#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> j = ...;</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> k = ...;</span><br><span class="line">  <span class="type">const</span> <span class="type">double</span> a_ijk = <span class="built_in">a</span>(i,j,k);</span><br><span class="line">  <span class="comment">/* rest of the loop body */</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>通常，只能在允许访问该view的执行空间中访问该view的条目</p><h4 id="6-1-3-自动释放"><a href="#6-1-3-自动释放" class="headerlink" title="6.1.3 自动释放"></a>6.1.3 自动释放</h4><p>view通过引用计数机制自动管理view的释放</p><h4 id="6-1-4-调整大小"><a href="#6-1-4-调整大小" class="headerlink" title="6.1.4 调整大小"></a>6.1.4 调整大小</h4><p>可以使用非成员函数<code>resize</code>来调整kokkos view的大小</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate a view with 100x50x4 elements</span></span><br><span class="line"><span class="function">Kokkos::View&lt;<span class="type">int</span>**[4]&gt; <span class="title">a</span><span class="params">( <span class="string">&quot;a&quot;</span>, <span class="number">100</span>,<span class="number">50</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// Resize a to 200x50x4 elements; the original allocation is freed</span></span><br><span class="line">Kokkos::<span class="built_in">resize</span>(a, <span class="number">200</span>,<span class="number">50</span>);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// Create a second view b viewing the same data as a</span></span><br><span class="line">Kokkos::View&lt;<span class="type">int</span>**[<span class="number">4</span>]&gt; b = a;</span><br><span class="line"><span class="comment">// Resize a again to 300x60x4 elements; b is still 200x50x4</span></span><br><span class="line">Kokkos::<span class="built_in">resize</span>(a,<span class="number">300</span>,<span class="number">60</span>);</span><br></pre></td></tr></table></figure><h3 id="6-2-布局"><a href="#6-2-布局" class="headerlink" title="6.2 布局"></a>6.2 布局</h3><h4 id="6-2-1-strides-and-dimensions"><a href="#6-2-1-strides-and-dimensions" class="headerlink" title="6.2.1 strides  and dimensions"></a>6.2.1 strides  and dimensions</h4><p>布局是指从多维索引(i,j,k)到物理内存偏移量的映射。布局有行主序（layoutLeft）列主序(layoutRight)，它们可以共同由strided描述，对于跨步布局，每个维度都有一个步幅。该维度的步长决定了两个数组条目在内存中相距多远，其在该维度中的索引仅相差一个，而其其他索引都相同。例如，对于步幅为 (s_1, s_2, s_3) 的 3-D 步幅视图，条目 (i, j, k) 和 (i, j+1, k) 在内存中是 s_2 个条目（不是字节）。 Kokkos 称之为 LayoutStride。</p><p>strieds可能与维度不同，因为kokkos可以保存缓存或者向量对齐。可以使用<code>extent</code>函数访问view的维度。可以通过<code>stride</code>函数访问步幅</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">size_t</span> N0 = ...;</span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> N1 = ...;</span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> N2 = ...;</span><br><span class="line"><span class="function">Kokkos::View&lt;<span class="type">int</span>***&gt; <span class="title">a</span> <span class="params">(<span class="string">&quot;a&quot;</span>, N0, N1, N2)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> dim1 = a.<span class="built_in">extent</span> (<span class="number">1</span>); <span class="comment">// returns dimension 1</span></span><br><span class="line"><span class="type">size_t</span> strides[<span class="number">3</span>]</span><br><span class="line">a.<span class="built_in">stride</span> (strides); <span class="comment">// fill &#x27;strides&#x27; with strides</span></span><br></pre></td></tr></table></figure><h4 id="6-2-2-默认布局取决于执行空间"><a href="#6-2-2-默认布局取决于执行空间" class="headerlink" title="6.2.2 默认布局取决于执行空间"></a>6.2.2 默认布局取决于执行空间</h4><p>kokkos根据其执行空间选择view的默认布局，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">View&lt;<span class="type">int</span>**, Cuda&gt;LayoutLeft;</span><br><span class="line">View&lt;<span class="type">int</span>**, OpenMP&gt;LayoutRight;</span><br></pre></td></tr></table></figure><p>原理：CPU的GPU都使用一个线程计算一行，CPU中顺序访存，所以layout-right行主序</p><p>GPU中每个线程计算一行，但是一个warp中的32个线程计算的是同列的元素，由于合并访存的存在，最好这同列的元素是连续存储的。所以layout-left行主序</p><h4 id="6-2-3-明确指定布局"><a href="#6-2-3-明确指定布局" class="headerlink" title="6.2.3 明确指定布局"></a>6.2.3 明确指定布局</h4><p>如果想给BLAS LAPACK一个视图，可以将布局指定为视图的模板参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">size_t</span> N0 = ...;</span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> N1 = ...;</span><br><span class="line"><span class="function">Kokkos::View&lt;<span class="type">double</span>**, Kokkos::LayoutLeft&gt; <span class="title">A</span> <span class="params">(<span class="string">&quot;A&quot;</span>, N0, N1)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// Get &#x27;LDA&#x27; for BLAS / LAPACK</span></span><br><span class="line"><span class="type">int</span> strides[<span class="number">2</span>]; <span class="comment">// any integer type works in stride()</span></span><br><span class="line">A.<span class="built_in">stride</span> (strides);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LDA = strides[<span class="number">1</span>];</span><br></pre></td></tr></table></figure><h3 id="6-3-管理数据放置"><a href="#6-3-管理数据放置" class="headerlink" title="6.3 管理数据放置"></a>6.3 管理数据放置</h3><h4 id="6-3-1-内存空间"><a href="#6-3-1-内存空间" class="headerlink" title="6.3.1 内存空间"></a>6.3.1 内存空间</h4><p>view分配在内存空间中，默认会被分配在默认执行空间的默认内存空间。也可以将内存空间明确指定为模板参数，例如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分配在cudaspace</span></span><br><span class="line"><span class="function">Kokkos::View&lt;<span class="type">int</span>*, Kokkos::CudaSpace&gt; <span class="title">a</span> <span class="params">(<span class="string">&quot;a&quot;</span>, <span class="number">100000</span>)</span></span>;</span><br><span class="line"><span class="comment">//分配在主机的默认内存空间，使用默认主机执行空间进行首次接触初始化</span></span><br><span class="line"><span class="function">Kokkos::View&lt;<span class="type">int</span>*, Kokkos::HostSpace&gt; <span class="title">a</span> <span class="params">(<span class="string">&quot;a&quot;</span>, <span class="number">100000</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>kokkos的执行空间和内存空间没有双射关系，kokkos提供了一种方法来显示的将两个view提供给device</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Kokkos::View&lt;<span class="type">int</span>*, Kokkos::Device&lt;Kokkos::Cuda,Kokkos::CudaUVMSpace&gt; &gt; <span class="built_in">a</span> (<span class="string">&quot;a&quot;</span>, <span class="number">100000</span>);</span><br><span class="line">Kokkos::View&lt;<span class="type">int</span>*, Kokkos::Device&lt;Kokkos::OpenMP,Kokkos::CudaUVMSpace&gt; &gt; <span class="built_in">b</span> (<span class="string">&quot;b&quot;</span>, <span class="number">100000</span>);</span><br></pre></td></tr></table></figure><p>在这种情况下，ab在相同的内存空间下，但是a在GPU上初始化，b在host上初始化。</p><p>理解view的可访问性只取决于内存空间与执行空间无关是非常重要的，上面的a和b有相同的访问属性，不同的是它们怎样初始化以及怎样resize、深拷贝这种与执行空间相关的操作。</p><h4 id="6-3-2-深拷贝和hostMirror"><a href="#6-3-2-深拷贝和hostMirror" class="headerlink" title="6.3.2 深拷贝和hostMirror"></a>6.3.2 深拷贝和hostMirror</h4><p>将数据从一个视图复制到另一个视图，特别是在不同内存空间的视图之间，称为深复制。 Kokkos 从不执行隐藏的深层复制。为此，用户必须调用该函数。例如：deep_copy</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Kokkos::View&lt;<span class="type">int</span>*&gt; <span class="title">a</span> <span class="params">(<span class="string">&quot;a&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Kokkos::View&lt;<span class="type">int</span>*&gt; <span class="title">b</span> <span class="params">(<span class="string">&quot;b&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">Kokkos::<span class="built_in">deep_copy</span> (a, b); <span class="comment">// copy contents of b into a</span></span><br></pre></td></tr></table></figure><p>深拷贝只能在具有相同内存布局和填充的视图之间执行。例如以下两个操作是无效的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Kokkos::View&lt;<span class="type">int</span>*[3], Kokkos::CudaSpace&gt; <span class="title">a</span> <span class="params">(<span class="string">&quot;a&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Kokkos::View&lt;<span class="type">int</span>*[3], Kokkos::HostSpace&gt; <span class="title">b</span> <span class="params">(<span class="string">&quot;b&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">Kokkos::<span class="built_in">deep_copy</span> (a, b); <span class="comment">// This will give a compiler error</span></span><br><span class="line"></span><br><span class="line"><span class="function">Kokkos::View&lt;<span class="type">int</span>*[3], Kokkos::LayoutLeft, Kokkos::CudaSpace&gt; <span class="title">c</span> <span class="params">(<span class="string">&quot;c&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Kokkos::View&lt;<span class="type">int</span>*[3], Kokkos::LayoutLeft, Kokkos::HostSpace&gt; <span class="title">d</span> <span class="params">(<span class="string">&quot;d&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">Kokkos::<span class="built_in">deep_copy</span> (c, d); <span class="comment">// This might give a runtime error</span></span><br></pre></td></tr></table></figure><p>第一个不起作用，因为 CudaSpace 和 HostSpace 的默认布局不同。编译器会捕捉到这一点，因为不存在将视图从一个布局复制到另一个布局的 deep_copy 函数的重载。如果两个内存空间的填充设置不同，第二种情况将在运行时失败。这将导致不同的分配大小，从而阻止直接内存复制.</p><p>要解决深浅拷贝的问题，要么使用CudaUVMSpace,要么使用mirror</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20221208150211356.png" alt="image-20221208150211356"></p><p> 如何使用CudaUVMSpace：可能会有性能问题</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20230224165310559.png" alt="image-20230224165310559"></p><p>如何使用mirror（显 式内存拷贝）</p><ol><li>在某个内存空间创建view</li><li>创建这个view的镜像hostView在host memory space</li><li>在host上填充hostView</li><li>将hostView深拷贝到view中  <code>Kokkos::deep_copy(view,hostView)</code></li><li>启动kernel处理view</li><li>如果需要的话，将view深拷贝回hostView</li></ol><p>需要注意的是当view在hostSpcace时，<code>create_mirror_view</code>只有在无法访问view的数据时才会分配数据，否则只会引用数据，而<code>create_mirror</code>总会分配数据。</p><p>mirror的layout与device上的数据相同，这意味着host上的mirror可能不会有很好的性能，但是做IO这种工作是没问题的。</p><p>记住：kokkos绝对  不会隐式的执行深拷贝</p><h3 id="6-4-访问特性"><a href="#6-4-访问特性" class="headerlink" title="6.4 访问特性"></a>6.4 访问特性</h3><p>访问特征是通过一个可选的模板参数来指定的，该参数在参数列表中排在最后。多个特征可以与二元“|”运算符组合</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Kokkos::View&lt;<span class="type">double</span>*, Kokkos::MemoryTraits&lt;SomeTrait&gt; &gt; a;</span><br><span class="line">Kokkos::View&lt;<span class="type">const</span> <span class="type">double</span>*, Kokkos::MemoryTraits&lt;SomeTrait | SomeOtherTrait&gt; &gt; b;</span><br><span class="line">Kokkos::View&lt;<span class="type">int</span>*, Kokkos::LayoutLeft, Kokkos::MemoryTraits&lt;SomeTrait | SomeOtherTrait&gt; &gt; c;</span><br><span class="line">Kokkos::View&lt;<span class="type">int</span>*, MemorySpace, Kokkos::MemoryTraits&lt;SomeTrait | SomeOtherTrait&gt; &gt; d;</span><br><span class="line">Kokkos::View&lt;<span class="type">int</span>*, Kokkos::LayoutLeft, MemorySpace, Kokkos::MemoryTraits&lt;SomeTrait&gt; &gt; e;</span><br></pre></td></tr></table></figure><h3 id="6-5-非托管视图"><a href="#6-5-非托管视图" class="headerlink" title="6.5 非托管视图"></a>6.5 非托管视图</h3><p>让 Kokkos 控制内存分配总是更好，但有时您别无选择。例如，您可能必须使用返回原始指针的应用程序或接口。 Kokkos 允许您将原始指针包装在非托管视图中。 “非托管”意味着 Kokkos 不对这些视图进行引用计数或自动释放。以下示例显示如何创建主机内存的非托管视图。您也可以为 CUDA 设备内存执行此操作，或者实际上为分配在任何内存空间中的内存执行此操作，方法是相应地指定视图的执行或内存空间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sometimes other code gives you a raw pointer, ...</span></span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> N0 = ...;</span><br><span class="line"><span class="type">double</span>* x_raw = <span class="built_in">malloc</span> (N0 * <span class="built_in">sizeof</span> (<span class="type">double</span>));</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ... but you want to access it with Kokkos.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// malloc() returns host memory, so we use the host memory space HostSpace.  </span></span><br><span class="line">  <span class="comment">// Unmanaged Views have no label because labels work with the reference counting system.</span></span><br><span class="line">  Kokkos::View&lt;<span class="type">double</span>*, Kokkos::HostSpace, Kokkos::MemoryTraits&lt;Kokkos::Unmanaged&gt; &gt;</span><br><span class="line">    <span class="built_in">x_view</span> (x_raw, N0);</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">functionThatTakesKokkosView</span> (x_view);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// It&#x27;s safest for unmanaged Views to fall out of scope before freeing their memory.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span> (x_raw);</span><br></pre></td></tr></table></figure><h2 id="7-并行"><a href="#7-并行" class="headerlink" title="7.并行"></a>7.并行</h2><p>kokkos三种并行操作</p><ul><li><a href="https://kokkos.github.io/kokkos-core-wiki/API/core/parallel-dispatch/parallel_for.html"><code>parallel_for()</code></a> </li><li><a href="https://kokkos.github.io/kokkos-core-wiki/API/core/parallel-dispatch/parallel_reduce.html"><code>parallel_reduce()</code></a> </li><li><a href="https://kokkos.github.io/kokkos-core-wiki/API/core/parallel-dispatch/parallel_scan.html"><code>parallel_scan()</code></a></li></ul><p>两种循环主题 :functors 和lambdas，必须使用<code>KOKKOS_INLINE_FUNCTION</code>标记functors，使用<code>KOKKOS_LAMBDA</code>标记lambda</p><h3 id="7-1-指定并行循环体"><a href="#7-1-指定并行循环体" class="headerlink" title="7.1 指定并行循环体"></a>7.1 指定并行循环体</h3><h4 id="7-1-1-functors"><a href="#7-1-1-functors" class="headerlink" title="7.1.1 functors"></a>7.1.1 functors</h4><p>仿函数，必须是const，并且由<code>KOKKOS_INLINE_FUNCTION</code>修饰</p><h4 id="7-1-2-lambda"><a href="#7-1-2-lambda" class="headerlink" title="7.1.2 lambda"></a>7.1.2 lambda</h4><p>建议使用按值捕获<code>[=]()&#123;&#125;</code></p><h3 id="7-1-3-指定执行空间"><a href="#7-1-3-指定执行空间" class="headerlink" title="7.1.3 指定执行空间"></a>7.1.3 指定执行空间</h3><p>如果一个functor有<code>execution_space</code>public typedef ,parallel时这个functor只会在这个执行空间上执行，如果没有，将会在默认执行空间执行。lambda没有typedef，所以除非指定，否则只会运行在默认执行空间</p><h3 id="7-2-parallel-for"><a href="#7-2-parallel-for" class="headerlink" title="7.2 parallel for"></a>7.2 parallel for</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ExecPolicy, <span class="keyword">class</span> FunctorType&gt;</span></span><br><span class="line"><span class="function"><span class="title">Kokkos::parallel_for</span><span class="params">(<span class="type">const</span> std::string &amp;name, <span class="type">const</span> ExecPolicy &amp;policy, <span class="type">const</span> FunctorType &amp;functor)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ExecPolicy, <span class="keyword">class</span> FunctorType&gt;</span></span><br><span class="line"><span class="function"><span class="title">Kokkos::parallel_for</span><span class="params">(<span class="type">const</span> ExecPolicy &amp;policy, <span class="type">const</span> FunctorType &amp;functor)</span></span>;</span><br></pre></td></tr></table></figure><p><code>ExecPolicy</code>可以为简单的数字，这时的执行空间为默认的执行空间，也可以指定执行空间和其他执行策略。</p><p>kokkos必须保证代码中使用的执行空间在编译时启动(enabled)</p><h3 id="7-3-parallel-reduce"><a href="#7-3-parallel-reduce" class="headerlink" title="7.3 parallel reduce"></a>7.3 parallel reduce</h3><p>使用reduce时，functor必须定义<code>using value_type=int;</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">squaresum</span> &#123;</span><br><span class="line">  <span class="comment">// Specify the type of the reduction value with a &quot;value_type&quot;</span></span><br><span class="line">  <span class="comment">// alias.  In this case, the reduction value has type int.</span></span><br><span class="line">  <span class="keyword">using</span> value_type = <span class="type">int</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function">KOKKOS_INLINE_FUNCTION</span></span><br><span class="line"><span class="function">  <span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> <span class="type">int</span> i, <span class="type">int</span>&amp; lsum)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    lsum += i * i;  <span class="comment">// compute the sum of squares</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">  Kokkos::<span class="built_in">initialize</span>(argc, argv);</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> n = <span class="number">10</span>;</span><br><span class="line">  <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">  Kokkos::<span class="built_in">parallel_reduce</span>(n, <span class="built_in">squaresum</span>(), sum);</span><br><span class="line">  <span class="comment">// Compare to a sequential loop.</span></span><br><span class="line">  <span class="type">int</span> seqSum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    seqSum += i * i;</span><br><span class="line">  &#125;</span><br><span class="line">  Kokkos::<span class="built_in">finalize</span>();</span><br><span class="line">  <span class="keyword">return</span> (sum == seqSum) ? <span class="number">0</span> : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>lambda</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Kokkos::<span class="built_in">parallel_reduce</span>(n, <span class="built_in">KOKKOS_LAMBDA</span>(<span class="type">const</span> <span class="type">int</span> i, <span class="type">int</span>&amp; lsum) &#123; lsum += i * i; &#125;, sum);</span><br></pre></td></tr></table></figure><h2 id="8-层次并行"><a href="#8-层次并行" class="headerlink" title="8.层次并行"></a>8.层次并行</h2><h3 id="8-1-现代高性能计算机并行层次"><a href="#8-1-现代高性能计算机并行层次" class="headerlink" title="8.1 现代高性能计算机并行层次"></a>8.1 现代高性能计算机并行层次</h3><p>CPU集群</p><ol><li>CPU SOCKET共享对相同内存和网络资源访问</li><li>socket内的内核有共享的末级缓存(last level cache LLC)</li><li>同一个核心上的超线程可访问共享的L1（L2）cache，并将指令提交给相同的执行单元</li><li>向量单元对多个数据项执行共享指令</li></ol><p>GPU系统</p><ol><li>同一节点上的多个GPU共享对同一主机内存和网络资源的访问</li><li>core clusters（SM）具有共享缓存并可以访问单个GPU上的相同高带宽内存</li><li>在同一core cluster上的线程可以访问相同的L1缓存和暂存内存</li><li>在相同warp上的线程可以同步并且可以直接寄存器交换数据</li></ol><h2 id="SIMD"><a href="#SIMD" class="headerlink" title="SIMD"></a>SIMD</h2><p>SIMD type：一个表现的像标量的短向量</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20230224214839938.png" alt="image-20230224214839938"></p><p>存储类型和临时变量</p><ul><li>大多数simd::simd types有相同的存储类型</li><li>simd&lt;T,cuda_warp<N>&gt;将会使用warp级别并行</li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;KOKKOS编程指南&quot;&gt;&lt;a href=&quot;#KOKKOS编程指南&quot; class=&quot;headerlink&quot; title=&quot;KOKKOS编程指南&quot;&gt;&lt;/a&gt;KOKKOS编程指南&lt;/h1&gt;&lt;h2 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot;</summary>
        
      
    
    
    
    
    <category term="hpc" scheme="https://mightcoder.com/tags/hpc/"/>
    
    <category term="gpu" scheme="https://mightcoder.com/tags/gpu/"/>
    
    <category term="kokkos" scheme="https://mightcoder.com/tags/kokkos/"/>
    
  </entry>
  
  <entry>
    <title>Rocm</title>
    <link href="https://mightcoder.com/2023/05/26/rocm/"/>
    <id>https://mightcoder.com/2023/05/26/rocm/</id>
    <published>2023-05-26T13:39:37.000Z</published>
    <updated>2023-05-26T10:37:08.184Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ROCm——open-software-platform-for-accelerated-computing"><a href="#ROCm——open-software-platform-for-accelerated-computing" class="headerlink" title="ROCm——open software platform for accelerated computing"></a>ROCm——open software platform for accelerated computing</h1><ul><li>拥有完善的库、工具和管理API</li><li>拥有开源的OpenMP和HIP编译器</li><li>规模从工作站到云到百万兆级计算</li><li>完善的生态系统</li></ul><p>HIP：c++运行时api，支持AMD和nvidaGPU</p><h2 id="AMD硬件架构"><a href="#AMD硬件架构" class="headerlink" title="AMD硬件架构"></a>AMD硬件架构</h2><h3 id="GCN-硬件概述"><a href="#GCN-硬件概述" class="headerlink" title="GCN 硬件概述"></a>GCN 硬件概述</h3><p>AMD GPU由一个或多个着色器引擎(SE)以及一个命令处理器组成，着色器引擎内又有负载管理器和计算单元(CU)。</p><p>命令处理器从命令队列中读取命令，提交给工作负载管理器，然后工作负载管理器将任务分配给计算单元。</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20230330161108592.png" alt="image-20230330161108592"></p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20230330161322400.png" alt="image-20230330161322400"></p><p>以下部分AMD设备的SE、CUs&#x2F;SE数量</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20230330161505315.png" alt="image-20230330161505315"></p><p>workgroup–block</p><p>workitem–thread</p><p> wavefont–warp</p><p>amd硬件允许每个workgroup最多有16个wavefont</p><p>将硬件和抽象对应起来，AMD GPU的调度方式如下：</p><p>命令处理器从命令队列中获取kernel，创建workgroup，然后将其分发到SE，SE上的工作负载管理器为workgroup创建wavefont，并将其发送到CU。与cuda相同，一个workgroup对应一个SE，workgroup的所有wavefont都在一个SE上。</p><h3 id="GPU-memory-and-IO"><a href="#GPU-memory-and-IO" class="headerlink" title="GPU memory and IO"></a>GPU memory and IO</h3><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20230330211509853.png" alt="image-20230330211509853"></p><p>如何工作？</p><ol><li>GPU向命令队列提交DMA传输块，这个过程无需操作系统级的内核调用，只需要用户级别的内存写入</li><li>命令处理器(CP)解析请求</li><li>CP将其提交给DMA引擎（这部分操作与计算单元计算及其他传输过程同时进行）</li><li>DMA引擎负责系统内存到HBM或者是设备之间的双向传输（传输在进程的虚拟内存空间中进行）</li></ol><h3 id="GCN-计算单元-CU-内部结构"><a href="#GCN-计算单元-CU-内部结构" class="headerlink" title="GCN 计算单元(CU)内部结构"></a>GCN 计算单元(CU)内部结构</h3><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20230403164307370.png" alt="image-20230403164307370"></p><p>在每个CU内部有一个标量单元和8KB的标量通用寄存器(sGPR)</p><ul><li>被波前所有线程共享</li><li>用于流控制以及指针计算等</li><li>有自己的通用寄存器池(GPR pool)和标量数据缓存</li></ul><p>每个计算单元有四个矢量单元(16通道SIMD)，一个CU的吞吐量：64个单精度操作&#x2F;每个时钟周期。有4*64KB的项链寄存器(vGPR)。</p><p>每个矢量单元有：</p><ul><li>一个16通道的IEEE754（浮点数）向量ALU</li><li>一个64KB的向量寄存器——四个矢量单元总共256个寄存器，每个寄存器有64个4字节宽的条目（如果如果需要8字节的浮点数计算，使用寄存器对即可）</li></ul><p>每个矢量单元有一个用于10个波前的指令缓冲器，每个计算单元可同时启用40个波前</p><p>最后，每个计算单元都有相应的局部数据共享(LDS)</p><ul><li>有32个bank，附带冲突解决方案</li><li>可以用于同一个工作组中所有线程的数据共享</li></ul><p>下面是一张nvdia到AMD的术语对照表</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20230403164858303.png" alt="image-20230403164858303"></p><h2 id="AMD-GPU编程概念和HIP"><a href="#AMD-GPU编程概念和HIP" class="headerlink" title="AMD GPU编程概念和HIP"></a>AMD GPU编程概念和HIP</h2><h3 id="什么是HIP"><a href="#什么是HIP" class="headerlink" title="什么是HIP"></a>什么是HIP</h3><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20230403170824793.png" alt="image-20230403170824793"></p><p>HIP是（Heterogeneous-compute interface for protability）的首字母缩写，是C++运行时API和内核语言，开发者可以创建可移植应用，这些应用可以运行在AMD和CUDA设备</p><ul><li>完全开源</li><li>为应用程序提供一套API，利用AMD和CUDA设备进行GPU加速</li><li>语法类似CUDA，大多数CUDA的API可以直接转换：cuda-&gt;hip</li><li>支持cuda运行时功能的最强子集，大多数情况下可以支持CUDA API所提供的功能</li></ul><h3 id="HOST和DEVICE"><a href="#HOST和DEVICE" class="headerlink" title="HOST和DEVICE"></a>HOST和DEVICE</h3><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20230403171023070.png" alt="image-20230403171023070"></p><p>什么是host device </p><h3 id="kernel-memory-host代码的结构"><a href="#kernel-memory-host代码的结构" class="headerlink" title="kernel,memory,host代码的结构"></a>kernel,memory,host代码的结构</h3><p>grid:just like cuda</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20230403171513496.png" alt="image-20230403171513496"></p><p>block thread:</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20230403171604520.png" alt="image-20230403171604520"></p><p>2D blcok thread</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20230403171641861.png" alt="image-20230403171641861"></p><p>kernel</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20230403171715982.png" alt="image-20230403171715982"></p><p>如何启动</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20230403171732626.png" alt="image-20230403171732626"></p><p>SIMD</p><p>内核到硬件的自然映射:</p><ul><li>块被动态地调度到CUs上</li><li>一个块中的所有线程都在同一个CU上执行</li><li>块中的线程共享LDS内存和L1缓存</li><li>块中的线程以64宽的块(称为“wavefont”)执行。</li><li>wavefont在SIMD单元上执行</li><li>如果一个wavefont停滞(例如数据依赖)，CUs可以快速切换到另一个wavefont</li></ul><p>一个好的做法是使块大小为64的倍数，并且有多个wavefont(例如256个线程)</p><p>device memory</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20230403172142458.png" alt="image-20230403172142458"></p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20230403172208102.png" alt="image-20230403172208102"></p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20230403172252314.png" alt="image-20230403172252314"></p><p>错误检查（非常有用）</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20230403172334003.png" alt="image-20230403172334003"></p><p>完整实例</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20230403172434166.png" alt="image-20230403172434166"></p><h2 id="设备管理，同步和MPI"><a href="#设备管理，同步和MPI" class="headerlink" title="设备管理，同步和MPI"></a>设备管理，同步和MPI</h2><p>多GPU？多个host线程？多个MPIranks？</p><p>获取设备数量，指定设备，查询设备信息</p><p>host可以通过交换当前选中的设备来管理多个设备。</p><p>MPIranks可以设置不同的设备或者设置多个ranks，通过over-subscribe向单个设备发出命令。</p><p>查询设备属性。<code>hip_runtime_api.h</code></p><h3 id="阻塞调用及非阻塞调用"><a href="#阻塞调用及非阻塞调用" class="headerlink" title="阻塞调用及非阻塞调用"></a>阻塞调用及非阻塞调用</h3><p><code>hipLaunchKernelGGL</code>是一种对主机的非阻塞调用，异步</p><p><code>hipMemcpy</code>是阻塞操作，<code>hipMemcpyAsync</code>非阻塞</p><h3 id="STREAM"><a href="#STREAM" class="headerlink" title="STREAM"></a>STREAM</h3><p>流相当于任务队列，一系列类似内核函数、memcpy或者事件的集合，流中的任务会按顺序执行。</p><p>不同流中的任务可以叠加使用和划分设备资源</p><p>创建和销毁：</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20230403204048258.png" alt="image-20230403204048258"></p><p>如果传入0或者NULL作为<code>hipStream_t</code>参数表示这个函数在NULL STREAM上执行</p><ul><li>直到其他流中先进入队列的任务完成后NULL流上的任务才会开始</li><li>像<code>hipMemcpy</code>这样的隐式阻塞始终运行在NULL流上</li></ul><p>为什么要使用流：内核间并行（当然是可并行时，如果一个kernel占用全部的资源，使用流仍然无法并行）</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20230403204515907.png" alt="image-20230403204515907"></p><p>特别要说明的，以下三种操作有独立的引擎，可以重叠执行</p><ul><li>host-&gt;device</li><li>device-&gt;host</li><li>kernel</li></ul><p>这三种操作重叠执行的前提：</p><ul><li>重叠操作应该在单独的、非NULL流中</li><li>host memory应该是固定的(pinned)</li></ul><h3 id="pinned-memory"><a href="#pinned-memory" class="headerlink" title="pinned memory"></a>pinned memory</h3><p>默认情况下主机内存是分页的，GPU可以直接访问host数据如果已经固定（不会报缺页异常）</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20230403205538086.png" alt="image-20230403205538086"></p><p>如果hostmemory 固定，memcpy的带宽也会增大。因此，如果频繁的在h d之间传输数据，推荐在固定区域分配主机内存。</p><p>经典应用：</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20230403205804842.png" alt="image-20230403205804842"></p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20230403205830279.png" alt="image-20230403205830279"></p><h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>主机与设备之间的两种同步</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20230403205916730.png" alt="image-20230403205916730"></p><p>流之间的同步：事件event</p><h3 id="event"><a href="#event" class="headerlink" title="event"></a>event</h3><p>创建、绑定、销毁</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20230403210052673.png" alt="image-20230403210052673"></p><p>主机与事件的同步、记录两个事件之间的时间、在某个事件完成前阻塞某个流</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20230403210209877.png" alt="image-20230403210209877"></p><p>使用流的一个例子</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20230403210511246.png" alt="image-20230403210511246"></p><h2 id="共享内存和线程同步"><a href="#共享内存和线程同步" class="headerlink" title="共享内存和线程同步"></a>共享内存和线程同步</h2><h3 id="函数限定符"><a href="#函数限定符" class="headerlink" title="函数限定符"></a>函数限定符</h3><p>hipcc对源码进行两次编译，一次编译host代码，一次编译device代码</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20230403210707176.png" alt="image-20230403210707176"></p><h3 id="避免线程分散-thread-divergence"><a href="#避免线程分散-thread-divergence" class="headerlink" title="避免线程分散(thread divergence)"></a>避免线程分散(thread divergence)</h3><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20230403210926801.png" alt="image-20230403210926801"></p><p>同一个wavefont内出现线程分散对性能有很重要的影响</p><h3 id="设备代码上的内存声明"><a href="#设备代码上的内存声明" class="headerlink" title="设备代码上的内存声明"></a>设备代码上的内存声明</h3><ul><li>malloc&#x2F;free在device代码上不被支持</li><li>变量或数组可以在栈上声明</li><li>在设备代码声明的栈变量被分配到寄存器上，并且是每个线程的私有变量</li><li>线程可以通过设备指针访问公有内存，但是不共享内存，唯一的例外是将内存声明为<code>__shared__</code></li></ul><p>在栈上声明为<code>__shared__</code>的变量在LDS和共享内存的每个块上分配一次，他们被同一个块中的线程共享。访问共享内存要访问设备内存和全局内存更快，比寄存器慢。</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20230403211712140.png" alt="image-20230403211712140"></p><p><code>__syncthreads</code>wavefont之间同步，阻塞wavefont直到所有的wavefont都到达这里。</p><p>最佳实践：用于避免死锁</p><p>注意：</p><ul><li>如果一个wavefont中的一个线程遇到<code>__syncthreads</code>，视作整个wavefont遇到<code>__syncthreads</code></li><li>wavefont可能回遇到不同的<code>__syncthreads</code>指令，如果其中一个wavefont退出了（exit或者执行完成内核），其他在等待<code>__syncthreads</code>的wavefont可以继续执行。</li></ul><p>动态共享内存</p><h2 id="编译器、库、工具"><a href="#编译器、库、工具" class="headerlink" title="编译器、库、工具"></a>编译器、库、工具</h2><p>编译器：hipcc  aomp（openmp）</p><p>hipcc调用hcc，hcc是clang的派生，因此可以在hipcc中使用熟悉的clang选项和标志</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20230403213133602.png" alt="image-20230403213133602"></p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20230403213307011.png" alt="image-20230403213307011"></p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20230403213348974.png" alt="image-20230403213348974"></p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20230403213417615.png" alt="image-20230403213417615"></p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20230403213439757.png" alt="image-20230403213439757"></p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;ROCm——open-software-platform-for-accelerated-computing&quot;&gt;&lt;a href=&quot;#ROCm——open-software-platform-for-accelerated-computing&quot;</summary>
        
      
    
    
    
    
    <category term="hpc" scheme="https://mightcoder.com/tags/hpc/"/>
    
    <category term="gpu" scheme="https://mightcoder.com/tags/gpu/"/>
    
    <category term="rocm" scheme="https://mightcoder.com/tags/rocm/"/>
    
  </entry>
  
  <entry>
    <title>cuda c权威编程指南笔记</title>
    <link href="https://mightcoder.com/2023/05/25/cuda%20c%E6%9D%83%E5%A8%81%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97%E7%AC%94%E8%AE%B0/"/>
    <id>https://mightcoder.com/2023/05/25/cuda%20c%E6%9D%83%E5%A8%81%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97%E7%AC%94%E8%AE%B0/</id>
    <published>2023-05-25T13:39:37.000Z</published>
    <updated>2023-05-25T13:35:23.351Z</updated>
    
    <content type="html"><![CDATA[<h1 id="cuda-c权威编程指南笔记"><a href="#cuda-c权威编程指南笔记" class="headerlink" title="cuda c权威编程指南笔记"></a>cuda c权威编程指南笔记</h1><h2 id="一、基于CUDA的异构并行计算"><a href="#一、基于CUDA的异构并行计算" class="headerlink" title="一、基于CUDA的异构并行计算"></a>一、基于CUDA的异构并行计算</h2><h3 id="1-1并行计算"><a href="#1-1并行计算" class="headerlink" title="1.1并行计算"></a>1.1并行计算</h3><p>并行性：包括任务并行和数据并行。</p><p>当多任务或函数可以独立的大规模的并行执行时，就是任务并行，任务并行的重点在于利用多核系统对数据进行分配。</p><p>当同时处理许多数据时，就是数据并行，数据并行的重点在于数据的分配。</p><p>CUDA编程非常适合解决数据并行计算的问题</p><p>数据划分方法：块划分和周期划分</p><p>块划分：每个线程计算一部分数据，通常这些数据有相同的大小</p><p>周期划分，每个线程计算数据的多部分</p><h2 id="二、CUDA编程模型"><a href="#二、CUDA编程模型" class="headerlink" title="二、CUDA编程模型"></a>二、CUDA编程模型</h2><p>关于<code>cudaMalloc()</code>参数的解释</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *da;</span><br><span class="line">cudaMalloc((<span class="type">void</span>**)&amp;da,size);</span><br></pre></td></tr></table></figure><p>这里da是int指针，在<code>cudaMalloc()</code>的参数中需要一个指向指针的指针（即<code>void**</code>），来将这个指针的值改变为GPU中的内存地址。如果直接传这个指针，只能改变这个指针指向地址的值而不能改变该指针的指向地址（值传递，实际上形参只复制了指针指向的地址）。</p><p>关于<code>cudaMemcpy()</code>的同步问题：</p><p> a）同一个stream（包括默认stream）中的kernel后面的copy函数总是会等到kernel结束才执行copy，无论是同步版的<code>cudaMemcpy()</code>还是异步版的<code>cudaMemcpyAsync()</code>。<br>  b）对于host端而言，<code>cudaMemcpy()</code>是同步返回的，而<code>cudaMemcpyAsync()</code>是异步返回的（不等真正执行完就返回的）。但这并不影响和kernel之间的配合。</p><h2 id="三、CUDA执行模型"><a href="#三、CUDA执行模型" class="headerlink" title="三、CUDA执行模型"></a>三、CUDA执行模型</h2><p>通过了解CUDA的执行模型来优化指令吞吐量。</p><h3 id="3-1CUDA执行模型概述"><a href="#3-1CUDA执行模型概述" class="headerlink" title="3.1CUDA执行模型概述"></a>3.1CUDA执行模型概述</h3><p>GPU是围绕着一个流式多处理器stream Multiprocessor（SM）的可拓展阵列搭建的，以Fermi架构为例，说明GPU的关键组件：</p><ul><li>CUDA核心</li><li>共享内存\一级缓存</li><li>寄存器文件</li><li>加载&#x2F;存储单元</li><li>特殊功能单元</li><li>线程束调度器</li></ul><p>下图为Ampere架构的A100GPU的SM架构：</p><p><img src="https://lh3.googleusercontent.com/raD52-V3yZtQ3WzOE0Cvzvt8icgGHKXPpN2PS_5MMyZLJrVxgMtLN4r2S2kp5jYI9zrA2e0Y8vAfpZia669pbIog2U9ZKdJmQ8oSBjof6gc4IrhmorT2Rr-YopMlOf1aoU3tbn5Q" alt="5"> </p><p>block，grid是抽象概念，物理层次是SM，warp。当启动kernel时，block被分布在可用的SM上运行，block一旦被调度到一个SM上，其中的线程只会在那个指定的SM上并发执行。多个block可能被分配到同一个SM上。</p><p>CUDA采用SIMT单指令多线程架构来管理和执行线程，每32个为一组，称为warp。warp中所有线程同时执行相同的指令，每个线程都有自己的指令计数器和寄存器状态，因此每个线程会有独立的程序执行路径。（SIMT侧重于线程级并行，且多线程执行的是同一指令（同一kernel函数））</p><p>逻辑层次和物理层次对应关系如下图（左侧第二个应该为block）：</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/202205181520819.png" alt="image-20220502202132210"></p><p>block和warp的对应关系如下图：</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/202205181526488.png" alt="image-20220502202410015"></p><p>同一个block中的线程可以同步，但是block间线程无法同步。</p><p>由于SM的资源限制，活跃的warp是有限的，但是warp间的切换是没有开销的，因为硬件资源已经分配到了SM上的线程和块中。当warp因为任何理由闲置时（例如从设备内存中读取数值），SM可以从同一SM上的常驻线程块中调度其他可用warp。</p><h3 id="3-2理解warp执行的本质"><a href="#3-2理解warp执行的本质" class="headerlink" title="3.2理解warp执行的本质"></a>3.2理解warp执行的本质</h3><h4 id="3-2-1-warp与block"><a href="#3-2-1-warp与block" class="headerlink" title="3.2.1 warp与block"></a>3.2.1 warp与block</h4><p>从逻辑视角看，线程可以组织成一维二维三维的block，然而，从硬件的角度看，所有的线程被组织成一维的，然后将其分配到warp中。</p><blockquote><p>block中warp的数量&#x3D;向上取整【block中线程总数&#x2F;warp大小（32）】</p></blockquote><p>因此，当block中线程数不能被32整除时，最后的warp有些线程就不会活跃，但是它们仍会消耗SM的资源比如寄存器。</p><h4 id="3-2-2-warp分化"><a href="#3-2-2-warp分化" class="headerlink" title="3.2.2 warp分化"></a>3.2.2 warp分化</h4><p>warp分化是指同一warp的线程在执行有分支的程序时，warp将连续连续执行每一个分支路径，同时会禁用不执行这一路径的线程。这会导致并行线程的数量降低，导致性能明显下降，且条件分支越多，并行性削减越明显。</p><p>造成warp分化的原因是SIMT特性，同一warp中的线程必须同时执行同样的指令。且GPU没有复杂的分支预测机制，因此必须通过执行每一个分支的方式完成分支控制。</p><p>warp对性能影响很大，因此我们必须尽可能避免warp分化。所依据的原理就是根据block中线程的warp分配是确定的，我们可以通过确保同一warp中的线程执行的分支相同，来避免warp分化。</p><p>举个简单的例子：<br><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/202205181622724.png" alt="image-20220518162230655"></p><p>上面这个例子就将控制分支的分支粒度由1变为wrap大小</p><h4 id="3-2-3-资源分配"><a href="#3-2-3-资源分配" class="headerlink" title="3.2.3 资源分配"></a>3.2.3 资源分配</h4><p>warp的本地执行上下文有以下资源组成</p><ul><li>程序计数器</li><li>寄存器</li><li>共享内存</li></ul><p>SM处理的每个warp的执行上下文在其声明周期内是保存在硬件上的，上下文切换没有损失，但这也导致了每个SM可处理的warp是有限的，warp线程消耗寄存器越多，SM可处理的warp就越少，一个block消耗的共享内存越多，SM中可以被同时处理的线程块就越少。</p><p>warp分为三种类型：</p><ul><li>选定的warp：正在执行的warp是选定的</li><li>阻塞的warp：没有做好准备执行</li><li>符合条件的warp：准备执行但尚未执行</li></ul><h4 id="3-2-4-隐藏延迟"><a href="#3-2-4-隐藏延迟" class="headerlink" title="3.2.4 隐藏延迟"></a>3.2.4 隐藏延迟</h4><p>指令延迟：在指令发出和完成之间的时钟周期被定义为指令延迟</p><p>当每个时钟周期中所有的线程调度器都有一个符合条件的warp时，可以达到计算资源的完全利用。</p><p>延迟隐藏不是让计算单元的延迟消失，而是让warp调度器不受指令延迟影响，GPU的指令延迟被其他warp的计算隐藏。</p><blockquote><p>利特尔原则：所需warp数&#x3D;延迟*吞吐量</p></blockquote><p>例如：内核中一条指令的平均延迟是5个周期。为了在每个周期内执行6个warp的吞吐量，则至少需要30个未完成的warp。</p><h4 id="3-2-5-占有率"><a href="#3-2-5-占有率" class="headerlink" title="3.2.5 占有率"></a>3.2.5 占有率</h4><p>占有率：每个SM中活跃的warp数占最大warp数量的比值</p><blockquote><p>占有率&#x3D;活跃线程束数量&#x2F;最大线程束数量</p></blockquote><p>最大线程束数量由硬件决定，比如3090就是48</p><p>block和grid大小的准则：</p><ul><li>每个block中线程数量是warp大小的倍数</li><li>避免block太小，至少为128或者256</li><li>block的数量要远远大于SM的数量，从而保证足够的并行性</li></ul><h4 id="3-2-6-同步"><a href="#3-2-6-同步" class="headerlink" title="3.2.6 同步"></a>3.2.6 同步</h4><p>系统级同步：<code>cudaDeviceSynchronize()</code></p><p>block级同步：<code>__device__ void syncthread(void)</code></p><p>这个函数会使同一block中的线程都达到这个同步点再继续执行。由于强制线程空闲，对性能有不利影响。</p><p>需要同步的情况：</p><p>block内的线程需要同步，当使用共享内存时，可能会出现race condition，这时利用同步需要规定好读写顺序。</p><p>block间线程同步没有办法，只能通过<code>cudaDeviceSynchronize()</code>进行block同步。</p><h4 id="3-2-7可拓展性"><a href="#3-2-7可拓展性" class="headerlink" title="3.2.7可拓展性"></a>3.2.7可拓展性</h4><p>简单的来说，可拓展性就是指当增加计算单元时性能也可以跟着提升。</p><p>CUDA内核启动时，block分布在多个SM中，block可以并行或连续或任意的顺序执行，这种独立性使CUDA程序在任意数量的计算核心间可以拓展</p><h3 id="3-3-并行性的表现"><a href="#3-3-并行性的表现" class="headerlink" title="3.3 并行性的表现"></a>3.3 并行性的表现</h3><p>减少block的维数增加block的个数会增加并行性</p><p>block的x维应该是warp大小的倍数</p><p>并行性、占有率、内存吞吐量等指标都不能单独决定性能</p><h3 id="3-4-避免分支分化"><a href="#3-4-避免分支分化" class="headerlink" title="3.4 避免分支分化"></a>3.4 避免分支分化</h3><p>避免分支分化的原理就是3.2.2里讲的尽量使同一个warp中的线程执行相同的控制分支。本节以规约问题为例介绍怎么避免分支分化。</p><p>reduction问题是经典的并行计算问题，基本思想如下：</p><p>问题描述：</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/202205182120120.png" alt="image-20220518212033862"></p><p>若要使用并行算法来完成，可以通过相邻配对和交错配对的方式来完成。</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/202205182121561.png" alt="image-20220518212110518"></p><p>在GPU中实现并行规约算法，由于线程块间不能同步，所有在block中并行规约结果后需要在host串行将结果相加起来。</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/202205182124093.png" alt="image-20220518212414053"></p><p>并行核函数：</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/202205182124836.png" alt="image-20220518212315476"></p><p>原理图：</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/202205182128072.png" alt="image-20220518212804029"></p><p>main函数：</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/202205182124313.png" alt="image-20220518212456238"><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/202205182125652.png" alt="image-20220518212559453"></p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/202205182126634.png" alt="image-20220518212624578"></p><p>这是相邻配对的方式，每个warp中有一半的线程会分支分化，我们对此进行优化。</p><p>将其改为</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/202205182128838.png" alt="image-20220518212822772"></p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/202205182128639.png" alt="image-20220518212815599"></p><p>相比于第一种规约，只有前面一半\四分之一\八分之一\。。。的线程进行计算，因此避免了warp分化。</p><p>再将其改为交错配对</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/202205182130565.png" alt="image-20220518213022510"></p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/202205182130036.png" alt="image-20220518213008996"></p><p>三种核函数性能对比：</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/202205182131797.png" alt="image-20220518213108748"></p><p>发现第三个比第一个快了1.69倍，比第二个快了1.34倍，与第二个相比，性能提升的原因是reduceInterleaved函数里的全局内存加载&#x2F;存储模式导致的，在第4章里会介绍更多有关于全局内存加载&#x2F;存储模式对内核性能的影响。</p><h3 id="3-5展开循环"><a href="#3-5展开循环" class="headerlink" title="3.5展开循环"></a>3.5展开循环</h3><p>在CUDA中，循环展开的意义重大，通过减少指令消耗和增加更多的独立调度指令来提高性能。因此，更多的并发操作被添加到流水线上，以产生更高的指令和内存带宽。这为线程束调度器提供更多符合条件的线程束，它们可以帮助隐藏指令或内存延迟。</p><h4 id="3-5-1-展开规约"><a href="#3-5-1-展开规约" class="headerlink" title="3.5.1 展开规约"></a>3.5.1 展开规约</h4><p>在第四节的规约中，每个线程对应一个数据，每个block对应一个数据块。现在每个block展开两个数据块的处理（问题是原来不是并行的吗，这相当于循环吗？展开循环避免了许多指令和减少了计数，这里也会较少许多指令）</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/202205182222466.png" alt="image-20220518222209394"></p><p>这条语句将每个block添加了相邻block的元素</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/202205182222195.png" alt="image-20220518222252160"></p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/202205182222172.png" alt="image-20220518222258133"></p><p>速度快了3.42倍，再进一步展开，将其展开为4、8个数据块</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/202205182224666.png" alt="image-20220518222401610"></p><h4 id="3-5-2-展开线程的规约"><a href="#3-5-2-展开线程的规约" class="headerlink" title="3.5.2 展开线程的规约"></a>3.5.2 展开线程的规约</h4><p>在循环处理数据时，活跃线程数不断减半，当活跃线程减为32，就不会再较少了，这部分可以从循环中展开。</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/202205182240301.png" alt="image-20220518224027128"></p><p>注意临时指针是<code>volatile</code>修饰的，它告诉百年一起每次赋值时需要将vmem的值存回全局内存，并且从全局内存读取，保证编译器不会对全局或共享内存优化读写。(为什么这个要，但是前面却不需要？？)</p><p>修改后的核函数如下</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/202205182242710.png" alt="image-20220518224216370"></p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/202205182242292.png" alt="image-20220518224236152"></p><h4 id="3-5-3-完全展开的规约"><a href="#3-5-3-完全展开的规约" class="headerlink" title="3.5.3 完全展开的规约"></a>3.5.3 完全展开的规约</h4><p>如果编译时已知一个循环中的迭代次数，就可以把循环完全展开。因为在Fermi或Kepler架构中，每个块的最大线程数都是1 024（参见表3-2），并且在这些归约核函数中循环迭代次数是基于一个线程块维度的，所以完全展开归约循环是可能的：</p><p><img src="http://yqfile.alicdn.com/61015742618a0b0f05fc456eafa79ea9f282aafc.png" alt="image"><img src="http://yqfile.alicdn.com/dcef9f7fcce98689c2d9495e413db4fd48bab20e.png" alt="image"></p><p>内核时间再次有了小小的改善，它的执行比reduceUnrollWarps8快1.06倍，比原来的实现快9.16倍</p><h4 id="3-5-4-模板函数的规约"><a href="#3-5-4-模板函数的规约" class="headerlink" title="3.5.4 模板函数的规约"></a>3.5.4 模板函数的规约</h4><p>虽然可以手动展开循环，但是使用模板函数有助于进一步减少分支消耗。在设备函数上CUDA支持模板参数。如下所示，可以指定块的大小作为模板函数的参数：</p><p><img src="http://yqfile.alicdn.com/b04bafe536f62138b5f874702357c24562f95cd3.png" alt="image"></p><p><img src="http://yqfile.alicdn.com/577f44b00ae2b3d7a3bd0c8ba2633e16a6ee8d3e.png" alt="image"></p><p>相比reduceCompleteUnrollWarps8，唯一的区别是使用了模板参数替换了块大小。检查块大小的if语句将在编译时被评估，如果这一条件为false，那么编译时它将会被删除，使得内循环更有效率。</p><p>该核函数一定要在switch-case结构中被调用。这允许编译器为特定的线程块大小自动优化代码，但这也意味着它只对在特定块大小下启动reduceCompleteUnroll有效：</p><p><img src="http://yqfile.alicdn.com/ff0dc123aed9aaa80f363477410249f688f0938b.png" alt="image"></p><h4 id="3-5-4-总结"><a href="#3-5-4-总结" class="headerlink" title="3.5.4 总结"></a>3.5.4 总结</h4><p><img src="http://yqfile.alicdn.com/a3bb1472646950be61ce127dfcce08b8488ba3cd.png" alt="image"></p><p>注意，最大的相对性能增益是通过reduceUnrolling8核函数获得的，在这个函数之中每个线程在归约前处理8个数据块。有了8个独立的内存访问，可以更好地让内存带宽饱和及隐藏加载&#x2F;存储延迟。可以使用以下命令检测内存加载&#x2F;存储效率指标：<br><img src="http://yqfile.alicdn.com/7824d9203313bd3743eb550188da9b3d309ac2d4.png" alt="image"></p><p>表3-6总结了所有核函数的结果。在第4章，将会更加详细地介绍全局内存访问，并且会对内存访问如何影响内核性能有更深的了解。</p><p><img src="http://yqfile.alicdn.com/39c130a3209c05a7b29e31a99b197754cf05eb7e.png" alt="image"></p><p>问题回到了隐藏延迟：为什么在warp中大量独立的内存操作可以隐藏延迟？？</p><h3 id="3-6-动态并行"><a href="#3-6-动态并行" class="headerlink" title="3.6 动态并行"></a>3.6 动态并行</h3><p>GPU动态并行允许在GPU端直接创建和同步新的GPU内核，有以下几点优点：</p><ul><li>动态并行提供了一个更有层次结构的方法，在这个方法中，并发性可以在kernel中的多个级别表现出来。</li><li>有了动态并行，可以推迟到运行时决定需要在GPU上创建多少个block和grid，可以动态的利用GPU硬件调度器和加载平衡器，并进行调整以适应数据驱动或工作负载</li><li>在GPU端创建kernel减少了host和device之间的控制和数据传输。</li></ul><p>本节以动态并行实现递归规约为例介绍动态并行。</p><h4 id="3-6-1-嵌套执行"><a href="#3-6-1-嵌套执行" class="headerlink" title="3.6.1 嵌套执行"></a>3.6.1 嵌套执行</h4><ul><li>避免大量嵌套有利于提升性能。</li><li>同步对性能和正确性至关重要，但是减少block内部的同步次数会使嵌套内核的效率更高。</li><li>在每一个嵌套层上设备运行时都要保存额外的内存，所以内核嵌套的最大数量可能是受限制的。</li></ul><h2 id="四、全局内存"><a href="#四、全局内存" class="headerlink" title="四、全局内存"></a>四、全局内存</h2><h3 id="4-1-CUDA内存模型概述"><a href="#4-1-CUDA内存模型概述" class="headerlink" title="4.1 CUDA内存模型概述"></a>4.1 CUDA内存模型概述</h3><p>对于程序员来说，有两种类型存储器：可编程与不可编程</p><p>不可编程：一级缓存和二级缓存</p><p>可编程：</p><ul><li>寄存器</li><li>本地内存</li><li>共享内存</li><li>全局内存</li><li>常量内存</li><li>纹理内存</li></ul><p>每个kernel中的每个线程都有自己的寄存器和本地内存，block内线程共享共享内存，device中的所有线程都可访问全局内存，所有线程都可访问只读的常量内存和纹理内存。</p><h4 id="4-1-1-寄存器"><a href="#4-1-1-寄存器" class="headerlink" title="4.1.1 寄存器"></a>4.1.1 寄存器</h4><p>寄存器式GPU上最快的存储器，kernel中没有其他修饰符修饰的变量通常存在寄存器中，kernel声明的数组中，</p><p>如果引用该数组的索引是常量且能够在编译时确定，那么该数组也存储在寄存器中。</p><p>寄存器变量对线程私有，声明周期与kernel的声明周期相同。</p><p>若kernel使用了超过硬件限制数量的寄存器，则会用本地内存代替多占用的寄存器。这种寄存器溢出会对性能带来不利影响。</p><p>我们可以显式的为kernel加上额外信息来帮助编译器优化。</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/202205201731997.png" alt="image-20220520173121694"></p><p>限制了每个SM最大block和每个block最多线程</p><h4 id="4-1-2-本地内存"><a href="#4-1-2-本地内存" class="headerlink" title="4.1.2 本地内存"></a>4.1.2 本地内存</h4><p>除了寄存器溢出的变量会存储在寄存器上，编译器可能存放在本地内存中的变量有：</p><ul><li>在编译时使用未知索引引用的本地数组</li><li>可能会占用大量寄存器空间的较大本地结构体或数组</li><li>其他不满足kernel寄存器限定条件的变量</li></ul><p>需要注意的是，本地内存本质上与全局内存在同一块存储区域，因此高延迟，低带宽。</p><h4 id="4-1-3-共享内存"><a href="#4-1-3-共享内存" class="headerlink" title="4.1.3 共享内存"></a>4.1.3 共享内存</h4><p>当用<code>__shared__</code>修饰的变量存放在共享内存中。</p><p>相比本地内存和全局内存，具有更高的带宽和更低的延迟</p><p>共享内存被block内线程共享，因此要注意同步问题，使用<code>__syncthreads</code>进行同步。</p><p>SM中的一级缓存和共享内存都使用64KB的片上内存，是静态划分的，但是可以在运行时动态配置</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/202205201744956.png" alt="image-20220520174447847"></p><h4 id="4-1-4-常量内存"><a href="#4-1-4-常量内存" class="headerlink" title="4.1.4 常量内存"></a>4.1.4 常量内存</h4><p>常量变量用<code>__constant__</code>修饰，必须在全局空间内和所有核函数外进行声明。其必须通过下面函数进行初始化。</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/202205201747807.png" alt="image-20220520174742618"></p><p>大多数情况下这个函数是隐式同步的</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/202205201748556.png" alt="image-20220520174817425"></p><h4 id="4-1-5-纹理内存"><a href="#4-1-5-纹理内存" class="headerlink" title="4.1.5 纹理内存"></a>4.1.5 纹理内存</h4><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/202205201749544.png" alt="image-20220520174911292"></p><h4 id="4-1-6-全局内存"><a href="#4-1-6-全局内存" class="headerlink" title="4.1.6 全局内存"></a>4.1.6 全局内存</h4><p>全局内存可以被静态或动态分配，静态通过<code>__device__</code>来分配内存，动态通过<code>cudaMalloc()</code>和<code>cudaFree()</code>来分配和释放全局内存。</p><p>访问全局内存也要注意同步问题，多个线程并发的修改内存的同一位置会导致未定义程序行为。</p><p>内存对齐：全局内存常驻于device内存中，可以通过32字节、64字节128字节的内存事务进行访问，这些内存事务必须自然对齐，也就是说首地址必须是32字节，64字节或128字节的倍数。</p><h4 id="4-1-7-GPU缓存"><a href="#4-1-7-GPU缓存" class="headerlink" title="4.1.7 GPU缓存"></a>4.1.7 GPU缓存</h4><p>GPU cache是不可编程的，在GPU上有四种缓存：</p><ul><li>一级缓存</li><li>二级缓存</li><li>只读常量缓存</li><li>只读纹理缓存</li></ul><p>每个SM有一个一级缓存，所有的SM共享一个二级缓存，一级缓存和二级缓存都能够用来存储本地内存和全局内存中的数据，包括寄存器溢出的部分。每个SM有一个只读常量缓存和只读纹理缓存。</p><p>L1cache和局部内存是同一块存储区域。L2cache被所有SM共享但是其速度要快于全局内存</p><p>在GPU中，只有内存加载操作可以被缓存，内存存储操作不能被缓存</p><h4 id="4-1-8-CUDA变量声明总结"><a href="#4-1-8-CUDA变量声明总结" class="headerlink" title="4.1.8 CUDA变量声明总结"></a>4.1.8 CUDA变量声明总结</h4><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/202205201951702.png" alt="image-20220520195107399"></p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/202205202005695.png" alt="image-20220520200502424"></p><h4 id="4-1-9-静态全局内存"><a href="#4-1-9-静态全局内存" class="headerlink" title="4.1.9 静态全局内存"></a>4.1.9 静态全局内存</h4><p>4.1.6说到可以通过<code>__device__</code>声明静态全局内存，关于静态全局内存的使用有几点需要注意的</p><p>通过<code>__device__</code>声明的变量只是一个符号，不能通过这个变量访问GPU中的全局内存变量。即使在同一文件中可见，主机代码也不能访问设备变量，设备代码也不能访问主机变量。</p><p>要想访问GPU的全局内存变量，应该通过<code>cudaMemcpyToSambol()</code>和<code>cudaMemcpyFromSambol()</code>访问。</p><p>另外还可以<code>cudaGetSymbolAddress()</code>获得全局变量的统一虚拟地址（UAV），注意不能用<code>&amp;</code>符号获取地址。</p><h3 id="4-2-内存管理"><a href="#4-2-内存管理" class="headerlink" title="4.2 内存管理"></a>4.2 内存管理</h3><p>尽可能减少主机与设备之间的传输</p><h4 id="4-2-3-固定内存"><a href="#4-2-3-固定内存" class="headerlink" title="4.2.3 固定内存"></a>4.2.3 固定内存</h4><p>因为虚拟内存的原因，在host端分配的内存是可分页的（pageable），可能在虚拟内存中，当GPU要访问主机端的数据时就可能发生page fault需要页面置换，从而降低效率。</p><p>我们可以使用<code>cudaMallocHost()</code>函数来分配host内存，这样这些内存的页面是锁定的即不会被置入swap区，从而提高了读写带宽。通过<code>cudaFreeHost()</code>来释放主机内存。</p><blockquote><p><strong>主机与设备间的内存传输</strong></p><ul><li>与分页内存相比，固定内存分配和释放成本更高，但是它为大规模数据传输提供了更高的传输吞吐量</li><li>将许多小的传输批处理为一个更大的传输能提高性能，因为它减少了单位传输消耗</li><li>主机与设备之间的数据传输有时可以与内核执行重叠。第六章会详细讲解</li><li>应当尽量减少或重叠主机与设备间的数据传输</li></ul></blockquote><h4 id="4-2-4-零拷贝内存"><a href="#4-2-4-零拷贝内存" class="headerlink" title="4.2.4 零拷贝内存"></a>4.2.4 零拷贝内存</h4><p>之前讲过host不能直接访问device变量，device不能直接访问host变量，但是有一个例外：即零拷贝内存（zero copy mem）</p><p>零拷贝内存的优势：</p><ul><li>当设备内存不足时可以使用主机内存</li><li>避免主机与设备之间的显示传输（使用零拷贝内存则会自动隐式传输）</li><li>提高PCLe的传输率</li></ul><p>使用<code>cudaHostAlloc()</code>来给零拷贝内存分配空间</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/202205231844941.png" alt="image-20220523184456852"></p><p>flag有四种：<br><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/202205231845892.png" alt="image-20220523184544847"></p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/202205231846105.png" alt="image-20220523184601042"></p><p>可以使用<code>cudaHostGetDevicePointer()</code>函数获取设备端的指针</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/202205231848437.png" alt="image-20220523184856391"></p><p>总结一下，零拷贝内存就是将显示的内存传输改为隐式，减少了编程者的工作量，对于少量数据来说零拷贝内存是一个不错的选择，但是对于由PCLe总线连接的离散GPU上的更大数据集来说，零拷贝内存不是一个好选择，它会导致性能显著下降。</p><blockquote><p>有两种常见的异构计算架构：集成架构和离散架构（集成显卡和独立显卡）</p><p>在集成架构中，CPU和GPU集成在一个芯片上，并在物理地址上共享内存。在这种架构中，由于无需再PCLe总线上备份，所以零拷贝内存在性能上和可编程性方面可能更佳。</p><p>对于通过PCLe总线连接的离散系统而言，零拷贝内存只在特殊情况下有优势。</p><p>另外特写需要注意的，零拷贝内存被device和host共享，要注意同步问题。</p></blockquote><h4 id="4-2-5-统一虚拟寻址"><a href="#4-2-5-统一虚拟寻址" class="headerlink" title="4.2.5 统一虚拟寻址"></a>4.2.5 统一虚拟寻址</h4><p>统一虚拟寻址（UVA）指主机内存和设备内存共享同一个内存空间</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/202205231856774.png" alt="image-20220523185643679"></p><p>UVA可以在零拷贝内存的基础上更进一步解放程序员，使用零拷贝内存时还需要创建host指针和device指针两个指针，有UVA后不需要两个指针，只需要一个指针就可以被host和device访问。</p><p>对比零拷贝内存的代码和UVA的代码</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/202205231900361.png" alt="image-20220523190028273"></p><p>有了UVA可以直接将指针传给核函数</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/202205231901126.png" alt="image-20220523190120067"></p><h4 id="4-2-6-统一内存寻址"><a href="#4-2-6-统一内存寻址" class="headerlink" title="4.2.6 统一内存寻址"></a>4.2.6 统一内存寻址</h4><p>在CUDA 6.0引入统一内存寻址,进一步简化了内存管理。其原理为创建了一个托管内存池，内存池已分配的空间可以用相同的内存地址在CPU和GPU上进行访问。</p><p>统一内存寻址和UVA不同，UVA只是创建了统一的虚拟内存空间，但是不会自动将数据从一个物理位置转移到另一个物理位置。它应用都是在主机端分配内存，会受到PCLe传输的影响，核函数延迟高。而统一内存寻址将内存和执行空间分离，因此可以根据需要将数据透明的传输到主机或设备上，以提高局部性和性能。</p><p>可以通过<code>__managed__</code>来静态声明一个托管变量，但是只能在文件范围和全局范围内进行</p><p>或者通过<code>cudaMallocManaged()</code>来动态分配托管内存。</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/202205231913341.png" alt="image-20220523191354292"></p><h3 id="4-3-内存访问模式"><a href="#4-3-内存访问模式" class="headerlink" title="4.3 内存访问模式"></a>4.3 内存访问模式</h3><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/202205231952392.png" alt="image-20220523195216276"></p><p>核函数的内存请求是在DRAM(片外全局内存)和片上内存间以128字节或32字节的内存事务实现的。</p><p>一级缓存的缓存行是128字节。二级缓存的缓存行是32字节。可以在编译时选择是否开启一级缓存，默认开启,通过<code>-Xptxas -dlcm-cg</code>关闭缓存，<code>-Xptxas -dlcm-ca</code>开启。</p><h4 id="4-3-1-对齐和合并访问"><a href="#4-3-1-对齐和合并访问" class="headerlink" title="4.3.1 对齐和合并访问"></a>4.3.1 对齐和合并访问</h4><p>从全局内存读取数据有两个特性：对齐访问，全局访问</p><p>对齐访问指从内存读取到缓存时，必须从缓存行大小的整数倍地址开始读，比如一级缓存，每次读取的地址必须是128的倍数。</p><p>合并访问：CUDA模型的显著特征之一是指令必须以warp为单位进行发表和执行，存储也是一样。当warp的32个线程访问一个连续的内存块时，就会出现合并内存访问。</p><p>如何优化内存事务效率：用最少的事务请求满足最多的内存请求，即尽可能的减少访存次数。</p><h4 id="4-3-2-全局内存读取"><a href="#4-3-2-全局内存读取" class="headerlink" title="4.3.2 全局内存读取"></a>4.3.2 全局内存读取</h4><p>启用一级缓存的内存加载以128字节粒度进行加载，不启用则以32字节进行加载。在未对其的情况下，不启用缓存会使加载效率得到提升，因为一次加载的字节数较少，无用的数据部分会减少。但是缓存可以减少重复加载。</p><blockquote><p>CPU与GPU一级缓存的区别：</p><p>CPU一级缓存优化了时间和空间局部性，GPU专为空间局部性设计，频繁访问一个一级缓存的内存位置不会增加数据留在缓存中的概率。</p></blockquote><h4 id="4-3-3-全局内存存储"><a href="#4-3-3-全局内存存储" class="headerlink" title="4.3.3 全局内存存储"></a>4.3.3 全局内存存储</h4><p>内存写入只通过二级缓存，在32字节的粒度上被执行。内存事务可以同时被分为一段、两段和四段、</p><p>对齐存储效率显著高于非对齐存储。</p><h4 id="4-3-4-结构体数组和数组结构体"><a href="#4-3-4-结构体数组和数组结构体" class="headerlink" title="4.3.4 结构体数组和数组结构体"></a>4.3.4 结构体数组和数组结构体</h4><p>结构体数组（SoA）数组结构体（AoS）是两种常见的数据组织方式，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">innerStruct</span>&#123;</span></span><br><span class="line">  <span class="type">float</span> x;</span><br><span class="line">  <span class="type">float</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">innerStruct</span> <span class="title">myAos</span>[<span class="title">n</span>]</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">innerArray</span>&#123;</span></span><br><span class="line"><span class="type">float</span> x[n];</span><br><span class="line">  <span class="type">float</span> y[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两种方式在内存中的结构如图所示：</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/202205232043815.png" alt="image-20220523204321745"></p><p>使用SOA模式可以充分利用GPU的内存带宽，由于相同字段元素相邻存储，不仅可以合并内存访问，还可以对全局内存实现更高效的利用。</p><blockquote><p>许多并行编程范式，尤其是SIMD类型范式更倾向于SOA，CUDA也倾向于使用SOA。</p></blockquote><h4 id="4-3-5-性能调整"><a href="#4-3-5-性能调整" class="headerlink" title="4.3.5 性能调整"></a>4.3.5 性能调整</h4><p><strong>展开技术</strong></p><p>在第三章已经讲过，增加每个线程执行独立内存操作的数量可以提高性能。</p><p>对于IO密集型的核函数，内存访问并行有很高的优先级。</p><p><strong>增大并行性</strong></p><p>增大并行性主要通过修改核函数的配置实现，通过减少block内线程数，增加block的数量来增大并行性。但是block中线程的数量也不能太少，原因如下：</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/202205232204078.png" alt="image-20220523220455984"></p><blockquote><p>最大化带宽利用率</p><p>总结下要最大化贷款的利用率要从两个角度出发<br>一是提高DRAM和SM片上内存的有效内存的移动，避免浪费。并且要保证内存访问应当是对齐和合并的<br>二是提高并发内存操作，主要途径有（1）展开（2）修改核函数启动配置来提高并行性</p></blockquote><h3 id="4-4-核函数可达到的带宽"><a href="#4-4-核函数可达到的带宽" class="headerlink" title="4.4 核函数可达到的带宽"></a>4.4 核函数可达到的带宽</h3><h4 id="4-4-1-理论带宽与有效带宽"><a href="#4-4-1-理论带宽与有效带宽" class="headerlink" title="4.4.1 理论带宽与有效带宽"></a>4.4.1 理论带宽与有效带宽</h4><p>理论带宽：当前硬件可实现的绝对最大带宽<br>有效带宽：（读字节数+写字节数）*  10<sup>-9</sup>&#x2F;运行时间</p><h4 id="4-4-2-矩阵转置问题"><a href="#4-4-2-矩阵转置问题" class="headerlink" title="4.4.2 矩阵转置问题"></a>4.4.2 矩阵转置问题</h4><p>简单的矩阵转置代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">transposeHost</span><span class="params">(<span class="type">float</span> *out, <span class="type">float</span> *in, <span class="type">const</span> <span class="type">int</span> nx, <span class="type">const</span> <span class="type">int</span> ny)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> iy = <span class="number">0</span>; iy &lt; ny; ++iy) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> ix = <span class="number">0</span>; ix &lt; nx; ++ix) &#123;</span><br><span class="line">out[ix*ny+iy] = in[iy*nx+ix];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>矩阵转置有两种基本方法：行读取列存储，列读取行存储，其中行操作都是合并存储的，列操作都是交叉存储的。</p><p>如果禁用一级缓存，这两种方法结果相同，但是如果启用一级缓存，列读取行存储的有效带宽更高，因为读取时虽然是交叉读取，但是因为有缓存可以减少访存；但是行读取列存储时由于存储不经过一级缓存，所以缓存对其没有意义。</p><p><strong>展开转置</strong></p><p>将转置操作展开能获得更高的带宽</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">__global__ <span class="type">void</span> <span class="title function_">transposeUnroll4Col</span><span class="params">(<span class="type">float</span> *out, <span class="type">float</span> *in, <span class="type">const</span> <span class="type">int</span> nx,</span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="type">int</span> ny)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> ix = blockDim.x * blockIdx.x*<span class="number">4</span> + threadIdx.x;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> iy = blockDim.y * blockIdx.y + threadIdx.y;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> ti = iy*nx + ix; <span class="comment">// access in rows</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> to = ix*ny + iy; <span class="comment">// access in columns</span></span><br><span class="line">  <span class="keyword">if</span> (ix+<span class="number">3</span>*blockDim.x &lt; nx &amp;&amp; iy &lt; ny) &#123;</span><br><span class="line">    out[ti] = in[to];</span><br><span class="line">    out[ti + blockDim.x] = in[to+ blockDim.x*ny];</span><br><span class="line">    out[ti + <span class="number">2</span>*blockDim.x] = in[to+ <span class="number">2</span>*blockDim.x*ny];</span><br><span class="line">    out[ti + <span class="number">3</span>*blockDim.x] = in[to+ <span class="number">3</span>*blockDim.x*ny];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>对角转置</strong></p><p><strong>使用瘦块（thin block）增加并行性</strong></p><h2 id="五、共享和常量内存"><a href="#五、共享和常量内存" class="headerlink" title="五、共享和常量内存"></a>五、共享和常量内存</h2><h3 id="5-1-CUDA共享内存概述"><a href="#5-1-CUDA共享内存概述" class="headerlink" title="5.1 CUDA共享内存概述"></a>5.1 CUDA共享内存概述</h3><h4 id="5-1-1-共享内存"><a href="#5-1-1-共享内存" class="headerlink" title="5.1.1 共享内存"></a>5.1.1 共享内存</h4><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/202205251442449.png" alt="image-20220525144256333"></p><p>共享内存（SMEM）与一级缓存在片上，相比于全局内存，其延迟低20-30倍，带宽高大约10倍。</p><p>共享内存被block内的线程共享，当warp读取共享内存时，理想情况下每个请求应该在一个事务中完成，在最坏情况下，一个请求在32个事务中顺序执行。因此要避免多次共享内存请求。当多个线程访问共享内存中的同一个字，一个线程读取该字后，通过多播把他发送给其他线程。</p><p>共享内存被SM所以常驻线程共享，所以共享内存是限制设备并行性的关键资源。一个核函数使用的共享内存越多，处于并发活跃状态的线程块就越少。</p><blockquote><p><strong>可编程管理的缓存</strong></p><p>在编写CPU程序时，缓存对于程序是透明的，我们不能直接操纵缓存，只能通过循环转换等方法优化缓存。循环转换是一种常用的缓存优化方法，通过重新安排迭代顺序，提高缓存的局部性。</p><p>而共享内存是可编程管理的缓存，我们可以通过在数据布局上提供更多细粒度控制和改善片上数据的移动，使得应用程序代码优化变得简单。</p></blockquote><h4 id="5-1-2-共享内存分配"><a href="#5-1-2-共享内存分配" class="headerlink" title="5.1.2 共享内存分配"></a>5.1.2 共享内存分配</h4><p>共享内存可以动态或静态分配，其作用域可以分配为全局或局部。</p><p>通过<code>__shared__</code>修饰符声明变量为静态分配共享变量，如果在核函数内进行声明则是局部变量，如果在核函数外进行声明即为全局变量。</p><p>例如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__shared__ <span class="type">float</span> tile[size_y][size_x];</span><br></pre></td></tr></table></figure><p>若共享内存大小在编译时未知，可以动态声明，使用<code>extern</code>关键字声明未知大小的数组，在核函数调用时，将所需的字节数作为三重括号内的第三个参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> __shared__ <span class="type">int</span> tile[];</span><br><span class="line">kernel&lt;&lt;&lt;grid,block,isize* <span class="title function_">sizeof</span><span class="params">(<span class="type">int</span>)</span>&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>注意：只能动态声明一维数组！</p><h4 id="5-1-3-共享内存存储体-bank-和访问模式"><a href="#5-1-3-共享内存存储体-bank-和访问模式" class="headerlink" title="5.1.3 共享内存存储体(bank)和访问模式"></a>5.1.3 共享内存存储体(bank)和访问模式</h4><p><strong>存储体（bank）</strong></p><p>为了获得高内存带宽，共享内存被分为32个同样大小的内存模型,它们被称为存储体，它们可以被同时访问。有32个存储体是因为在一个线程束中有32个线程。共享内存是一个一维地址空间。根据GPU的计算能力，共享内存的地址在不同模式下会映射到不同的存储体中(稍后详述)。如果通过线程束发布共享内存加载或存储操作，且在每个存储体上只访问不多于一个的内存地址，那么该操作可由一个内存事务来完成。否则，该操作由多个内存事务来完成，这样就降低了内存带宽的利用率。</p><p><strong>存储体冲突(bank conflict)</strong></p><p>在共享内存中当多个地址请求落在相同的内存存储体中时，就会发生存储体冲突，这会导致请求被重复执行。</p><p>当线程束发出共享内存请求时,有以下3种典型的模式:</p><ul><li><p>并行访问:多个地址访问多个存储体</p></li><li><p>串行访问:多个地址访问同一个存储体</p></li><li><p>广播访问:单一地址读取单一存储体</p></li></ul><p>并行访问是最常见的模式，它是被一个线程束访问的多个地址落在多个存储体中。这种模式意味着，如果不是所有的地址，那么至少有一些地址可以在一个单一的内存事务中被服务。最佳情况是，当每个地址都位于一个单独的存储体中时，执行无冲突的共享内存访问。串行访问是最坏的模式，当多个地址属于同一个存储体时，必须以串行的方式进行请求。如果线程束中32个线程全都访问同一存储体中不同的内存地址，那么将需要32个内存事务，并且满足这些访问所消耗的时间是单一请求的32倍。<br>在广播访问的情况下，线程束中所有的线程都读取同一存储体中相同的地址。若一个内存事务被执行，那么被访问的字就会被广播到所有请求的线程中。虽然一个单一的内存事务只需要一个广播访问，但是因为只有一小部分字节被读取，所以带宽利用率很差。</p><p>若每个线程访问一个存储体，这是最优的并行访问模式，若多个线程访问一个存储体，有两种可能的情况：</p><ul><li>如果线程访问同一个存储体中相同的地址，广播访问无冲突</li><li>如果线程访问同一个存储体中不同的地址，会发生存储体冲突</li></ul><p><strong>访问模式</strong></p><p>内存存储体的宽度（字长）随计算能力的不同而变化：计算能力2.x的为四字节，计算能力3.x的为8字节</p><p>字长为四字节的存储模式：</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/202205251628021.png" alt="image-20220525162857783"></p><p>字长为8字节的存储模式</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/202205251629548.png" alt="image-20220525162922453"></p><p><strong>内存填充</strong></p><p>内存填充是避免存储体冲突的一种方法，以下图为例，若bank0发生大量存储体冲突,可以通过填充字的方式来避免</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/202205251632600.png" alt="image-20220525163216480"></p><p>填充的内存不能用于数据存储，这样block中可用的共享内存会减少</p><h4 id="5-1-4-配置共享内存"><a href="#5-1-4-配置共享内存" class="headerlink" title="5.1.4 配置共享内存"></a>5.1.4 配置共享内存</h4><p>SM上的片上内存被共享内存和一级缓存共享。有两种配置方法：</p><ul><li>按设备进行配置</li><li>按核函数进行配置</li></ul><p>具体配置方法略去，不同计算能力的设备的片上内存不同，配置方法不同。</p><h4 id="5-1-5-同步"><a href="#5-1-5-同步" class="headerlink" title="5.1.5 同步"></a>5.1.5 同步</h4><p>共享内存的同步有两个基本方法</p><ul><li>障碍（barriers）</li><li>内存栅栏（memory fences）</li></ul><p><strong>弱排序内存模型</strong></p><p>CUDA采用弱排序内存模型，这意味着，内存访问不一定按照它们在程序中的顺序执行，为了显式的确定内存访问的顺序，必须通过barriers和memory fences来保证。</p><p><strong>显示障碍（barriers）</strong></p><p><code>void __syncthreads()</code>作为显示障碍保证当所有线程都到达该点时才能继续执行</p><p>需要注意的是在条件语句中调用<code>void __syncthreads()</code>，很可能块中的线程无法到达相同的障碍点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (threadID % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">__syncthreads();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">__syncthreads();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，前面已经说过block会以并行、串行的方式执行，这保证了CUDA是可拓展的，但这也会导致block间无法同步，若想实现block间的同步，可以在核函数中启动多个核函数并使用<code>__syncthreads()</code>进行同步。</p><p><strong>内存栅栏（memory fences）</strong></p><p>什么是内存栅栏（内存屏障，memory barriers）</p><p>在并行系统中，由于指令的乱序执行，实际的访存可能会和程序中的访存顺序不同，这就会导致程序不按照预想的形式执行，为了避免这种问题，引入内存栅栏，保证访存是按照程序中的顺序。</p><p>有三种范围的内存栅栏：block,grid,system</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __threadfence_block();</span><br></pre></td></tr></table></figure><p>保证栅栏前该线程对所有共享内存和全局内存的写操作对同一块中的其他线程是可见的，即保证其他线程都知道该线程执行了这些访存操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __threadfence();</span><br></pre></td></tr></table></figure><p>范围变为grid</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __threadfence_system();</span><br></pre></td></tr></table></figure><p>范围变为system，全部设备</p><p><strong>volatile</strong></p><p>volatile的作用与c语言中相同，可以防止编译器优化，保证volatile修饰的变量都将存到全局内存中，避免缓存在寄存器和本地内存中。</p><h3 id="5-2-共享内存的数据布局"><a href="#5-2-共享内存的数据布局" class="headerlink" title="5.2 共享内存的数据布局"></a>5.2 共享内存的数据布局</h3><p>介绍了方形和矩形两种常见的数据布局，以及其对应的矩阵转置算法，还有通过内存填充来避免存储体冲突。以行主序写列主序读在读的时候会出现存储体冲突，通过内存填充可以避免存储体冲突。</p><p>要区分在全局内存和共享内存矩阵转置的区别，全局内存要避免的是交叉访问尽量合并访问，共享内存要避免的是存储体冲突。</p><p>具体见原书代码吧，应当学会矩阵的转置以及内存填充。</p><h3 id="5-3-减少全局内存的使用"><a href="#5-3-减少全局内存的使用" class="headerlink" title="5.3 减少全局内存的使用"></a>5.3 减少全局内存的使用</h3><p>本节以第三章提到的规约函数为例，介绍如何使用共享内存作为可编程管理缓存以减少全局内存的使用。</p><p>通过将规约函数中的数据处理放到共享内存中，减少了全局内存的使用，提高了性能。具体应当查看原书代码，学会使用局部内存。</p><h3 id="5-4-合并的全局内存访问"><a href="#5-4-合并的全局内存访问" class="headerlink" title="5.4 合并的全局内存访问"></a>5.4 合并的全局内存访问</h3><h3 id="5-5-常量内存"><a href="#5-5-常量内存" class="headerlink" title="5.5 常量内存"></a>5.5 常量内存</h3><p>常量内存位于DRAM上，且有专门的片上缓存。常量内存主要有两种用途：</p><ul><li>只读数据</li><li>当线程束中线程访问相同位置时</li></ul><p>常量内存在设备端是只读的，在host是可读可写的</p><p>常量内存的访问模式不同于其他内存，当线程束中所有线程都访问相同的位置是，这个访问模式是最优的，当线程束访问不同的地址时，该访问就需要串行。</p><p>声明：通过<code>__constant__</code>声明</p><p>初始化：通过<code>cudaMemcpySymbol(const void *symbol,const void *src,size_t count,size_t offset,cudaMemcpyKind kind)</code>,kind可省略，省略就表示默认<code>cudaMemcpyHostDevice</code></p><p><strong>与只读内存的比较</strong></p><blockquote><p><strong>常量缓存与只读缓存</strong></p><p>在设备上只读缓存和常量缓存都是只读的</p><p>每个SM资源有限，只读缓存48KB，常量缓存64KB</p><p>常量缓存在统一读取中可以更好运行，只读缓存更适合分散读取</p></blockquote><p>声明与初始化（主机端）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">float</span> h_coef[] = &#123;a0, a1, a2, a3, a4&#125;;</span><br><span class="line">cudaMalloc((<span class="type">float</span>**)&amp;d_coef, (RADIUS + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="type">float</span>));</span><br><span class="line">cudaMemcpy(d_coef, h_coef, (RADIUS + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="type">float</span>), cudaMemcpyHostToDevice);</span><br></pre></td></tr></table></figure><p>设备端</p><p><code>__log()</code> 例如：<code>output[idx] += __ldg(&amp;input[idx])</code>强制使用只读缓存</p><h3 id="5-6-warp洗牌指令"><a href="#5-6-warp洗牌指令" class="headerlink" title="5.6 warp洗牌指令"></a>5.6 warp洗牌指令</h3><p>洗牌指令：只要两个线程在相同的线程束中，就允许这两个线程直接读取另一个线程的寄存器</p><p>首先必须要介绍束内线程（lane）的概念，每个warp中的束内线程有其独一无二的束内线程索引（laneID），每个warp有其线程束索引（warpID）<br>$$<br>laneID&#x3D;threadID.x%32\<br>warpID&#x3D;threadID.x&#x2F;32<br>$$</p><p>对于二维线程块可以将其转为一维线程索引再求laneID和warpID</p><h2 id="六、流与并发"><a href="#六、流与并发" class="headerlink" title="六、流与并发"></a>六、流与并发</h2><p>一般来说，在CUDA中有两种级别的并发：</p><ul><li>内核并发</li><li>网格并发</li></ul><p>本章主要介绍网格并发以及如何用NVVP将内核并发执行可视化</p><h3 id="6-1-流与事件"><a href="#6-1-流与事件" class="headerlink" title="6.1 流与事件"></a>6.1 流与事件</h3><p>CUDA流目的：实现网格级并发（如何实现并发：通过异步操作，异步了如何确定执行顺序：通过流来确定执行顺序）</p><p>定义：CUDA流是一系列异步的CUDA操作，这些操作按照主机代码确定的顺序在设备上执行。流能封装这些操作，保持操作的顺序，允许操作在流中排队，并使它们在先前的所有操作之后执行，并且可以查询排队操作的状态。</p><p>这些操作包括在主机与设备间进行数据传输，内核启动以及大多数由主机发起但由设备处理的其他命令。流中操作的执行相对于主机总是异步的。CUDA运行时决定何时可以在设备上执行操作。我们的任务是使用CUDA的API来确保一个异步操作在运行结果被使用之前可以完成。</p><p>如何实现网格级并发？：在同一个CUDA流中的操作有严格的执行顺序，而在不同CUDA流中的操作在执行顺序上不受限制。使用多个流同时启动多个内核，可以实现网格级并发。</p><p>实现网格级并发的优势？：在许多情况下，执行内核比传输数据耗时更多。在这些情况下，可以完全隐藏CPU和GPU 之间的通信延迟。通过将内核执行和数据传输调度到不同的流中，这些操作可以重叠,程序的总运行时间将被缩短。流在CUDA的API调用粒度上可实现流水线或双缓冲技术。</p><h4 id="6-1-1-CUDA流"><a href="#6-1-1-CUDA流" class="headerlink" title="6.1.1 CUDA流"></a>6.1.1 CUDA流</h4><p>流的两种类型：</p><ul><li>隐式声明的流（空流）</li><li>显式声明的流（非空流）</li></ul><p>如果没有显示指明流，那么数据传输和内核启动默认使用空流，前面几章的例子使用的都是空流。</p><p>接下来讲解如何创建销毁检查流：</p><p>声明：<code>cudaStream_t stream;</code></p><p>创建：<code>cudaStreamCreate(&amp;stream);  </code></p><p>销毁：<code>cudaError_t cudaStreamDestroy(cudaStream_t stream);</code></p><p>当<code>cudaStreamDestroy</code>函数调用时，若流中有未完成的工作，该函数将立即返回，若所有工作已经完成，与流相关的资源将被自动释放。</p><p>因为CUDA流操作是异步的，不知道什么时候结束，所以有相关函数来检查流中操作是否以及完成</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cudaError_t <span class="title function_">cudaStreamSynchronize</span><span class="params">(cudaStream_t stream)</span>;</span><br><span class="line">cudaError_t <span class="title function_">cudaStreamQuery</span><span class="params">(cudaStream_t stream)</span>;</span><br></pre></td></tr></table></figure><p><code>cudaStreamSynchronize</code>强制阻塞主机，直到在给定流中所有的操作都完成了。<code>cudaStreamQuery</code>会检查流中所有操作是否都已经完成，但在它们完成前不会阻塞主机。当所有操作都完成时<code>cudaStreamQuery</code>函数会返回<code>cudaSuccess</code>，当一个或多个操作仍在执行或等待执行时返回<code>cudaErrorNotReady</code>。</p><p>在之前的代码中，常见的数据传输和执行内核操作比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cudaMemcpy(..., cudaMemcpyHostToDevice);</span><br><span class="line">kernel&lt;&lt;&lt;grid, block&gt;&gt;&gt;(...);</span><br><span class="line">cudaMemcpy(..., cudaMemcpyDeviceToHost);</span><br></pre></td></tr></table></figure><p>在这个代码中，三个操作被发布到默认的流中，<code>cudaMemcpy()</code>主机同步等待数据传输完毕，在传输完成前，主机将强制空闲，内核启动是异步的，因此可以做到在内核启动后主机与设备的并行计算。</p><p>如果一直使用<code>cudaMemcpy() </code> 进行同步数据传输的话，主机端有无效的等待时间，也无法实现网格并行，可以通过<code>cudaMemcpyAsync()</code>来异步的数据传输，主机调用函数以后可以继续向前执行，由设备端继续执行，当然这样做必须三个函数的执行顺序必须按照发布顺序执行，因此需要通过显式的设置CUDA流来进行装载。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cudaError_t <span class="title function_">cudaMemcpyAsync</span><span class="params">(<span class="type">void</span>* dst, <span class="type">const</span> <span class="type">void</span>* src, <span class="type">size_t</span> count,cudaMemcpyKind kind, cudaStream_t stream = <span class="number">0</span>)</span>;</span><br></pre></td></tr></table></figure><p>将流作为第五个参数。</p><p>需要注意的是，执行异步数据传输时，必须使用固定主机分页</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cudaError_t <span class="title function_">cudaMallocHost</span><span class="params">(<span class="type">void</span> **ptr, <span class="type">size_t</span> size)</span>;</span><br><span class="line">cudaError_t <span class="title function_">cudaHostAlloc</span><span class="params">(<span class="type">void</span> **pHost, <span class="type">size_t</span> size, <span class="type">unsigned</span> <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure><p>在非默认流启动核函数，必须将流作为内核执行配置的第四个参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel_name&lt;&lt;&lt;grid, block, sharedMemSize, stream&gt;&gt;&gt;(argument <span class="built_in">list</span>)</span><br></pre></td></tr></table></figure><p>接下来在实例中看下非空流是如何实现网格并行的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nStreams; i++) &#123;</span><br><span class="line">  <span class="type">int</span> offset = i * bytesPerStream;</span><br><span class="line">  cudaMemcpyAsync(&amp;d_a[offset], &amp;a[offset], bytePerStream, streams[i]);</span><br><span class="line">  kernel&lt;&lt;grid, block, <span class="number">0</span>, streams[i]&gt;&gt;(&amp;d_a[offset]);</span><br><span class="line">  cudaMemcpyAsync(&amp;a[offset], &amp;d_a[offset], bytesPerStream, streams[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nStreams; i++) &#123;</span><br><span class="line">cudaStreamSynchronize(streams[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比于之前的默认流代码，使用流的异步代码不必阻塞，在一个数据传输及核函数返回前可以启动下一数据传输和核函数，实现网格级并行，效果如下图。</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/202205262106804.png" alt="image-20220526210629575"></p><h4 id="6-1-2-流调度"><a href="#6-1-2-流调度" class="headerlink" title="6.1.2 流调度"></a>6.1.2 流调度</h4><p><strong>虚假依赖关系</strong></p><p>虽然fermi架构支持16路并发，但所有的流最终多路复用到单一的迎检工作队列，这就导致了虚假的依赖关系，阻碍了网格级并行</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/202205262113244.png" alt="image-20220526211322189"></p><p><strong>Hyper-Q</strong></p><p>使用多个硬件工作队列，减少虚假依赖关系</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/202205262114761.png" alt="image-20220526211435690"></p><h4 id="6-1-3-流的优先级"><a href="#6-1-3-流的优先级" class="headerlink" title="6.1.3 流的优先级"></a>6.1.3 流的优先级</h4><p>计算能力3.5以上的设备，可以给流分配优先级</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分配优先级</span></span><br><span class="line">cudaError_t <span class="title function_">cudaStreamCreateWithPriority</span><span class="params">(cudaStream_t* pStream, <span class="type">unsigned</span> <span class="type">int</span> flags,<span class="type">int</span> priority)</span>;</span><br><span class="line"><span class="comment">//查询优先级</span></span><br><span class="line">cudaError_t <span class="title function_">cudaDeviceGetStreamPriorityRange</span><span class="params">(<span class="type">int</span> *leastPriority,<span class="type">int</span> *greatestPriority)</span>;</span><br></pre></td></tr></table></figure><p><code>cudaStreamCreateWithPriority</code>这个函数创建了一个具有指定整数优先级的流，并在pStream中返回一个句柄。这个优先级是与pStream中的工作调度相关的。高优先级流的网格队列可以优先占有低优先级流已经执行的工作。流优先级不会影响数据传输操作，只对计算内核有影响。如果优先级超出了设备定义的范围，它会被自动限制为定义范围内的最低值或最高值。</p><p><code>cudaDeviceGetStreamPriorityRange</code>的返回值放在<code>leastPriority</code>和<code>greatestPriority</code>中，如果当前设备不支持优先级，将返回0；</p><h4 id="6-1-4-事件"><a href="#6-1-4-事件" class="headerlink" title="6.1.4 事件"></a>6.1.4 事件</h4><p>CUDA事件与流中特定点相关联，可以执行两个基本任务：</p><ul><li>同步流的执行</li><li>监控设备的进展</li></ul><p>声明：<code>cudaEvent_t event; </code></p><p>初始化：<code>cudaError_t cudaEventCreate(cudaEvent_t* event);</code></p><p>销毁：<code>cudaError_t cudaEventDestroy(cudaEvent_t event); </code></p><p>在流中插入事件：<code>cudaError_t cudaEventRecord(cudaEvent_t event, cudaStream_t stream = 0);  </code></p><p>等待一个事件结束:<code>cudaError_t cudaEventSynchronize(cudaEvent_t event);  </code>类似<code>cudaStreamSynchronize  </code></p><p>查询一个事件是否执行完：<code>cudaError_t cudaEventQuery(cudaEvent_t event); </code>类似<code>cudaStreamQuery  </code></p><p>记录两个事件之间的时间：<code>cudaError_t cudaEventElapsedTime(float* ms, cudaEvent_t start, cudaEvent_t stop);  </code>两个事件不一定属于同一个流</p><h4 id="6-1-5-流同步"><a href="#6-1-5-流同步" class="headerlink" title="6.1.5 流同步"></a>6.1.5 流同步</h4><p>前面已经讲过，为了实现网格并行，非默认流中的操作是非阻塞的，但是会有主机和设备需要同步的时候，也就是流同步。</p><p><strong>阻塞流与非阻塞流</strong></p><p>前面已经介绍过空流与非空流，空流也就是默认流是同步流，其操作（内存操作）会阻塞主机，而非空流是异步流，其操作不阻塞主机，非空流可以进一步分成以下两种流：</p><ul><li>阻塞流：空流可以阻塞其操作</li><li>非阻塞流：不会阻塞空流中操作</li></ul><p>没看懂，回头再回来看吧！！！</p><p><strong>可配置事件</strong></p><p>没看懂sad</p><p><strong>隐式同步</strong></p><p>CUDA中有两种设备-主机同步：隐式同步与显示同步，隐式同步比如<code>cudaMemcpy</code>，了解隐式同步很有意义，因为没有考虑隐式同步的话会导致想不到的性能下降。</p><p>隐式同步包括：</p><ul><li>固定页主机内存分配</li><li>设备内存分配</li><li>设备内存初始化</li><li>同一个设备上两个地址之间的内存复制</li><li>一级缓存&#x2F;共享内存配置的修改</li></ul><p><strong>显示同步</strong></p><p>显示同步的几种方法：</p><p>- </p><ul><li>同步设备：<code>cudaDeviceSynchronize()</code>，使主机等待设备相关的计算与通信完成</li><li>同步流：<code>cudaStreamSynchronize()</code>，使主机等待所有该流中的操作完成</li><li>同步事件：<code>cudaEventSynchronize()</code>，使主机等待事件完成</li><li>事件同步（可以跨流）：<code>cudaStreamWaitEvent(cudaStream stream,cudaEvent_t event)</code>，使一个流等待一个事件完成，这个事件可能不属于这个流，这样就可以实现跨流同步。</li></ul><h3 id="6-2-并发内核执行"><a href="#6-2-并发内核执行" class="headerlink" title="6.2 并发内核执行"></a>6.2 并发内核执行</h3><h4 id="6-2-1-非空流的并发执行"><a href="#6-2-1-非空流的并发执行" class="headerlink" title="6.2.1 非空流的并发执行"></a>6.2.1 非空流的并发执行</h4><p>对于支持Hyper-Q的设备，使用多个非空流可以实现内核并发执行</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/202205291318256.png" alt="image-20220529131849166"></p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/202205291318583.png" alt="image-20220529131859505"></p><h4 id="6-2-2-fermiGPU的虚假依赖关系"><a href="#6-2-2-fermiGPU的虚假依赖关系" class="headerlink" title="6.2.2 fermiGPU的虚假依赖关系"></a>6.2.2 fermiGPU的虚假依赖关系</h4><p>然而在fermi架构中，由于不支持hyper-Q,所有流被多路复用的一个硬件工作队列，产生虚假依赖关系，无法并行</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/202205291320516.png" alt="image-20220529132059454"></p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/202205291320654.png" alt="image-20220529132048576"></p><p>可以采用广度优先顺序，确保工作队列中任务来自不同的流</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/202205291321117.png" alt="image-20220529132157058"></p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/202205291322795.png" alt="image-20220529132206722"></p><h4 id="6-2-3-使用OpenMP的调度操作"><a href="#6-2-3-使用OpenMP的调度操作" class="headerlink" title="6.2.3 使用OpenMP的调度操作"></a>6.2.3 使用OpenMP的调度操作</h4><p>之前的例子中都是使用一个线程启动多个内核，为了进一步提升性能可以使用多个主机线程将操作调度到多个流去。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">omp_set_num_threads(n_streams);</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i = omp_get_thread_num();</span><br><span class="line">  kernel_1&lt;&lt;&lt;grid, block, <span class="number">0</span>, streams[i]&gt;&gt;&gt;();</span><br><span class="line">  kernel_2&lt;&lt;&lt;grid, block, <span class="number">0</span>, streams[i]</span><br><span class="line">  kernel_3&lt;&lt;&lt;grid, block, <span class="number">0</span>, streams[i]&gt;&gt;&gt;();</span><br><span class="line">kernel_4&lt;&lt;&lt;grid, block, <span class="number">0</span>, streams[i]&gt;&gt;&gt;();</span><br><span class="line">&#125;&gt;&gt;&gt;();</span><br></pre></td></tr></table></figure><p>这个例子中使用openmp效果一般，当每个流在内核执行之前、期间或之后有额外的工作待完成，那么使用多线程调度流可以显著提高性能。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;cuda-c权威编程指南笔记&quot;&gt;&lt;a href=&quot;#cuda-c权威编程指南笔记&quot; class=&quot;headerlink&quot; title=&quot;cuda c权威编程指南笔记&quot;&gt;&lt;/a&gt;cuda c权威编程指南笔记&lt;/h1&gt;&lt;h2</summary>
        
      
    
    
    
    
    <category term="hpc" scheme="https://mightcoder.com/tags/hpc/"/>
    
    <category term="gpu" scheme="https://mightcoder.com/tags/gpu/"/>
    
    <category term="cuda" scheme="https://mightcoder.com/tags/cuda/"/>
    
  </entry>
  
  <entry>
    <title>【live house】2023.3.15 脆莓 《重返舞台》</title>
    <link href="https://mightcoder.com/2023/03/15/%E3%80%90live%20house%E3%80%912023-3-15-%E8%84%86%E8%8E%93-%E3%80%8A%E9%87%8D%E5%9B%9E%E8%88%9E%E5%8F%B0%E3%80%8B/"/>
    <id>https://mightcoder.com/2023/03/15/%E3%80%90live%20house%E3%80%912023-3-15-%E8%84%86%E8%8E%93-%E3%80%8A%E9%87%8D%E5%9B%9E%E8%88%9E%E5%8F%B0%E3%80%8B/</id>
    <published>2023-03-15T15:57:59.000Z</published>
    <updated>2023-04-25T10:16:27.828Z</updated>
    
    <content type="html"><![CDATA[<p>第二次爱上脆莓，整张专辑都可以循环一整天</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/IMG_20230315_203415.jpg" alt="IMG_20230315_203415"></p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/IMG_20230315_210340.jpg" alt="IMG_20230315_210340"></p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/mmexport1678891856106.jpg" alt="mmexport1678891856106"></p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/mmexport1678891861611.jpg" alt="mmexport1678891861611"></p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/mmexport1678891865305.jpg" alt="mmexport1678891865305"></p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;第二次爱上脆莓，整张专辑都可以循环一整天&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/IMG_20230315_203415.jpg&quot;</summary>
        
      
    
    
    
    
    <category term="livehouse" scheme="https://mightcoder.com/tags/livehouse/"/>
    
  </entry>
  
  <entry>
    <title>PAC22-初赛</title>
    <link href="https://mightcoder.com/2022/07/31/PAC22-%E5%88%9D%E8%B5%9B/"/>
    <id>https://mightcoder.com/2022/07/31/PAC22-%E5%88%9D%E8%B5%9B/</id>
    <published>2022-07-31T13:01:37.000Z</published>
    <updated>2023-05-15T09:33:48.218Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0-赛题分析"><a href="#0-赛题分析" class="headerlink" title="0.赛题分析"></a>0.赛题分析</h2><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/202207162126920.png" alt="image-20220716212644704"></p><p>初始化和验证正确性用了一秒，核心函数用了63.5秒</p><p>通过分析，该程序为访存密集型，在GPU上可能访存成为瓶颈。</p><p>可能存在的优化方法：</p><p>编译器优化：感觉无计可施，只替换为dpcpp不变代码的话会变慢</p><p>拆分复数类，自己实现，将AOS转换为SOA</p><p>修改循环或者进行矩阵转置</p><p>GPU版本</p><p>多GPU并行</p><p>更换buffer为USM</p><p>使用MPI多进程来提高GPU利用率</p><p>负载均衡</p><p>CPUGPU协同计算</p><p>降低时间复杂度</p><h2 id="1-重写复数库"><a href="#1-重写复数库" class="headerlink" title="1.重写复数库"></a>1.重写复数库</h2><p>思路：将AOS换位SOA</p><p>将复数数据其完全拆分成double数组操作，除了将将AOS换位SOA，还简化了部分中间计算。</p><p>问题：拆分复数后显著变慢。</p><blockquote><p>tips：某个方向的优化遇到瓶颈最好不要死钻牛角尖，心态会很受影响，最好换个方向进行优化</p></blockquote><p>原因：因为没有先改变循环的顺序，导致有些数组还是列访问，当将复数数组拆分成两个数组后，cache miss会加倍，cache冲突率也会加倍，所以时间会变慢，在修改循环顺序后保证了所有的数组都是行访问，性能就不会下降了。但是由于在拆分前已经向量化了（vtune显示向量化100%），所以拆分后没有显著的性能提升。等放到GPU上试试有没有性能提升吧</p><blockquote><p>tips：做这种AOS转SOA时，要先保证访存不会出问题</p></blockquote><p>最终这一步并没有明显的性能优化，所以最后提交版本并没有做复数类的拆分。</p><h2 id="2-CPU优化"><a href="#2-CPU优化" class="headerlink" title="2.CPU优化"></a>2.CPU优化</h2><p>修改循环顺序、减少重复运算</p><h3 id="修改循环顺序"><a href="#修改循环顺序" class="headerlink" title="修改循环顺序"></a>修改循环顺序</h3><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/202207231547569.png" alt="image-20220723154700341"></p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/202207231547719.png" alt="image-20220723154725663"></p><p>主要作用是保证了数组的行访问而不是列访问，提高访存连续性。</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/202207231550394.png" alt="image-20220723155014349"></p><blockquote><p>tips：遇到大循环先检查一边所有的数组访问，看看有没有列访问，然后想办法改变循环顺序使其变为行访问。</p></blockquote><h3 id="减少重复运算："><a href="#减少重复运算：" class="headerlink" title="减少重复运算："></a>减少重复运算：</h3><p>将重复的公共运算提出循环，避免时间的浪费。</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/202208041602973.png" alt="image-20220804160217915"></p><p>本轮优化后时间减少到6-8秒</p><h2 id="3-GPU版本"><a href="#3-GPU版本" class="headerlink" title="3.GPU版本"></a>3.GPU版本</h2><p>尝试将代码移植到SYCL版本，查阅官方文档后发现有两条路，SYCL版本(DPCPP)和OpenMP offload，我们对两个版本都进行了尝试，感觉坑还是挺多的，主要是语法杂糅太容易出错了，建议仔细看下《data-parallel-c++》这本书，github上有人翻译成了中文版。</p><p>OpenMP offload版本还是比较简单的，尤其对于这种本就是openmp程序的，只需要分好teams，做一下循环展开collapse就好（不然无法offload，具体原因没找到），最终结果发现只比CPU版本快了一点点，我们的版本肯定不是最快的，但是在尝试过后我们发现openmp可操作空间相较于SYCL不是很大，于是就放弃了后续的版本开发。openmp offload主要是方便移植，想要学习除了官方文档和oneapi的devcloud外，还可以参考《oneapi-gpu-optimization-guide》这本书的openmp部分。</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/202208041501855.png" alt="image-20220804150154606"></p><p>对于SYCL版本，我们选择nd-range来划分任务，针对本赛题的四层循环，我们最初将外面三层循环对应到nd-range的三维，后来发现三维相乘爆int了，即使使用long也会报错，后来选择将ncouls除以k，在parallel_for内部再嵌套一层循环，然后就能够跑通了。随后尝试增大k，发现速度有所提升，思考后我认为原因主要是虽然我这样写并行粒度大，但是每个EU的占用率不高，所以干脆将nd-range划分为二维，在parallel_for内部保留ncouls的一层循环。速度又有所提升。最终GPU初版优化到2.5秒左右。</p><h2 id="4-GPU层面优化"><a href="#4-GPU层面优化" class="headerlink" title="4.GPU层面优化"></a>4.GPU层面优化</h2><p>因为平台上有两个GPU，在编写出GPU初版后，我尝试调用两个GPU共同计算，但至今没有搞懂oneapi的dpcpp和底层硬件是怎么对应的，当使用默认设备初始化queue时，只有一个设备的占用率有变化，最多到12.5%，当尝试遍历获取所有设备再指定queue的设备后，两个GPU的占用率都有变化，且最多能够到37.5%（令人费解）。anyway，我们尝试显示指定queue的device后性能又有所提升。</p><p>我们最初的版本使用的是buffer来传输数据。在尝试换成USM后性能再次提升。</p><p>本轮优化后时间来到1.5秒左右。</p><h2 id="5-降低时间复杂度，中间结果预计算"><a href="#5-降低时间复杂度，中间结果预计算" class="headerlink" title="5.降低时间复杂度，中间结果预计算"></a>5.降低时间复杂度，中间结果预计算</h2><p>在比赛即将截止时我们又发现了新的算法优化。我们发现只有下图中红框内的计算需要循环number_bands次，其他的计算不需要经历number_bands循环，为冗余计算。</p><p>为想办法消掉number_bands这层循环，将下图红框操作提出大循环单独计算，将number_bands层循环移到最内层，<strong>避免冗余计算</strong></p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/202208092114355.png" alt="image-20220809211427126"></p><p>改为：</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/202208092114080.png" alt="image-20220809211437031"></p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/202208092114264.png" alt="image-20220809211441207"></p><p>此时最内层的计算只和ngpown和number_bands这两层循环有关。将其提出大循环，减少不必要的冗余计算。 最后时间复杂度从O(ngpown<em>ncouls</em>number_bands<em>nend)变为O(ngpown</em>ncouls*nend)</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/202208092115064.png" alt="image-20220809211559009"></p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/202208092116834.png" alt="image-20220809211602777"></p><p>cpu只需要0.12秒左右，但是结果过不了cpu版本的check，没办法只能上CPUGPU协同版本，当优化到现在这个算法的计算已经不是瓶颈了，变成了访存密集型，放到GPU上反而会慢一些，最终提交时间0.25秒。（希望能过check）</p><h2 id="6-编译器优化"><a href="#6-编译器优化" class="headerlink" title="6.编译器优化"></a>6.编译器优化</h2><p>这部分优化是提交之后学长告诉我们的，所以只是自己试了试，提交的是0.25的版本。因为dpcpp为了保证兼容性，采用即时编译(JIT)，可以通过提前编译(AOT)来避免JIT，需要在编译时指定在哪种设备上执行，编译参数如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpcpp -O3 -qopenmp  -fsycl-targets=spir64_gen -Xsycl-target-backend=spir64_gen &quot;-device 0x020a&quot; maicpp -o main.exe</span><br></pre></td></tr></table></figure><p>优化效果十分显著，添加参数后时间可以来到0.12秒左右，在我们之前的版本上效果更加显著，因为之前的版本是纯GPU计算，时间可以从0.8秒降低到0.4秒左右！</p><h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7.总结"></a>7.总结</h2><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/202208092117272.png" alt="image-20220809211721043"></p><p>加速比如图所示。</p><h2 id="说句题外话"><a href="#说句题外话" class="headerlink" title="说句题外话"></a>说句题外话</h2><p>未解之谜：至今不知道英特尔的GPU底层是怎么映射的，我们最开始使用的是遍历得到的device，两个GPUcompute率都可以飙到37.5%，最快能到0.7秒，但是及其不稳定，波动到3秒都有可能。后来使用默认构造函数构造queue，时间稳定在0.85秒左右。但是当我这样写时：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> queue q[7];</span><br><span class="line">int dq=0;</span><br><span class="line">auto platforms = sycl::platform::get_platforms();</span><br><span class="line">for (auto &amp;platform : platforms) &#123;</span><br><span class="line">    auto devices = platform.get_devices();</span><br><span class="line">    for (auto &amp;device : devices) &#123;</span><br><span class="line">        q[dq]=queue(device);</span><br><span class="line">        dq++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">queue q1;</span><br></pre></td></tr></table></figure><p>使用q1时两个GPUcompute都飙到37.5%，太奇怪了，不知道底层怎么编写的。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h2 id=&quot;0-赛题分析&quot;&gt;&lt;a href=&quot;#0-赛题分析&quot; class=&quot;headerlink&quot; title=&quot;0.赛题分析&quot;&gt;&lt;/a&gt;0.赛题分析&lt;/h2&gt;&lt;p&gt;&lt;img</summary>
        
      
    
    
    
    
    <category term="hpc" scheme="https://mightcoder.com/tags/hpc/"/>
    
    <category term="pac" scheme="https://mightcoder.com/tags/pac/"/>
    
    <category term="gpu" scheme="https://mightcoder.com/tags/gpu/"/>
    
    <category term="竞赛" scheme="https://mightcoder.com/tags/%E7%AB%9E%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>optimizing_cpp(10)</title>
    <link href="https://mightcoder.com/2022/04/05/optimizing-cpp-10/"/>
    <id>https://mightcoder.com/2022/04/05/optimizing-cpp-10/</id>
    <published>2022-04-05T13:11:37.000Z</published>
    <updated>2022-07-15T08:13:03.060Z</updated>
    
    <content type="html"><![CDATA[<h2 id="十、向量操作"><a href="#十、向量操作" class="headerlink" title="十、向量操作"></a>十、向量操作</h2><p>现代处理器基本都支持向量指令了，这种技术叫SIMD(single instruction multiple data)。向量大小从64位（MMX）、128位(XMM)、256位(YMM)、512位(ZMM)</p><p>向量操作适用于对多个数据执行相同的操作且运行并行，比如图像处理、声音处理、矩阵运算。</p><p>下面附上各个向量指令集支持的数据类型</p><table><thead><tr><th><strong>Type of elements</strong></th><th align="center"><strong>Size of each elements, bits</strong></th><th align="center"><strong>Number of elements</strong></th><th align="center"><strong>Total size of vector, bits</strong></th><th><strong>Instruction set</strong></th></tr></thead><tbody><tr><td><code>char</code></td><td align="center">8</td><td align="center">8</td><td align="center">64</td><td><em>MMX</em></td></tr><tr><td><code>short int</code></td><td align="center">16</td><td align="center">4</td><td align="center">64</td><td><em>MMX</em></td></tr><tr><td><code>int</code></td><td align="center">32</td><td align="center">2</td><td align="center">64</td><td><em>MMX</em></td></tr><tr><td><code>int64_t</code></td><td align="center">64</td><td align="center">1</td><td align="center">64</td><td><em>MMX</em></td></tr><tr><td></td><td align="center"></td><td align="center"></td><td align="center"></td><td></td></tr><tr><td><code>char</code></td><td align="center">8</td><td align="center">16</td><td align="center">128</td><td><em>SSE2</em></td></tr><tr><td><code>short int</code></td><td align="center">16</td><td align="center">8</td><td align="center">128</td><td><em>SSE2</em></td></tr><tr><td><code>int</code></td><td align="center">32</td><td align="center">4</td><td align="center">128</td><td><em>SSE2</em></td></tr><tr><td><code>int64_t</code></td><td align="center">64</td><td align="center">2</td><td align="center">128</td><td><em>SSE2</em></td></tr><tr><td><code>float</code></td><td align="center">32</td><td align="center">4</td><td align="center">128</td><td><em>SSE</em></td></tr><tr><td><code>double</code></td><td align="center">64</td><td align="center">2</td><td align="center">128</td><td><em>SSE2</em></td></tr><tr><td></td><td align="center"></td><td align="center"></td><td align="center"></td><td></td></tr><tr><td><code>char</code></td><td align="center">8</td><td align="center">32</td><td align="center">256</td><td><em>AVX2</em></td></tr><tr><td><code>short int</code></td><td align="center">16</td><td align="center">16</td><td align="center">256</td><td><em>AVX2</em></td></tr><tr><td><code>int</code></td><td align="center">32</td><td align="center">8</td><td align="center">256</td><td><em>AVX2</em></td></tr><tr><td><code>int64_t</code></td><td align="center">64</td><td align="center">4</td><td align="center">256</td><td><em>AVX2</em></td></tr><tr><td><code>float</code></td><td align="center">32</td><td align="center">8</td><td align="center">256</td><td><em>AVX</em></td></tr><tr><td><code>double</code></td><td align="center">64</td><td align="center">4</td><td align="center">256</td><td><em>AVX</em></td></tr><tr><td></td><td align="center"></td><td align="center"></td><td align="center"></td><td></td></tr><tr><td><code>char</code></td><td align="center">8</td><td align="center">64</td><td align="center">512</td><td><em>AVX512BW</em></td></tr><tr><td><code>short int</code></td><td align="center">16</td><td align="center">32</td><td align="center">512</td><td><em>AVX512BW</em></td></tr><tr><td><code>int</code></td><td align="center">32</td><td align="center">16</td><td align="center">512</td><td><em>AVX512</em></td></tr><tr><td><code>int64_t</code></td><td align="center">64</td><td align="center">8</td><td align="center">512</td><td><em>AVX512</em></td></tr><tr><td><code>float</code></td><td align="center">32</td><td align="center">16</td><td align="center">512</td><td><em>AVX512</em></td></tr><tr><td><code>double</code></td><td align="center">64</td><td align="center">8</td><td align="center">512</td><td><em>AVX512</em></td></tr></tbody></table><p>这里忽略了anger关于avx256的介绍，因为查阅资料后发现有不少错误，比如他强调的<code>_mm256_zeroupper()</code> ，这个函数会由编译器自动加上，程序员不应当手动调用。</p><p>另外附上各阶段指令集支持类型</p><table><thead><tr><th>MMX</th><th>64 位整型</th></tr></thead><tbody><tr><td>SSE</td><td>128 位浮点运算，整数运算仍然要使用 MMX 寄存器，只支持单精度浮点运算</td></tr><tr><td>SSE2</td><td>对整型数据的支持，支持双精度浮点数运算，CPU 快取的控制指令</td></tr><tr><td>SSE3</td><td>扩展的指令包含寄存器的局部位之间的运算，例如高位和低位之间的加减运算；浮点数到整数的转换，以及对超线程技术的支持。</td></tr><tr><td>SSE4</td><td></td></tr><tr><td>AVX</td><td>256 位浮点运算</td></tr><tr><td>AVX2</td><td>对 256 位整型数据的支持，三运算指令（3-Operand Instructions）</td></tr><tr><td>AVX512</td><td>512 位运算</td></tr></tbody></table><p>另外发现一个挺不错的入门介绍，贴上来<a href="https://blog.csdn.net/qq_32916805/article/details/117637192">一文读懂SIMD指令集 目前最全SSE&#x2F;AVX介绍_Axurq的博客-CSDN博客_simd指令集</a></p><h3 id="1-自动向量化"><a href="#1-自动向量化" class="headerlink" title="1.自动向量化"></a>1.自动向量化</h3><p>许多编译器有自动向量化的功能，比如gcc中-O3就开启了自动向量化，除此之外，还可以通过<code>-fopt-info-vec-optimized</code>或<code>-fopt-info-vec</code>命令来查看是否开启向量化。</p><p>自动向量化最重要的方面就是对齐，尽量保证在内存中是地址对齐的。</p><p>内存对齐：</p><p>内存对齐是一个常见的现象，网上查阅资料其实说的都不是很详尽，个人整理理解如下</p><p><strong>为什么要内存对齐？</strong></p><p>1.现代计算机中内存空间都是按照byte划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定变量的时候经常在特定的内存地址访问，比如2、4、8的倍数。</p><p>2.由于1的原因，如果内存没有对齐在读内存时可能本来只需要读一次，但却需要读两次。就像下面这张图（太丑了凑合看），如果不内存对齐，读double时先读前八个字节，再读后八个字节，需要读两次，但是右边的图内存对齐后只需要读一次就行了。</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/202204011846756.png" alt="image-20220401184636679"></p><p>并且经过测试，编译器除了会自动内存对齐，还会将内存地址也对齐，其元素的内部地址总是能被结构体中最大的元素的大小整除，方便cpu进行内存访问。</p><p>仍然存疑关于avx256要32位对齐：64位cpu一次访存读取的块是多大的？是64位吗，那为什么向量化从内存载入时要求还32字节对齐呢（8字节对齐不就行了吗），cpu可以一次读取32字节数据吗？</p><h3 id="2-手动向量化"><a href="#2-手动向量化" class="headerlink" title="2.手动向量化"></a>2.手动向量化</h3><p>一般来说尽量让编译器自动向量化，但是有些情况编译器无法自动向量化，而向量化带来的收益很可观就可以手动向量化，例如下面这个栗子，当存在分支时，编译器很难向量化，此时可以利用内部函数手动向量化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example 12.4a. Loop with branch</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Loop with branch</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SelectAddMul</span><span class="params">(<span class="type">short</span> <span class="type">int</span> aa[], <span class="type">short</span> <span class="type">int</span> bb[], <span class="type">short</span> <span class="type">int</span> cc[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        aa[i] = (bb[i] &gt; <span class="number">0</span>) ? (cc[i] + <span class="number">2</span>) : (bb[i] * cc[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以改成</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example 12.4b. Vectorized with SSE2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;emmintrin.h&gt;</span> <span class="comment">// Define SSE2 intrinsic functions</span></span></span><br><span class="line"><span class="comment">// Function to load unaligned integer vector from array</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> __m128i <span class="title">LoadVector</span><span class="params">(<span class="type">void</span> <span class="type">const</span> * p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _mm_loadu_si128((__m128i <span class="type">const</span>*)p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Function to store unaligned integer vector into array</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title">StoreVector</span><span class="params">(<span class="type">void</span> * d, __m128i <span class="type">const</span> &amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _mm_storeu_si128((__m128i *)d, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Branch/loop function vectorized:</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SelectAddMul</span><span class="params">(<span class="type">short</span> <span class="type">int</span> aa[], <span class="type">short</span> <span class="type">int</span> bb[], <span class="type">short</span> <span class="type">int</span> cc[])</span>、</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Make a vector of (0,0,0,0,0,0,0,0)</span></span><br><span class="line">    __m128i zero = _mm_set1_epi16(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// Make a vector of (2,2,2,2,2,2,2,2)</span></span><br><span class="line">    __m128i two = _mm_set1_epi16(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// Roll out loop by eight to fit the eight-element vectors:</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i += <span class="number">8</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Load eight consecutive elements from bb into vector b:</span></span><br><span class="line">        __m128i b = <span class="built_in">LoadVector</span>(bb + i);</span><br><span class="line">        <span class="comment">// Load eight consecutive elements from cc into vector c:</span></span><br><span class="line">        __m128i c = <span class="built_in">LoadVector</span>(cc + i);</span><br><span class="line">        <span class="comment">// Add 2 to each element in vector c</span></span><br><span class="line">        __m128i c2 = _mm_add_epi16(c, two);</span><br><span class="line">        <span class="comment">// Multiply b and c</span></span><br><span class="line">        __m128i bc = _mm_mullo_epi16 (b, c);</span><br><span class="line">        <span class="comment">// Compare each element in b to 0 and generate a bit-mask:</span></span><br><span class="line">        __m128i mask = _mm_cmpgt_epi16(b, zero);</span><br><span class="line">        <span class="comment">// AND each element in vector c2 with the bit-mask:</span></span><br><span class="line">        c2 = _mm_and_si128(c2, mask);</span><br><span class="line">        <span class="comment">// AND each element in vector bc with the inverted bit-mask:</span></span><br><span class="line">        bc = _mm_andnot_si128(mask, bc);</span><br><span class="line">        <span class="comment">// OR the results of the two AND operations:</span></span><br><span class="line">        __m128i a = _mm_or_si128(c2, bc);</span><br><span class="line">        <span class="comment">// Store the result vector in eight consecutive elements in aa:</span></span><br><span class="line">        <span class="built_in">StoreVector</span>(aa + i, a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>手动向量化如何对齐数据</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example 12.5. Aligned arrays</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> size = <span class="number">256</span>; <span class="comment">// Array size</span></span><br><span class="line"><span class="built_in">alignas</span>(<span class="number">16</span>) <span class="type">int16_t</span> aa[size]; <span class="comment">// Make aligned array</span></span><br></pre></td></tr></table></figure><p><strong>查找表向量化</strong></p><p>查找表是一种很高效的优化手段，以空间换时间，后面会详细讲解如何使用。查找表通常是向量化的障碍，从avx2开始支持对查找表有利的函数如gather等。</p><h3 id="3-将串行代码向量化"><a href="#3-将串行代码向量化" class="headerlink" title="3.将串行代码向量化"></a>3.将串行代码向量化</h3><p>有许多代码执行相同的操作，但是却因为循环依赖无法向量化和并行，我们可以通过修改代码结构来使其能够向量化，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example 12.8a. Sum of a list</span></span><br><span class="line"><span class="type">float</span> a[<span class="number">100</span>];</span><br><span class="line"><span class="type">float</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) </span><br><span class="line">    sum += a[i];</span><br></pre></td></tr></table></figure><p>上述的代码是串行的，因为每次迭代 <code>sum</code> 的值都依赖于前一次迭代后 <code>sum</code>  的值。诀窍是将循环按 <code>n</code> 展开并重新组织代码，每个值依赖于 <code>n</code> 个位置之前的值，其中 <code>n</code> 是向量中元素的数量。如果 <code>n = 4</code>，我们得到：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example 12.8b. Sum of a list, rolled out by 4</span></span><br><span class="line"><span class="type">float</span> a[<span class="number">100</span>];</span><br><span class="line"><span class="type">float</span> s0 = <span class="number">0</span>, s1 = <span class="number">0</span>, s2 = <span class="number">0</span>, s3 = <span class="number">0</span>, sum;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i += <span class="number">4</span>)</span><br><span class="line">&#123;</span><br><span class="line">    s0 += a[i];</span><br><span class="line">    s1 += a[i+<span class="number">1</span>];</span><br><span class="line">    s2 += a[i+<span class="number">2</span>];</span><br><span class="line">    s3 += a[i+<span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line">sum = (s0+s1)+(s2+s3);</span><br></pre></td></tr></table></figure><p>现在，<code>s0</code>、<code>s1</code>、<code>s2</code> 和 <code>s3 </code>可以组合成一个128位的向量，这样我们就可以在一个操作中做4个加法。如果我们使用 <em>fast math</em> 选项并指定<em>SSE</em> 或更高指令集的选项，一个好的编译器会自动将<strong>例 12.8a</strong>转换为<strong>12.8b</strong>，并将代码向量化。</p><p>再一些更复杂的情况下不能自动向量化。例如，让我们看看泰勒级数的例子。指数函数可由级数计算：</p><p>$$<br>e^x&#x3D;\sum_{n&#x3D;0}^\infty\frac{x^n}{n!}<br>$$<br>用<em>C++</em> 实现看起来可能是这样的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example 12.9a. Taylor series</span></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">Exp</span><span class="params">(<span class="type">float</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Approximate exp(x) for small x</span></span><br><span class="line">    <span class="type">float</span> xn = x; <span class="comment">// x^n</span></span><br><span class="line">    <span class="type">float</span> sum = <span class="number">1.f</span>; <span class="comment">// sum, initialize to x^0/0!</span></span><br><span class="line">    <span class="type">float</span> nfac = <span class="number">1.f</span>; <span class="comment">// n factorial</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n = <span class="number">1</span>; n &lt;= <span class="number">16</span>; n++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += xn / nfac;</span><br><span class="line">        xn *= x;</span><br><span class="line">        nfac *= n+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里每个  x^n 的值由前一个值计算而来，即 x^n &#x3D; x*(x^{n-1})，每个 n! 的值也由前一个值计算而来，即 n!&#x3D; n*(n-1)!。如果我们想要将循环按 4展开，那我们必须要用 4个位置之前的值来计算当前的值。因此，我们将用 x^4*x^{n-4}来计算x^n。没有简单的方法来展开阶乘的计算，但是这个并不是必需的，因为阶乘并不依赖  x ，我们可以将值预先计算好，存一个表中。更好的方法是存储阶乘的倒数，这样我们就不需要除法了（如你所知，除法是很慢的）。现在上述的的代码可以按如下的方式向量化（使用 <strong>Intel vector classes</strong>）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example 12.9b. Taylor series, vectorized</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dvec.h&gt;</span> <span class="comment">// Define vector classes (Intel)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pmmintrin.h&gt;</span> <span class="comment">// SSE3 required</span></span></span><br><span class="line"><span class="comment">// This function adds the elements of a vector, uses SSE3.</span></span><br><span class="line"><span class="comment">// (This is faster than the function add_horizontal)</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">float</span> <span class="title">add_elements</span><span class="params">(__m128 <span class="type">const</span> &amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __m128 s;</span><br><span class="line">    s = _mm_hadd_ps(x, x);</span><br><span class="line">    s = _mm_hadd_ps(s, s);</span><br><span class="line">    <span class="keyword">return</span> _mm_cvtss_f32(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">Exp</span><span class="params">(<span class="type">float</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Approximate exp(x) for small x</span></span><br><span class="line">    __declspec(<span class="built_in">align</span>(<span class="number">16</span>)) <span class="comment">// align table by 16</span></span><br><span class="line">    <span class="type">const</span> <span class="type">float</span> coef[<span class="number">16</span>] = &#123; <span class="comment">// table of 1/n!</span></span><br><span class="line">    <span class="number">1.</span>, <span class="number">1.</span>/<span class="number">2.</span>, <span class="number">1.</span>/<span class="number">6.</span>, <span class="number">1.</span>/<span class="number">24.</span>, <span class="number">1.</span>/<span class="number">120.</span>, <span class="number">1.</span>/<span class="number">720.</span>, <span class="number">1.</span>/<span class="number">5040.</span>,</span><br><span class="line">    <span class="number">1.</span>/<span class="number">40320.</span>, <span class="number">1.</span>/<span class="number">362880.</span>, <span class="number">1.</span>/<span class="number">3628800.</span>, <span class="number">1.</span>/<span class="number">39916800.</span>,</span><br><span class="line">    <span class="number">1.</span>/<span class="number">4.790016E8</span>, <span class="number">1.</span>/<span class="number">6.22702E9</span>, <span class="number">1.</span>/<span class="number">8.71782E10</span>,</span><br><span class="line">    <span class="number">1.</span>/<span class="number">1.30767E12</span>, <span class="number">1.</span>/<span class="number">2.09227E13</span>&#125;;</span><br><span class="line">    <span class="type">float</span> x2 = x * x; <span class="comment">// x^2</span></span><br><span class="line">    <span class="type">float</span> x4 = x2 * x2; <span class="comment">// x^4</span></span><br><span class="line">    <span class="comment">// Define vectors of four floats</span></span><br><span class="line">    <span class="function">F32vec4 <span class="title">xxn</span><span class="params">(x4, x2*x, x2, x)</span></span>; <span class="comment">// x^1, x^2, x^3, x^4</span></span><br><span class="line">    <span class="function">F32vec4 <span class="title">xx4</span><span class="params">(x4)</span></span>; <span class="comment">// x^4</span></span><br><span class="line">    <span class="function">F32vec4 <span class="title">s</span><span class="params">(<span class="number">0.f</span>, <span class="number">0.f</span>, <span class="number">0.f</span>, <span class="number">1.f</span>)</span></span>; <span class="comment">// initialize sum</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i += <span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Loop by 4</span></span><br><span class="line">        s += xxn * _mm_load_ps(coef+i); <span class="comment">// s += x^n/n!</span></span><br><span class="line">        xxn *= xx4; <span class="comment">// next four x^n</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">add_elements</span>(s); <span class="comment">// add the four sums</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个循环在一个向量中计算四个连续的项。如果循环很长，那么进一步展开循环可能是值得的，因为这里的速度可能受到 <code>xxn</code> 相乘的延迟而不是吞吐量的限制（参见<strong>11 乱序执行</strong>）。这里的系数表是在编译时计算的。在运行时计算系数表可能更方便，只要你能确保系数表只被计算一次，而不是每次调用函数时都会被计算一次。</p><h3 id="4-向量运算的数学函数"><a href="#4-向量运算的数学函数" class="headerlink" title="4.向量运算的数学函数"></a>4.向量运算的数学函数</h3><p>除了英特尔官方的向量基本运算函数外，还有许多函数库支持对数、指数、三角等数学函数的运算。</p><p>有两种向量数学库，长向量库和短向量库，长向量库在每一步等待所有值计算完成后再进入下一步，这意味着在内存中会有中间数组存储中间值，而短向量库对一组数据（比如avx256就是4个double）执行全部步骤后得到最终结果再算下一组数据，这样做就不会产生中间值。一般来说短向量库要高效一些因为没有中间值，但是当数学函数的计算存在依赖链时，短向量库由于阻止了乱序执行效率会显著降低。</p><p>下面是一些长向量数学库的列表：</p><ol><li>Intel vector math library (VML, MKL)。支持所有<em>x86</em> 平台。这个库降低了<em>非英特尔CPU</em> 的性能，除非你重写了英特尔的 <em>CPU分派程序</em>。见<strong>13.7 Intel 编译器中的 CPU分派</strong>。</li><li>Intel Performance Primitives (IPP)。支持所有<em>x86</em> 平台。在<em>非英特尔 CPU</em> 上也能工作的很好。包括许多用于统计学，信号处理和图像处理的函数。</li><li>Yeppp。开源库。支持 <em>x86</em> 和 <em>ARM</em> 平台以及多种编程语言。<a href="https://www.yeppp.info/">www.yeppp.info</a>。</li></ol><p>下面是一些短向量数学库的列表：</p><ol><li>Sleef library。支持多种不同的平台。开源。<a href="https://www.sleef.org/">www.sleef.org</a>。</li><li>Intel short vector math library (SVML)。这是由 <em>Intel 编译器</em> 提供的，并通过自动向量化调用。<em>Gnu编译器</em> 可以通过选项 <code>-mveclibabi=svml</code> 使用这个库。如果不使用 Intel 编译器话，这个库通常可以很好地处理 <em>非Intel CPU</em>。见<strong>13.7 Intel 编译器中的 CPU分派</strong>。</li><li>AMD LIBM library。只在64位<em>Linux</em> 和<em>Windows</em> 平台上可用。这个库在没有<em>FMA4</em> 指令集的情况下降低了<em>CPU</em> 的性能（这个指令集最初是由英特尔设计的，但目前只有 <em>AMD</em> 的CPU 支持）。在 <em>Gnu编译器</em> 中，可以通过选项 <code>-mveclibabi=acml</code> 使用这个库。</li><li>VCL vector class library。支持所有<em>x86</em> 平台。支持 <em>Microsoft</em>、<em>Intel</em>、<em>Gnu</em> 和<em>Clang</em> 编译器。代码是内联的，不需要链接外部库。<a href="https://www.agner.org/optimize/#vectorclass">www.agner.org/optimize/#vectorclass</a>。</li></ol><p>所有这些库都具有很好的性能和精度。速度比任何非向量库快很多倍。</p><p><em>SVML</em> 和 <em>LIBM</em> 库中的函数名没有很好的说明文档。如果你想直接调用库函数，可以参考下表中的例子：</p><table><thead><tr><th align="left"><strong>Library</strong></th><th align="left"><strong>exp function of 4 floats</strong></th><th align="left"><strong>exp function of 2 double</strong></th></tr></thead><tbody><tr><td align="left">Intel SVML v.10.2 &amp; earlier</td><td align="left"><code>vmlsExp4 </code></td><td align="left"><code>vmldExp2</code></td></tr><tr><td align="left">Intel SVML v.10.3 &amp; later</td><td align="left"><code>__svml_expf4</code></td><td align="left"><code>__svml_exp2</code></td></tr><tr><td align="left">Intel SVML + ia32intrin.h</td><td align="left"><code>_mm_exp_ps</code></td><td align="left"><code>_mm_exp_pd</code></td></tr><tr><td align="left">AMD Core Math Library</td><td align="left"><code>__vrs4_expf</code></td><td align="left"><code>__vrd2_exp</code></td></tr><tr><td align="left">AMD LIBM Library</td><td align="left"><code>amd_vrs4_expf</code></td><td align="left"><code>amd_vrd2_exp</code></td></tr><tr><td align="left">VCL vector class library</td><td align="left"><code>exp</code></td><td align="left"><code>exp</code></td></tr></tbody></table><h3 id="5-无法填满向量寄存器时"><a href="#5-无法填满向量寄存器时" class="headerlink" title="5.无法填满向量寄存器时"></a>5.无法填满向量寄存器时</h3><p>当变量数目无法填满向量寄存器时，比如只有三个值却想使用avx256，典型的栗子就是RGB图形处理，解决方案有：</p><ol><li>加入不使用的第四个值，使数据刚好可以装入向量中。这是一个简单的解决方案，但是它增加了内存使用量。如果内存访问是瓶颈，需要避免使用这种方法。</li><li>将四个（或八个）点的的数据组成一组，其中一个向量中有四个 R值，下一个向量中有四个 G值，最后一个向量中有四个 B值。</li><li>首先将所有的 R值组织成数据，然后是所有的 G值，最后是所有的 B值。</li></ol><p>2、3方法皆可。如果点的数量不能被向量大小整除，那么可以在最后面添加几个未使用的点，以得到整数个向量。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h2 id=&quot;十、向量操作&quot;&gt;&lt;a href=&quot;#十、向量操作&quot; class=&quot;headerlink&quot; title=&quot;十、向量操作&quot;&gt;&lt;/a&gt;十、向量操作&lt;/h2&gt;&lt;p&gt;现代处理器基本都支持向量指令了，这种技术叫SIMD(single instruction multiple</summary>
        
      
    
    
    
    
    <category term="hpc" scheme="https://mightcoder.com/tags/hpc/"/>
    
    <category term="cpp" scheme="https://mightcoder.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>optimizing_cpp(11)</title>
    <link href="https://mightcoder.com/2022/04/05/optimizing-cpp-11/"/>
    <id>https://mightcoder.com/2022/04/05/optimizing-cpp-11/</id>
    <published>2022-04-05T13:11:37.000Z</published>
    <updated>2022-07-15T08:13:03.060Z</updated>
    
    <content type="html"><![CDATA[<h2 id="十一、具体优化策略"><a href="#十一、具体优化策略" class="headerlink" title="十一、具体优化策略"></a>十一、具体优化策略</h2><blockquote><p>跳过了anger手册中关于cpu dispatch的一章，还是感觉太遥远了，等需要的时候再去了解吧</p></blockquote><h3 id="1-查找表（lookup-tables）"><a href="#1-查找表（lookup-tables）" class="headerlink" title="1.查找表（lookup tables）"></a>1.查找表（lookup tables）</h3><p>如果list在缓存中，从list中读值是非常快的，要快过函数计算，所以可以将函数计算替换成从查找表取值。</p><p>使用查找表的tips</p><ol><li>查找表应该声明为<code>const</code>，以便启用常量传播和其他优化。</li><li>在函数内部声明查找表时不要声明为静态的<code>static</code>，因为静态数据可能分散在不同的内存地址，可能会导致缓存问题。可以声明为const，例如：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example 14.1c</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CriticalInnerFunction</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Table of factorials:</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> FactorialTable[<span class="number">13</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">24</span>, <span class="number">120</span>, <span class="number">720</span>,</span><br><span class="line">        <span class="number">5040</span>, <span class="number">40320</span>, <span class="number">362880</span>, <span class="number">3628800</span>, <span class="number">39916800</span>, <span class="number">479001600</span>&#125;;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">int</span> i, a, b;</span><br><span class="line">    <span class="comment">// Critical innermost loop:</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        a = FactorialTable[b];</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>例 14.1c</strong>中的 <code>FactorialTable</code> 在调用 <code>CriticalInnerFunction</code> 时从静态内存中复制到栈上。编译器将表存储在静态内存中，并在函数开始的地方插入代码，将表复制到栈内存中。当然，复制表需要额外的时间，但是当它位于关键的最内层循环之外时，这是被允许的。循环将使用存储在栈内存中的表的副本，这与其它本地变量相邻，因此缓存效率可能比静态内存更高。</p><ol start="3"><li>可以使用查找表替代简单的分支，避免分支的预测出错</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example 14.2a</span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> a; <span class="type">int</span> b;</span><br><span class="line">a = (b == <span class="number">0</span>) ? <span class="number">1.0f</span> : <span class="number">2.5f</span>;</span><br></pre></td></tr></table></figure><p>如果我们假设 <code>b</code> 总是 0 或 1，并且它的值可预测性很差，那么使用查找表来代替分支是有利的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example 14.2b</span></span><br><span class="line"><span class="type">float</span> a; <span class="type">int</span> b;</span><br><span class="line"><span class="type">const</span> <span class="type">float</span> OneOrTwo5[<span class="number">2</span>] = &#123;<span class="number">1.0f</span>, <span class="number">2.5f</span>&#125;;</span><br><span class="line">a = OneOrTwo5[b &amp; <span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>将查找表作为 <code>switch</code> 语句的替代尤其有利，因为 <code>switch</code> 语句的可预测性经常较差。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example 14.3a</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">switch</span> (n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Alpha&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Beta&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Gamma&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Delta&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这可以使用查找表来提升效率：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example 14.3b</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> <span class="type">const</span> * <span class="type">const</span> Greek[<span class="number">4</span>] = &#123;</span><br><span class="line">    <span class="string">&quot;Alpha&quot;</span>, <span class="string">&quot;Beta&quot;</span>, <span class="string">&quot;Gamma&quot;</span>, <span class="string">&quot;Delta&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">int</span>)n &lt; <span class="number">4</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Check that index is not out of range</span></span><br><span class="line">    <span class="built_in">printf</span>(Greek[n]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>表的声明有两个 <code>const</code>，因为它们指向的指针和文本都是常量。</p><h3 id="2-边界检查优化"><a href="#2-边界检查优化" class="headerlink" title="2.边界检查优化"></a>2.边界检查优化</h3><p>在<em>C++</em> 中，通常有必要检查数组索引是否超出范围。这常常看起来是这样的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example 14.4a</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> size = <span class="number">16</span>; <span class="type">int</span> i;</span><br><span class="line"><span class="type">float</span> list[size];</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= size)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Error: Index out of range&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    list[i] += <span class="number">1.0f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>i &lt; 0</code> 和 <code>i &gt;= size</code> 这两个比较可以使用一个比较替换：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example 14.4b</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">int</span>)i &gt;= (<span class="type">unsigned</span> <span class="type">int</span>)size)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Error: Index out of range&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    list[i] += <span class="number">1.0f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 <code>i</code> 被解释为无符号整数时，<code>i</code> 可能的负值将以一个较大的正数出现，这将触发错误条件。用一个比较替换两个比较可以加快代码的速度，因为测试一个条件相对比较昂贵，而类型转换根本不会生成额外的代码。</p><p>这个方法可以扩展到一般情况下：你想要检查一个整数是否在一个特定的区间之内：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example 14.5a</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> min = <span class="number">100</span>, max = <span class="number">110</span>; <span class="type">int</span> i;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (i &gt;= min &amp;&amp; i &lt;= max) &#123; ...</span><br></pre></td></tr></table></figure><p>可以修改成：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example 14.5b</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">int</span>)(i - min) &lt;= (<span class="type">unsigned</span> <span class="type">int</span>)(max - min)) &#123; ...</span><br></pre></td></tr></table></figure><p>如果所需区间的长度是 2的幂，则有一种更快的方法来限制整数的范围。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example 14.6</span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> list[<span class="number">16</span>]; <span class="type">int</span> i;</span><br><span class="line">...</span><br><span class="line">list[i &amp; <span class="number">15</span>] += <span class="number">1.0f</span>;</span><br></pre></td></tr></table></figure><p>这需要略微解释一下。<code>i&amp;15</code> 的值肯定在 0 到 15 的区间内。如果 <code>i</code> 在这个区间之外，例如 <code>i = 18</code> ，那么 <code>&amp;</code> 运算符（按位与）将 <code>i</code> 的二进制值截断为 4 位，结果将是 2。结果与 <code>i</code> 除上 16 的余数相同。如果我们不需要错误消息的话，这种方法在数组索引超出范围时可以防止程序出错。需要注意的是，这种方法只适用于2的幂（即2、4、8、16、32、64、……）。通过按位与上$2^{n -1}$，我们可以确保一个数的值小于 $2^n$，并且不是负的。按位与操作隔离数字中有效的低 n 位，并将所有其他位设为零。</p><h3 id="3-使用位运算符一次检查多个值"><a href="#3-使用位运算符一次检查多个值" class="headerlink" title="3 使用位运算符一次检查多个值"></a>3 使用位运算符一次检查多个值</h3><p>位运算符 <code>&amp;</code>， <code>|</code>，<code> ^</code>，<code> ~</code>， <code>&lt;&lt;</code>，<code> &gt;&gt;</code> 可以在一次操作中测试或操作整数的所有位。例如，如果 32 位整数的每个位都有特定的含义，那么可以使用 <code>|</code> 运算符在一个操作中设置多个位；你用 <code>&amp;</code> 运算符清除或遮掩掉多个位。你可以用 <code>^</code> 运算符转换多个位。</p><p><code>&amp;</code> 运算符对于测试单个操作中的多个条件也很有用。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example 14.7a. Testing multiple conditions</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Weekdays</span> &#123;</span><br><span class="line">    Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday</span><br><span class="line">&#125;;</span><br><span class="line">Weekdays Day;</span><br><span class="line"><span class="keyword">if</span> (Day == Tuesday || Day == Wednesday || Day == Friday)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">DoThisThreeTimesAWeek</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本例中的 <code>if</code> 语句有三个条件，它们被实现为三个分支。如果将 <code>Sunday</code>、<code>Monday</code> 等常量定义为 2的幂，则可以将它们合并为一个分支：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example 14.7b. Testing multiple conditions using &amp;</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Weekdays</span> &#123;</span><br><span class="line">    Sunday = <span class="number">1</span>, Monday = <span class="number">2</span>, Tuesday = <span class="number">4</span>, Wednesday = <span class="number">8</span>,</span><br><span class="line">    Thursday = <span class="number">0x10</span>, Friday = <span class="number">0x20</span>, Saturday = <span class="number">0x40</span></span><br><span class="line">&#125;;</span><br><span class="line">Weekdays Day;</span><br><span class="line"><span class="keyword">if</span> (Day &amp; (Tuesday | Wednesday | Friday))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">DoThisThreeTimesAWeek</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过在<strong>例14.7b</strong>中给每个常数的值设置成 一个 2的幂，我们实际上是在使用 <code>Day</code> 中的每一位来表示星期几。我们可以用这种方法定义的常量的最大数量等于整数中的位的数量，通常是 32。在 64 位系统中，我们可以使用 64 位整数，这几乎没有任何性能上的损失。</p><p>在<strong>例 14.7b</strong>中的表达式  <code>(Tuesday | Wednesday | Friday)</code>  被编译器转换成 <code>0x2C</code>，这样的话 <code>if</code> 条件就可以通过一个 <code>&amp;</code> 操作来计算，而这是很快的。如果变量 <code>Day</code> 中设置了 <code>Tuesday</code>、<code>Wednesday</code> 或 <code>Friday</code> 中的的任何位，<code>&amp;</code> 操作的结果将是非零的，因此将被视为真。</p><p>注意布尔运算符 <code>&amp;&amp;</code>， <code>||</code>， <code>!</code> 以及对应的位运算符 <code>&amp;</code>， <code>|</code>， <code>~</code>。布尔运算符产生一个结果，true（1）或 false （0），且第二个操作数只在需要时计算。位运算符在应用于 32位整数时，会产生 32个结果，它们总是对两个操作数进行求值。然而，位运算符的计算速度比布尔运算符快得多，因为只要操作数是整数表达式而不是布尔表达式，它们就不需要使用分支。</p><p>当使用整数作为布尔向量时，位运算符可以做很多事情，而且这些操作非常快。这在包含许多布尔表达式的程序中很有用。无论常量是用 <code>enum</code>、<code>const</code> 还是 <code>#define</code> 定义的，都不会影响性能。</p><h3 id="4-整数乘法"><a href="#4-整数乘法" class="headerlink" title="4.整数乘法"></a>4.整数乘法</h3><p>编译器优化常常会使用移位代替乘法，当然这意味着乘数是2的幂，这在计算地址时会比较有用。</p><p>举个栗子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example 14.8</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> rows = <span class="number">10</span>, columns = <span class="number">8</span>;</span><br><span class="line"><span class="type">float</span> matrix[rows][columns];</span><br><span class="line"><span class="type">int</span> i, j;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">order</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; rows; i++)</span><br><span class="line">&#123;</span><br><span class="line">    j = <span class="built_in">order</span>(i);</span><br><span class="line">    matrix[j][<span class="number">0</span>] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，<code>matrix[j][0]</code> 的地址在内部使用下面的式子计算：</p><p><code>(int)&amp;matrix[0][0] + j * (columns * sizeof(float))</code>。</p><p>现在，要乘以 <code>j</code> 的因子是 <code>(cloumns * sizeof(float)) = 8 * 4 = 32</code>。这是 2的幂，所以编译器可以用 <code>j &lt;&lt; 5</code> 替换 <code>j * 32</code>。如果列的大小不是 2的幂，那么乘法会花费更长的时间。因此，如果以无序方式访问矩阵中的行，则将矩阵中的列数设置为 2的幂是有利的。</p><p>这同样适用于结构体或类元素的数组。如果以无序方式访问对象，则每个对象的大小最好是 2的幂。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example 14.9</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    <span class="type">int</span> UnusedFiller;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">order</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> size = <span class="number">100</span>;</span><br><span class="line">S1 list[size]; <span class="type">int</span> i, j;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">&#123;</span><br><span class="line">    j = <span class="built_in">order</span>(i);</span><br><span class="line">    list[j].a = list[j].b + list[j].c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，我们在结构体中插入了 <code>UnusedFiller</code>，以确保其大小是的 2的幂，以使地址计算的更快。</p><h3 id="5-整数除法"><a href="#5-整数除法" class="headerlink" title="5.整数除法"></a>5.整数除法</h3><p>除法的耗时要长的多，优化策略有：</p><ol><li>整数除以常数比变量快。确保在编译时知道除数的值。</li><li>如果常数是 2的幂的话，整数除法会更快。</li><li>当被除数是无符号时，整数除以常量会更快。</li></ol><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example 14.10</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a, b, c;</span><br><span class="line">a = b / c; <span class="comment">// This is slow</span></span><br><span class="line">a = b / <span class="number">10</span>; <span class="comment">// Division by a constant is faster</span></span><br><span class="line">a = (<span class="type">unsigned</span> <span class="type">int</span>)b / <span class="number">10</span>; <span class="comment">// Still faster if unsigned</span></span><br><span class="line">a = b / <span class="number">16</span>; <span class="comment">// Faster if divisor is a power of 2</span></span><br><span class="line">a = (<span class="type">unsigned</span> <span class="type">int</span>)b / <span class="number">16</span>; <span class="comment">// Still faster if unsigned</span></span><br></pre></td></tr></table></figure><p>相同的准则同样适用于取模运算：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example 14.11</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a, b, c;</span><br><span class="line">a = b % c; <span class="comment">// This is slow</span></span><br><span class="line">a = b % <span class="number">10</span>; <span class="comment">// Modulo by a constant is faster</span></span><br><span class="line">a = (<span class="type">unsigned</span> <span class="type">int</span>)b % <span class="number">10</span>; <span class="comment">// Still faster if unsigned</span></span><br><span class="line">a = b % <span class="number">16</span>; <span class="comment">// Faster if divisor is a power of 2</span></span><br><span class="line">a = (<span class="type">unsigned</span> <span class="type">int</span>)b % <span class="number">16</span>; <span class="comment">// Still faster if unsigned</span></span><br></pre></td></tr></table></figure><p>可以利用这些指导原则，如果可能的话，可以使用一个 2的幂的常数做为除数，如果确定被除数不为负数，可以将被除数更改为无符号。</p><h3 id="6-浮点数除法"><a href="#6-浮点数除法" class="headerlink" title="6.浮点数除法"></a>6.浮点数除法</h3><p>浮点数除法的耗时比加法、减法和乘法（20 - 45个时钟周期）耗时要长得多。尽量减少除法出现的次数。</p><p>1.可以将除法替换为乘法</p><p>浮点数除以一个常数可以用乘以常数的倒数来代替：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example 14.14a</span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> a, b;</span><br><span class="line">a = b / <span class="number">1.2345</span>;</span><br></pre></td></tr></table></figure><p>可以把这个改成：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example 14.14b</span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> a, b;</span><br><span class="line">a = b * (<span class="number">1.</span> / <span class="number">1.2345</span>);<span class="comment">//这个常数倒数的值会在编译时计算出</span></span><br></pre></td></tr></table></figure><p>再比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example 14.15a</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a &gt; b / c)</span><br></pre></td></tr></table></figure><p>有时会被替换成：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example 14.15b</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a * c &gt; b)</span><br></pre></td></tr></table></figure><p>但是要注意这里的陷阱：如果 <code>c &lt; 0</code>，不等式符号必须反转。如果 <code>b</code> 和 <code>c</code> 是整数，除法是不精确的，而乘法是精确的</p><p>2.合并除法</p><p>乘法和除法可以结合在一起，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example 14.16a</span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> y, a1, a2, b1, b2;</span><br><span class="line">y = a1/b1 + a2/b2;</span><br></pre></td></tr></table></figure><p>这里我们可以通过公分母来消去一个除法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example 14.16b</span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> y, a1, a2, b1, b2;</span><br><span class="line">y = (a1*b2 + a2*b1) / (b1*b2);</span><br></pre></td></tr></table></figure><p>3.使用公分母消去除法</p><p>使用公分母的技巧甚至可以用于完全独立的除法。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example 14.17a</span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> a1, a2, b1, b2, y1, y2;</span><br><span class="line">y1 = a1 / b1;</span><br><span class="line">y2 = a2 / b2;</span><br></pre></td></tr></table></figure><p>这可以这样变化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example 14.17b</span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> a1, a2, b1, b2, y1, y2, reciprocal_divisor;</span><br><span class="line">reciprocal_divisor = <span class="number">1.</span> / (b1 * b2);</span><br><span class="line">y1 = a1 * b2 * reciprocal_divisor;</span><br><span class="line">y2 = a2 * b1 * reciprocal_divisor;</span><br></pre></td></tr></table></figure><h3 id="7-避免混合使用float和double"><a href="#7-避免混合使用float和double" class="headerlink" title="7.避免混合使用float和double"></a>7.避免混合使用float和double</h3><p>不管你使用的是单精度还是双精度，浮点数的计算通常花费相同的时间。但是在为 64位操作系统编译的程序和使用指令集<em>SSE2</em> 或更高版本编译的程序中，混合使用单精度和双精度是有代价的。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example 14.18a</span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> a, b;</span><br><span class="line">a = b * <span class="number">1.2</span>; <span class="comment">// Mixing float and double is bad</span></span><br></pre></td></tr></table></figure><p><em>C&#x2F;C++</em> 标准规定所有浮点数常量在默认情况下都是双精度的。 所以在这个例子中， <code>1.2</code> 是一个双精度的常量。因此，在将 <code>b</code> 与双精度常数相乘之前，需要将 <code>b</code> 从单精度转换为双精度，然后再将结果转换回单精度。这些转换需要很长的时间。你可以通过避免转换，来使代码达到 5倍的效率，无论是通过使常数变成单精度或 使 <code>a</code> 和 <code>b</code> 变成双精度的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example 14.18b</span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> a, b;</span><br><span class="line">a = b * <span class="number">1.2f</span>; <span class="comment">// everything is float</span></span><br><span class="line"><span class="comment">// Example 14.18c</span></span><br><span class="line"><span class="type">double</span> a, b;</span><br><span class="line">a = b * <span class="number">1.2</span>; <span class="comment">// everything is double</span></span><br></pre></td></tr></table></figure><p>当为没有<em>SSE2</em> 指令集的旧处理器编译代码时，混合不同的浮点精度不会带来任何损失，但是最好在所有操作数中保持相同的精度，以防代码被移植到另一个平台。</p><h3 id="8-用整数来操作浮点数"><a href="#8-用整数来操作浮点数" class="headerlink" title="8.用整数来操作浮点数"></a>8.用整数来操作浮点数</h3><p>我们只需要反转一个符号位就可以改变浮点数的符号：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example 14.23</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> f;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">&#125; u;</span><br><span class="line">u.i ^= <span class="number">0x80000000</span>; <span class="comment">// flip sign bit of u.f</span></span><br></pre></td></tr></table></figure><p>我们可以将符号位设置成 0以得到绝对值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example 14.24</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> f;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">&#125; u;</span><br><span class="line">u.i &amp;= <span class="number">0x7FFFFFFF</span>; <span class="comment">// set sign bit to zero</span></span><br></pre></td></tr></table></figure><p>我们可以通过测试除符号位以外的所有位来检查浮点数是否为零：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example 14.25</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> f;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">&#125; u;</span><br><span class="line"><span class="keyword">if</span> (u.i &amp; <span class="number">0x7FFFFFFF</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// test bits 0 - 30</span></span><br><span class="line">    <span class="comment">// f is nonzero</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// f is zero</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们对指数部分加上 $n$ 就可以将一个非零浮点数乘上 $2^n$：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example 14.26</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> f;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">&#125; u;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">if</span> (u.i &amp; <span class="number">0x7FFFFFFF</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// check if nonzero</span></span><br><span class="line">    u.i += n &lt;&lt; <span class="number">23</span>; <span class="comment">// add n to exponent</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>例 14.26</strong>不会检查溢出，而且只有$n$是整数时才能有用。当没有下溢风险时，你可以对指数部分减去 $n$ 以达到除以 $2^n$的目的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example 14.27</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> f;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">&#125; u, v;</span><br><span class="line"><span class="keyword">if</span> (u.i &gt; v.i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// u.f &gt; v.f if both positive</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 在 <strong>例 14.27</strong>假设我们知道 <code>u.f</code>，<code>v.f</code>  都是正的。如果两者都是负数，或者其中一个为 0，另一个为 -0（符号位为0），则会失败。</p><p>我们可以将符号位移出来比较绝对值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example 14.28</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> f;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line">&#125; u, v;</span><br><span class="line"><span class="keyword">if</span> (u.i * <span class="number">2</span> &gt; v.i * <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// abs(u.f) &gt; abs(v.f)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>例 14.28</strong>中乘以 2 将移出符号位，使其余位表示浮点数绝对值的单调递增函数。</p><p>我们可以通过设置分数部分的位将在区间 $0 &lt;&#x3D; n &lt; 2^{23}$的整数转换成在区间 $[1.0, 2.0)$的浮点数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example 14.29</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> f;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">&#125; u;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">u.i = (n &amp; <span class="number">0x7FFFFF</span>) | <span class="number">0x3F800000</span>; <span class="comment">// Now 1.0 &lt;= u.f &lt; 2.0</span></span><br></pre></td></tr></table></figure><p>该方法对随机数生成器非常有用。</p><p>通常，如果浮点变量存储在内存中，那么以整数的形式访问它会更快，但如果它是寄存器变量，则不会更快。<code>union</code> 强制变量存储在内存中，至少是临时的。因此，如果相同变量使用寄存器可以使其它临近代码获益时，那么使用上述示例中的方法将没有好处。</p><p>在这些例子中，我们使用 <code>union</code> 而不是指针的类型转换，是因为这种方法更安全。指针的类型转换可能不适用于遵循<em>标准 C</em> 严格的别名规则的编译器，该规则指定不同类型的指针不能指向同一对象，<code>char</code> 指针除外。</p><p>上面的例子都使用单精度。在 32位系统中使用双精度浮点数会变得更复杂。双精度浮点数用 64个位表示，但是 32 位系统不支持 64位整数。许多 32位系统允许你定义 64位整数，但是它们实际上用两个32位整数来表示，效率较低。你可以使用双精度浮点数的高 32位，它允许你访问符号位、指数和分数中的高几位。例如，可以这样测试双精度浮点数的符号：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example 14.23b</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> d;</span><br><span class="line">    <span class="type">int</span> i[<span class="number">2</span>];</span><br><span class="line">&#125; u;</span><br><span class="line"><span class="keyword">if</span> (u.i[<span class="number">1</span>] &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// test sign bit</span></span><br><span class="line">    <span class="comment">// u.d is negative or -0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不建议通过修改 <code>double</code> 类型的一半二进制位来修改它，比如，如果你想要通过 <code>u.i[1] ^= 0x80000000</code> 来反转上述示例中的符号位的话，但这很在 CPU 中产生存储转发延迟（参见手册3：“The microarchitecture of Intel, AMD and VIA CPUs”）。在64 位系统中，可以通过使用 64位整数而不是两个 32位整数表示 <code>double</code> 来避免这种情况。</p><p>访问双精度浮点数中的 32位的另一个问题是，它不能移植到大端存储的系统中。因此，如果要具有大端存储的其他平台上实现，<strong>例 14.23b</strong> 和 <strong>例 14.30</strong> 将需要修改。所有<em>x86</em> 平台（<em>Windows</em>、<em>Linux</em>、<em>BSD</em>、基于<em>Intel CPU</em> 的<em>Mac OS</em> 等）都使用小端存储，但其他系统可能使用大端存储（如<em>PowerPC</em>）。</p><p>我们可以通过比较 32 - 62 位来近似比较双精度浮点数。这在高斯消元法中求矩阵中值最大的主元是很有用的。<strong>例 14.28</strong> 中的方法在主元搜寻中可以这么使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example 14.30</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> size = <span class="number">100</span>;</span><br><span class="line"><span class="comment">// Array of 100 doubles:</span></span><br><span class="line"><span class="keyword">union</span> &#123;<span class="type">double</span> d; <span class="type">unsigned</span> <span class="type">int</span> u[<span class="number">2</span>]&#125; a[size];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> absvalue, largest_abs = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> i, largest_index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get upper 32 bits of a[i] and shift out sign bit:</span></span><br><span class="line">    absvalue = a[i].u[<span class="number">1</span>] * <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// Find numerically largest element (approximately):</span></span><br><span class="line">    <span class="keyword">if</span> (absvalue &gt; largest_abs)</span><br><span class="line">    &#123;</span><br><span class="line">        largest_abs = absvalue;</span><br><span class="line">        largest_index = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>例 14.30</strong> 找到数组中 数字（除去符号位）最大（或差不多最大的）的元素。它可能无法区分相对差小于$2^{-20}$的元素，但这对于寻找合适的主元来说是足够准确的。整数比较可能比浮点比较更快。在大的端系统中，你必须用 <code>u[0]</code> 替换 <code>u[1]</code>。</p><h3 id="9-静态库和动态库"><a href="#9-静态库和动态库" class="headerlink" title="9.静态库和动态库"></a>9.静态库和动态库</h3><p>先比较一下静态库和动态库</p><p>静态链接相对于动态链接的优点是：</p><ol><li>使用静态链接，应用程序只需要包含库中所需要的部分，而使用动态链接则需要将整个库（或至少库的大部分）加载到内存中，即使只需要库中的一个函数。</li><li>当使用静态链接时，所有代码都包含在一个可执行文件中。而使用动态链接使得程序启动时必须加载多个文件。</li><li>调用动态库中的函数要比调用在静态链接库中的函数花费更长的时间，因为它需要通过导入表中的指针进行额外的跳转，还可能需要在过程链接表（<em>PLT</em> ）中进行查找。</li><li>当代码分布在多个动态库之中时，内存空间变得更加碎片化。动态库加载在可被内存页大小（4096）整除的圆形内存地址（round memory addresses）处。这将使所有动态库争用相同的高速缓存线路。这降低了代码缓存和数据缓存的效率。</li><li>动态库在某些系统中效率可能会较低，因为需要位置无关代码（参见下面的内容）。</li><li>如果使用动态链接，安装使用相同动态库的更新版本的第二个应用程序，可以改变第一个应用程序的行为，但是如果使用静态链接，则不能改变第一个应用程序的行为。</li></ol><p>使用动态链接的优点是：</p><ol><li>同时运行的多个应用程序可以共享相同的动态库，无需将库的多个实例加载到内存中。这适用于同时运行多个进程的服务器。实际上，只有代码节和只读数据节可以共享。任何可写数据部分，每个进程都需要一个单独的实例。</li><li>无需更新调用程序，动态链接库就可以更新到新的版本。</li><li>动态链接库可以被不支持静态链接的编程语言调用。</li><li>使用动态链库可以用于为已有程序制作插件来添加新的功能</li></ol><p>  显然静态链接更适合于速度关键型函数。许多函数库都有静态和动态版本。如果速度很重要，则建议使用静态版本。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h2 id=&quot;十一、具体优化策略&quot;&gt;&lt;a href=&quot;#十一、具体优化策略&quot; class=&quot;headerlink&quot; title=&quot;十一、具体优化策略&quot;&gt;&lt;/a&gt;十一、具体优化策略&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;跳过了anger手册中关于cpu</summary>
        
      
    
    
    
    
    <category term="hpc" scheme="https://mightcoder.com/tags/hpc/"/>
    
    <category term="cpp" scheme="https://mightcoder.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>optimizing_cpp(12)</title>
    <link href="https://mightcoder.com/2022/04/05/optimizing-cpp-12/"/>
    <id>https://mightcoder.com/2022/04/05/optimizing-cpp-12/</id>
    <published>2022-04-05T13:11:37.000Z</published>
    <updated>2022-07-15T08:13:03.059Z</updated>
    
    <content type="html"><![CDATA[<h2 id="十二、元编程"><a href="#十二、元编程" class="headerlink" title="十二、元编程"></a>十二、元编程</h2><p>元编程：普通编程操纵数据，元编程操纵其他编程语言，元编程指生成其他程序的程序。</p><p>在讲元编程前，必须补充模板编程的知识，在讲模板编程前，我想先补充一下宏编程的基础知识，因为两者有许多相似之处（我太菜了，不会的太多了）</p><h3 id="1-宏编程与预处理"><a href="#1-宏编程与预处理" class="headerlink" title="1.宏编程与预处理"></a>1.宏编程与预处理</h3><p>宏编程继承自c语言，在预处理时被替换。</p><p>预处理过程的第一步是进行一些翻译处理，包括讲源码中出现的字符映射到源字符集，会同时处理多字节序列和三字符序列（三字符序列的介绍<a href="https://www.cnblogs.com/dzhanjie/archive/2011/05/09/2040882.html">三字符序列 - 逛博 - 博客园 (cnblogs.com)</a>）</p><p>接着把物理行转换为逻辑行，示例如下：</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/202204051849713.png" alt="image-20220405184937602"><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/202204051849880.png" alt="image-20220405184947815"></p><p>然后，编译器讲文本划分为预处理记号序列、空白序列和注释序列，使用一个空格替换注释序列，使用一个空格替换所有的空白字符序列。</p><p>最后进入预处理阶段，预处理器查找一行中以#开头的预处理指令。</p><h4 id="1-1-define"><a href="#1-1-define" class="headerlink" title="1.1#define"></a>1.1#define</h4><p>define作用是定义常量，在预处理阶段将代码中的宏替换为替换体。</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/202204051900127.png" alt="image-20220405190044058"></p><p>需要注意的是如果宏中还包含宏，会再次替换，字符串内的不会被替换。</p><p>宏分两种，类对象宏：宏代表值，类函数宏：宏代表函数</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/202204051908193.png" alt="image-20220405190818123"></p><p>如果要在宏函数的字符串中包含宏参数怎么办？</p><p>在字符串内使用#运算符：</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/202204051914842.png" alt="image-20220405191449772"></p><p>如果要在宏函数中实现记号组合怎么办？</p><p>使用##运算符粘合两个记号</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/202204051916898.png" alt="image-20220405191603835"></p><h4 id="1-2-undef"><a href="#1-2-undef" class="headerlink" title="1.2#undef"></a>1.2#undef</h4><p>取消已定义的#define指令</p><h4 id="1-3-ifdef-else-endif"><a href="#1-3-ifdef-else-endif" class="headerlink" title="1.3#ifdef #else #endif"></a>1.3#ifdef #else #endif</h4><p>这几个主要用于条件编译</p><p>#ifdef指如果已经用define定义过了就执行下面的指令，如果没有就执行#else里的指令，直到#endif</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/202204051928547.png" alt="image-20220405192830479"></p><h4 id="1-4-ifndef"><a href="#1-4-ifndef" class="headerlink" title="1.4#ifndef"></a>1.4#ifndef</h4><p>ifndef与ifdef有些类似，只不过是如果未定义就执行下面的指令，主要用于防止相同的宏被重复定义</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/202204051930063.png" alt="image-20220405193031000"></p><h4 id="1-5-if-elif-else"><a href="#1-5-if-elif-else" class="headerlink" title="1.5#if #elif #else"></a>1.5#if #elif #else</h4><p>与逻辑语句中的if else类似</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/202204051933736.png" alt="image-20220405193308657"></p><p>另外，还可以用<code>#if defined(VAX)</code> 代替 <code>#ifdef VAX</code></p><h4 id="1-6预定义宏"><a href="#1-6预定义宏" class="headerlink" title="1.6预定义宏"></a>1.6预定义宏</h4><p>c语言中还规定了一些预定义宏：</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/202204051934867.png" alt="image-20220405193445791"></p><h4 id="1-7-line-error"><a href="#1-7-line-error" class="headerlink" title="1.7#line #error"></a>1.7#line #error</h4><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/202204051938802.png" alt="image-20220405193856682"></p><h4 id="1-8-pragma"><a href="#1-8-pragma" class="headerlink" title="1.8#pragma"></a>1.8#pragma</h4><p>pragma将编译器指令放入源代码中</p><h3 id="2-元编程"><a href="#2-元编程" class="headerlink" title="2.元编程"></a>2.元编程</h3><p>c++的元编程基于模板编程，对模板编程不熟悉的可以看下这个链接，里面不光详细的介绍了模板编程的语法，还系统的介绍了元编程</p><p><a href="https://github.com/wuye9036/CppTemplateTutorial#11-template-class%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95">wuye9036&#x2F;CppTemplateTutorial: 中文的C++ Template的教学指南。与知名书籍C++ Templates不同，该系列教程将C++ Templates作为一门图灵完备的语言来讲授，以求帮助读者对Meta-Programming融会贯通。(正在施工中) (github.com)</a></p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h2 id=&quot;十二、元编程&quot;&gt;&lt;a href=&quot;#十二、元编程&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    
    <category term="hpc" scheme="https://mightcoder.com/tags/hpc/"/>
    
    <category term="cpp" scheme="https://mightcoder.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>optimizing_cpp(9)</title>
    <link href="https://mightcoder.com/2022/04/05/optimizing-cpp-9/"/>
    <id>https://mightcoder.com/2022/04/05/optimizing-cpp-9/</id>
    <published>2022-04-05T13:11:37.000Z</published>
    <updated>2022-07-15T08:13:03.053Z</updated>
    
    <content type="html"><![CDATA[<h2 id="九、乱序执行"><a href="#九、乱序执行" class="headerlink" title="九、乱序执行"></a>九、乱序执行</h2><p>乱序执行的定义：现代cpu可以乱序执行指令或者同时执行多个操作，因为一个cpu上有多个计算核心可以同时计算。</p><p>乱序执行可以提高效率，但是当存在依赖关系链时（第三章第六节），cpu无法乱序执行，顺序结构中依赖关系链比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> a, b, c, d, y;</span><br><span class="line">y = a + b + c + d;</span><br></pre></td></tr></table></figure><p>这个表达式将会以<code>((a+b)+c)+d</code>形式计算，编译器不会优化，因为交换计算位置可能会导致溢出（可以回顾浮点数相关的知识（第六章第一节）），我们可以手动取消依赖关系链。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> a, b, c, d, y;</span><br><span class="line">y = (a + b) + (c + d);</span><br></pre></td></tr></table></figure><p>这样就可以同时计算<code>(a+b)</code>和<code>(c+d)</code>。</p><p>还有一种常见的依赖链是循环依赖链，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> size = <span class="number">100</span>;</span><br><span class="line"><span class="type">float</span> list[size], sum = <span class="number">0</span>; <span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">    sum += list[i];</span><br></pre></td></tr></table></figure><p>这里每一次循环都必须依赖上一次循环的结果，优化这种循环可以可以采用展开循环将依赖链一分为二</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example 11.2b</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> size = <span class="number">100</span>;</span><br><span class="line"><span class="type">float</span> list[size], sum1 = <span class="number">0</span>, sum2 = <span class="number">0</span>; <span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i += <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">    sum1 += list[i];</span><br><span class="line">    sum2 += list[i+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">sum1 += sum2;</span><br></pre></td></tr></table></figure><p>如果微处理器从时间 T 到 T+5 对<code>sum1</code>做加法，那么它可以从时间 T+1 到 T+6 对 <code>sum2</code> 做加法，整个循环只需要 256个时钟周期。当然如果size为奇数，要在循环外把最后一位再加上。</p><p>当然上面的栗子并没有消除循环依赖链，自然也无法使用乱序执行，如果可以的话应当尽量避免出现循环依赖链。</p><p>如果没有循环依赖链，另一个提高效率的方式是使用寄存器作为中间存储，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example 11.3</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> size = <span class="number">100</span>; <span class="type">int</span> i;</span><br><span class="line"><span class="type">float</span> a[size], b[size], c[size];</span><br><span class="line"><span class="type">float</span> <span class="keyword">register</span> temp;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">&#123;</span><br><span class="line">    temp = a[i] + b[i];</span><br><span class="line">    c[i] = temp * temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具有无序功能的微处理器非常智能。他们可以检测到上例中循环的一次迭代中的寄存器临时值独立于前一次迭代中的值。这允许它在计算完前一个值之前开始计算一个新的临时值。它通过为 <code>temp</code> 分配一个新的物理寄存器来实现这一点，即使在机器码中出现的逻辑寄存器是相同的。这叫做寄存器重命名。<em>CPU</em>可以保留同一逻辑寄存器的许多重命名实例。使cpu能重叠循环迭代计算的条件为：</p><ol><li>没有循环依赖链。</li><li>所有的中间结果都应该保存在寄存器中，而不是内存中。重命名机制只对寄存器有效，而对内存或缓存中的变量无效。在上例中，即使没有 <code>register</code> 关键字，大多数编译器也会使 <code>temp</code> 成为寄存器变量。（<strong>CodeGear编译器</strong>不能生成浮点寄存器变量，但会在内存中保存临时变量。这会阻止 <em>CPU</em> 的重叠计算）</li><li>循环分支需要可以被预测。如果重复计数很大或恒定，则不存在此问题。如果循环计数很小且不断变化，那么CPU可能偶尔会预测循环分支已经退出了，而实际上它没有，因此无法开始下一个计算。然而，乱序执行机制允许<em>CPU</em>提前增加循环计数器，这样它就可以在判断错误之前及时发现。因此，你不必太担心这种情况。</li></ol><p>乱序执行通常是自动的，开发者只需要保证没有依赖链就行。除此之外，还可以做些别的操作提高乱序执行的效率，比如将浮点加法与浮点乘法混合使用、将简单整数与向量整数操作混合使用、将数学计算与内存访问混合使用也有很大的好处。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h2 id=&quot;九、乱序执行&quot;&gt;&lt;a href=&quot;#九、乱序执行&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    
    <category term="hpc" scheme="https://mightcoder.com/tags/hpc/"/>
    
    <category term="cpp" scheme="https://mightcoder.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>optimizing_cpp(8)</title>
    <link href="https://mightcoder.com/2022/04/05/optimizing-cpp-8/"/>
    <id>https://mightcoder.com/2022/04/05/optimizing-cpp-8/</id>
    <published>2022-04-05T13:11:37.000Z</published>
    <updated>2022-07-15T08:13:03.056Z</updated>
    
    <content type="html"><![CDATA[<h2 id="八、多线程"><a href="#八、多线程" class="headerlink" title="八、多线程"></a>八、多线程</h2><p>有三种方法可以并行地执行任务：</p><ol><li>使用多个 <em>CPU</em> 或 <em>多 核 CPU</em>，如本章所述。</li><li>使用现代 <em>CPU</em> 的乱序执行能力，如第9章所述。</li><li>使用现代 <em>CPU</em> 的向量操作，如第10章所述。</li></ol><p>在决定并行处理是否有利时，区分粗粒度并行和细粒度并行非常重要。粗粒度并行是指一序列的操作可以独立于其他任务的情况（多个线程执行不同的任务）。细粒度并行是指任务被划分为许多小的子任务（多个线程共同执行一个任务），但是在与其他子任务进行必要的协调之前，不可能在特定的子任务上工作很长时间。</p><p>由于不同内核之间的通信和同步比较慢，因此粗粒度并行比使用细粒度并行效率更高。如果粒度太细，那么将任务拆分为多个线程是没有优势的。无序执行和向量操作是利用细粒度并行的更有用的方法。</p><p>在使用多线程时，需要关注缓存冲突和缓存一致性问题。</p><p>缓存冲突：多个 <em>CPU</em> 内核或逻辑处理器通常共享相同的缓存，至少在最后一级缓存中是这样，在某些情况下甚至共享相同的一级缓存。共享相同缓存的优点是线程之间的通信变得更快，并且线程可以共享相同的代码和只读数据。缺点是，如果线程使用不同的内存区域，缓存就会被填满，如果线程写入相同的内存区域，就会发生缓存竞争。</p><p>缓存一致性问题：如果多个线程同时写入一个缓存行，由于要保证缓存的一致性，这两个线程会多次从内存中读写数据到缓存，效率会极低甚至不如单线程。</p><p>看个栗子:</p><blockquote><p>接下来，我们来看一下多核下的性能问题，参看如下的代码。两个线程在操作一个数组的两个不同的元素（无需加锁），线程循环1000万次，做加法操作。在下面的代码中，我高亮了一行，就是<code>p2</code>指针，要么是<code>p[1]</code>，或是 <code>p[30]</code>，理论上来说，无论访问哪两个数组元素，都应该是一样的执行时间。</p><p><strong>void</strong> fn (<strong>int</strong>* data) {</p><p>​    <strong>for</strong>(<strong>int</strong> i &#x3D; 0; i &lt; 10<em>1024</em>1024; ++i)</p><p>​        *data +&#x3D; rand();</p><p>}</p><p><strong>int</strong> p[32];</p><p><strong>int</strong> *p1 &#x3D; &amp;p[0];</p><p><strong>int</strong> *p2 &#x3D; &amp;p[1]; &#x2F;&#x2F; int *p2 &#x3D; &amp;p[30];</p><p>thread t1(fn, p1);</p><p>thread t2(fn, p2);</p><p>然而，并不是，在我的机器上执行下来的结果是：</p><ul><li>对于 <code>p[0]</code> 和 <code>p[1]</code> ：560ms</li><li>对于 <code>p[0]</code> 和 <code>p[30]</code>：104ms</li></ul><p>这是因为 <code>p[0]</code> 和 <code>p[1]</code> 在同一条 Cache Line 上，而 <code>p[0]</code> 和 <code>p[30]</code> 则不可能在同一条Cache Line 上 ，CPU的缓存最小的更新单位是Cache Line，所以，<strong>这导致虽然两个线程在写不同的数据，但是因为这两个数据在同一条Cache Line上，就会导致缓存需要不断进在两个CPU的L1&#x2F;L2中进行同步，从而导致了5倍的时间差异</strong>。</p><p>接下来，我们再来看一下另外一段代码：我们想统计一下一个数组中的奇数个数，但是这个数组太大了，我们希望可以用多线程来完成这个统计。下面的代码中，<strong>我们为每一个线程传入一个 id ，然后通过这个 id 来完成对应数组段的统计任务。这样可以加快整个处理速度</strong>。</p><p><strong>int</strong> total_size &#x3D; 16 * 1024 * 1024; &#x2F;&#x2F;数组长度</p><p><strong>int</strong>* test_data &#x3D; new test_data[total_size]; &#x2F;&#x2F;数组</p><p><strong>int</strong> nthread &#x3D; 6; &#x2F;&#x2F;线程数（因为我的机器是6核的）</p><p><strong>int</strong> result[nthread]; &#x2F;&#x2F;收集结果的数组</p><p><strong>void</strong> thread_func (<strong>int</strong> id) {</p><p>​    result[id] &#x3D; 0;</p><p>​    <strong>int</strong> chunk_size &#x3D; total_size &#x2F; nthread + 1;</p><p>​    <strong>int</strong> start &#x3D; id * chunk_size;</p><p>​    <strong>int</strong> end &#x3D; min(start + chunk_size, total_size);</p><p>​    <strong>for</strong> ( <strong>int</strong> i &#x3D; start; i &lt; end; ++i ) {</p><p>​        <strong>if</strong> (test_data[i] % 2 !&#x3D; 0 ) ++result[id];</p><p>​    }</p><p>}</p><p>然而，在执行过程中，<strong>你会发现，6个线程居然跑不过1个线程</strong>。因为根据上面的例子你知道 <code>result[]</code> 这个数组中的数据在一个Cache Line中，所以，所有的线程都会对这个 Cache Line 进行写操作，导致所有的线程都在不断地重新同步 <code>result[]</code> 所在的 Cache Line，所以，导致 6 个线程还跑不过一个线程的结果。这叫 <strong>False Sharing</strong>。</p><p>优化也很简单，使用一个线程内的变量。</p><p><strong>void</strong> thread_func (<strong>int</strong> id) {</p><p>​    result[id] &#x3D; 0;</p><p>​    <strong>int</strong> chunk_size &#x3D; total_size &#x2F; nthread + 1;</p><p>​    <strong>int</strong> start &#x3D; id * chunk_size;</p><p>​    <strong>int</strong> end &#x3D; min(start + chunk_size, total_size);</p><p>​    <strong>int</strong> c &#x3D; 0; &#x2F;&#x2F;使用临时变量，没有cache line的同步了</p><p>​    <strong>for</strong> ( <strong>int</strong> i &#x3D; start; i &lt; end; ++i ) {</p><p>​        <strong>if</strong> (test_data[i] % 2 !&#x3D; 0 ) ++c;</p><p>​    }</p><p>​    result[id] &#x3D; c;</p><p>}</p><p>我们把两个程序分别在 1 到 32 个线程上跑一下，得出的结果画一张图如下所示（横轴是线程数，纵轴是完成统的时间，单位是微秒）：</p><p><img src="https://coolshell.cn/wp-content/uploads/2020/03/false.sharing-1024x643.png" alt="img"></p><p>上图中，我们可以看到，灰色的曲线就是第一种方法，橙色的就是第二种（用局部变量的）方法。当只有一个线程的时候，两个方法相当，基本没有什么差别，但是在线程数增加的时候的时候，你会发现，第二种方法的性能提高的非常快。直到到达6个线程的时候，开始变得稳定（前面说过，我的CPU是6核的）。而第一种方法无论加多少线程也没有办法超过第二种方法。因为第一种方法不是CPU Cache 友好的。也就是说，第二种方法，<strong>只要我的CPU核数足够多，就可以做到线性的性能扩展，让每一个CPU核都跑起来，而第一种则不能</strong>。</p><p>来自酷壳网上的栗子）</p></blockquote><p>只读的数据可以在多个线程之间共享，而可以修改的数据应该被每个线程单独存储。使数据特定于线程的最简单方法是在线程函数中声明它，使其为线程本地的，以便将其存储在堆栈中（在每个线程执行函数内部声明的临时变量）。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h2 id=&quot;八、多线程&quot;&gt;&lt;a href=&quot;#八、多线程&quot; class=&quot;headerlink&quot; title=&quot;八、多线程&quot;&gt;&lt;/a&gt;八、多线程&lt;/h2&gt;&lt;p&gt;有三种方法可以并行地执行任务：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用多个 &lt;em&gt;CPU&lt;/em&gt; 或 &lt;em&gt;多 核</summary>
        
      
    
    
    
    
    <category term="hpc" scheme="https://mightcoder.com/tags/hpc/"/>
    
    <category term="cpp" scheme="https://mightcoder.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>optimizing_cpp(7)</title>
    <link href="https://mightcoder.com/2022/04/05/optimizing-cpp-7/"/>
    <id>https://mightcoder.com/2022/04/05/optimizing-cpp-7/</id>
    <published>2022-04-05T13:01:37.000Z</published>
    <updated>2022-07-15T08:13:03.057Z</updated>
    
    <content type="html"><![CDATA[<h2 id="七、内存访问优化"><a href="#七、内存访问优化" class="headerlink" title="七、内存访问优化"></a>七、内存访问优化</h2><h3 id="1-缓存"><a href="#1-缓存" class="headerlink" title="1.缓存"></a>1.缓存</h3><p>优化访存主要就是优化cahce的访问，因此先系统复习下关于cache的相关知识。</p><p>现代cpu大多拥有三级缓存L1L2L3。</p><p><img src="https://coolshell.cn/wp-content/uploads/2020/02/cache.architecture.png" alt="di"></p><ul><li>L1缓存分成两种，一种是指令缓存，一种是数据缓存。L2缓存和L3缓存不分指令和数据。</li><li>L1和L2缓存在每一个CPU核中，L3则是所有CPU核心共享的内存。</li><li>L1、L2、L3的越离CPU近就越小，速度也越快，越离CPU远，速度也越慢。</li></ul><p>三级缓存和RAM读取速度的对比：</p><ul><li>L1 的存取速度：<strong>4 个CPU时钟周期</strong></li><li>L2 的存取速度： <strong>11 个CPU时钟周期</strong></li><li>L3 的存取速度：<strong>39 个CPU时钟周期</strong></li><li>RAM内存的存取速度<strong>：107 个CPU时钟周期</strong></li></ul><p><strong>cache与RAM的映射方式</strong>：</p><p>直接映射：一个cache块对应多个内存块，一个内存块只能对应一个cache块</p><p>全相联映射：任何一个内存块都能对应任何一个cache块，但是比较块号所需时间长</p><p>组相联映射：将前两者结合起来，cache分为多个每个组内有多个块，内存也分块，每一块对应一cahce组，可以占用组内的任意cache块</p><p>离cpu最近的可以直接相联，较近的可以组相联，最远的可以全相联，距离越远对cache速度的要求就越低对利用率的强调就越高。</p><p>cache的最小存储单位：cache line即上面所说的块，一般大小为64byte（512位）</p><p>在组相联映射中（N-wayassociative cache fill）将N个cache line绑成一组，先找到相关的组，再在这个组中找到相关的cacheline</p><p>我们举个栗子：</p><p>Intel 大多数处理器的L1 Cache都是32KB，8-Way 组相联，Cache Line 是64 Bytes。这意味着，</p><ul><li>32KB的可以分成，32KB &#x2F; 64 &#x3D; 512 条 Cache Line。</li><li>因为有8 Way，于是会每一Way 有 512 &#x2F; 8 &#x3D; 64 条 Cache Line。</li><li>于是每一way就有 64 x 64 &#x3D; 4096 Bytes 的内存。</li></ul><p>为了方便索引内存地址，</p><ul><li><strong>Tag</strong>：每条 Cache Line 前都会有一个独立分配的 24 bits来存的 tag，其就是内存地址的前24bits</li><li><strong>Index</strong>：内存地址后续的6个bits则是在这一Way的是Cache Line 索引，2^6 &#x3D; 64 刚好可以索引64条Cache Line</li><li><strong>Offset</strong>：再往后的6bits用于表示在Cache Line 里的偏移量</li></ul><p>如下图所示：（图片来自《<a href="https://manybutfinite.com/post/intel-cpu-caches/">Cache: a place for concealment and safekeeping</a>》）</p><p>当拿到一个内存地址的时候，先拿出中间的 6bits 来，找到是哪组。</p><p><img src="https://coolshell.cn/wp-content/uploads/2020/03/L1CacheExample.png"></p><p>然后，在这一个 8 组的 cache line 中，再进行 O(n) n&#x3D;8 的遍历，主是要匹配前 24bits 的 tag。如果匹配中了，就算命中，如果没有匹配到，那就是 cache miss，如果是读操作，就需要进向后面的缓存进行访问了。L2&#x2F;L3 同样是这样的算法。而淘汰算法有两种，一种是随机一种是 LRU。现在一般都是以 LRU 的算法（通过增加一个访问计数器来实现）</p><p><img src="https://coolshell.cn/wp-content/uploads/2020/03/selectingCacheLine.png" alt="img"></p><p>这也意味着：</p><ul><li>L1 Cache 可映射 36bits 的内存地址，一共 2^36 &#x3D; 64GB的内存</li><li>当CPU要访问一个内存的时候，通过这个内存中间的6bits 定位是哪个set，通过前 24bits 定位相应的Cache Line。</li><li>就像一个hash Table的数据结构一样，先是O(1)的索引，然后进入冲突搜索。</li><li>因为中间的 6bits 决定了一个同一个set，所以，对于一段连续的内存来说，每隔4096的内存会被放在同一个组内，导致缓存冲突(解释一下，随着地址的增加，后12位数字会不断循环，间隔就是2的12次方4096，所以每隔4096的地址就会缓存冲突)</li></ul><p>此外，当有数据没有命中缓存的时候，CPU就会以最小为Cache Line的单元向内存更新数据。当然，CPU并不一定只是更新64Bytes，因为访问主存实在是太慢了，所以，一般都会多更新一些。好的CPU会有一些预测的技术，如果找到一种pattern的话，就会预先加载更多的内存，包括指令也可以预加载。这叫 Prefetching 技术 （参看，Wikipedia 的 <a href="https://en.wikipedia.org/wiki/Cache_prefetching">Cache Prefetching</a> 和 <a href="http://compas.cs.stonybrook.edu/~nhonarmand/courses/sp16/cse502/slides/13-prefetch.pdf">纽约州立大学的 Memory Prefetching</a>）。比如，你在for-loop访问一个连续的数组，你的步长是一个固定的数，内存就可以做到prefetching。</p><p><strong>缓存的一致性问题</strong></p><p>cache的写策略：</p><ul><li>write back(写回)写到cache，等需要时再flush到内存中</li><li>write throuth(写直达)直接写道内存和cache中</li></ul><p>为了提高写的性能，一般采用write back</p><p>缓存一致性协议：</p><ul><li>监听cache一致性协议：当多个核共享总线时，总线上传递的信号都能被连接到总线的所有核“看”到。当某个核更新它cache中x的副本时，它将更新消息在总线上广播，若核1在监听总线，它就会知道x已经更新并且将自己cache中x的副本标记为非法的。实际情况是广播会通知其它核包含x的整个Cache行已经更新。</li><li>基于目录的cache一致性协议：使用一个叫目录的数据结构来存储每个内存行的状态。一般的，这个数据结构是分布式的。当一个高速缓存行被读入时，如核0的cache，与这个高速缓存行相对应的目录项就会更新，表示核0有这个行的副本。当一个变量需要更新时，就会查询目录，并将所有包含该变量高速缓存行设置为非法。</li></ul><p><a href="https://coolshell.cn/articles/20793.html">与程序员相关的CPU缓存知识 | 酷 壳 - CoolShell</a>酷壳的这篇文章还有示例，可以好好看一下，加深理解。</p><h3 id="2-一起使用的函数应该放在一起"><a href="#2-一起使用的函数应该放在一起" class="headerlink" title="2.一起使用的函数应该放在一起"></a>2.一起使用的函数应该放在一起</h3><p>如果在代码内存中使用的函数彼此接近，那么代码缓存的工作效率最高。函数通常按照它们在源代码中出现的顺序存储。因此，最好将代码中最关键部分中使用的函数集中在同一个源文件中，这些函数彼此相邻。将经常使用的函数与很少使用的函数分开，并将很少使用的分支（如错误处理）放在函数的末尾或单独的函数中。</p><p>有时，为了模块化，函数被保存在不同的源文件中。例如，在一个源文件中有父类的成员函数，在另一个源文件中有派生类的成员函数，这样做可能比较方便。如果父类和派生类的成员函数是在程序的相同关键部分被调用的，那么在程序内存中保持这两个模块的连续是有利的。这可以通过控制模块链接的顺序来实现。链接顺序通常是模块在项目窗口或<code>makefile</code>中出现的顺序。你可以通过向链接器请求映射文件来检查内存中函数的顺序。映射文件告诉每个函数相对于程序开始的地址。映射文件包含从静态库链接（*.lib<em>或</em>.a* ）的库函数的地址，但不是动态库（*.dll<em>或</em>.so*)。没有一种简单的方法可以控制动态链接库函数的地址。</p><h3 id="3-一起使用的变量应该放在一起"><a href="#3-一起使用的变量应该放在一起" class="headerlink" title="3.一起使用的变量应该放在一起"></a>3.一起使用的变量应该放在一起</h3><p>如果cpu缓存没有命中，那么代价会非常高，所以经常一起使用的数据片段应该在内存中彼此靠近，以便cpu缓存能够同时命中。如果可能，避免全局变量和静态变量，并避免动态内存分配（<code>new</code>和<code>delete</code>）。</p><p>如果代码中有大数据结构，那么存储数据的顺序可能非常重要。例如，如果一个程序有两个数组，<code>a</code> 和 <code>b</code>，并且元素的访问顺序是<code>a[0]</code>， <code>b[0]</code>， <code>a[1]</code>， <code>b[1]</code>，…，然后，你可以通过将数据组织为结构体的数组来提高性能：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example 9.1a</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Func</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> size = <span class="number">1024</span>;</span><br><span class="line"><span class="type">int</span> a[size], b[size], i;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">&#123;</span><br><span class="line">    b[i] = <span class="built_in">Func</span>(a[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果按如下方法组织数据，那么这个例子中的数据可以在内存中被按顺序访问：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example 9.1b</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Func</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> size = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Sab</span> &#123;<span class="type">int</span> a; <span class="type">int</span> b;&#125;;</span><br><span class="line">Sab ab[size];</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">&#123;</span><br><span class="line">    ab[i].b = <span class="built_in">Func</span>(ab[i].a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<strong>例 9.1b</strong>中这样的数据结构，程序代码中将不会有额外的开销。相反的，代码将变的更加简单，因为只需要计算一个数组的地址，而不是两个。</p><p>一些编译器将为不同的数组使用不同的内存空间，即使它们从未同时被使用过。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example 9.2a</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">F1</span><span class="params">(<span class="type">int</span> x[])</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">F2</span><span class="params">(<span class="type">float</span> x[])</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">F3</span><span class="params">(<span class="type">bool</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a[<span class="number">1000</span>];</span><br><span class="line">        <span class="built_in">F1</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">float</span> b[<span class="number">1000</span>];</span><br><span class="line">        <span class="built_in">F2</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，可以为 <code>a</code> 和 <code>b</code> 使用相同的内存区域，因为它们的活动范围不重叠。通过将 <code>a</code> 和 <code>b</code> 放入 <code>union</code> 中，可以节省大量缓存空间：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example 9.2b</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">F3</span><span class="params">(<span class="type">bool</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">union</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a[<span class="number">1000</span>];</span><br><span class="line">        <span class="type">float</span> b[<span class="number">1000</span>];</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> (y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">F1</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">F2</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，使用 <code>union</code> 不是一种安全的编程实践，因为如果 <code>a</code> 和 <code>b</code> 的使用重叠，编译器不会发出警告。你应该只对占用大量缓存空间的大型对象使用此方法。将简单变量放入<code>union</code>中不是最佳选择，因为它会阻止寄存器变量的使用。</p><h3 id="4-数据对齐"><a href="#4-数据对齐" class="headerlink" title="4.数据对齐"></a>4.数据对齐</h3><p>如果将变量存储在可被变量大小整除的内存地址中，则访问该变量的效率最高。例如，<code>double</code> 占用 8字节的存储空间。因此，最好将其存储在可被 8整除的地址中。大小应该总是 2的幂。大于 16字节的对象应该存储在可被 16整除的地址中。你通常可以假设编译器会自动处理这种对齐。</p><p>你可以选择按cache line大小对齐大型对象和数组（通常是 64字节）。这可以确保对象或数组的开头与cache line的开头一致。一些编译器会自动对齐大的静态数组，但你也可以通过以下方式显示指定：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__declspec(<span class="built_in">align</span>(<span class="number">64</span>)) <span class="type">int</span> BigArray[<span class="number">1024</span>]; <span class="comment">// Windows syntax</span></span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> BigArray[<span class="number">1024</span>] __attribute__((<span class="built_in">aligned</span>(<span class="number">64</span>))); <span class="comment">// Linux syntax</span></span><br></pre></td></tr></table></figure><h3 id="5-动态分配内存"><a href="#5-动态分配内存" class="headerlink" title="5.动态分配内存"></a>5.动态分配内存</h3><p>对象和数组可以通过 <code>new</code> 和 <code>delete</code> 或 <code>malloc</code> 和 <code>free</code> 动态分配。在编译时期不知道所需的内存大小时，这可能非常有用。下面是动态内存分配的四种典型用法：</p><ol><li>可以在编译时不知道数组大小的情况下动态分配大数组。</li><li>当编译时不知道对象总数时，可以动态分配可变数量的对象。</li><li>可以动态分配文本字符串和类似大小可变对象。</li><li>对于栈来说太大的数组可以动态分配。</li></ol><p>动态分配内存的优点有：</p><ol><li>在某些情况下提供了更清晰的程序结构。</li><li>不会分配超过所需的空间。缓存效率与为了覆盖最坏的情况下最大可能的内存要求，固定大小的数组变的很大时相比，会高的多。</li><li>当不能预先给出所需内存空间的合理上限时，这是非常有用的。</li></ol><p>动态分配内存的缺点有：</p><ol><li>动态分配和释放内存的过程比其他类型的存储需要更多的时间。见<strong>7.1 不同类型变量的存储</strong>。</li><li>当以随机顺序分配和释放不同大小的对象时，堆空间就会变得碎片化。这使得数据缓存效率低下。</li><li>如果已分配的数组已满，则可能需要调整其大小。这可能需要分配一个新的更大的内存块，并将整个内容复制到新块中。指向旧块中的数据的任何指针都将失效。</li><li>当堆空间变得过于碎片化时，堆管理器将启动垃圾收集。此垃圾收集可能在不可预测的时间开始，并在用户等待响应的不方便的时间导致程序执行的延迟。</li><li>程序员有责任确保已分配的所有内容也被释放。如果不这样做，将导致堆被填满。这是一种常见的编程错误，称为内存泄漏。</li><li>序员有责任确保在释放对象之后没有对象被访问。没有这么做也是一个常见的编程错误。</li><li>所分配的内存可能不是最佳对齐的。有关如何对齐动态分配的内存，请参见<strong>12.8 对齐动态分配的内存</strong>。</li><li>编译器很难优化使用指针的代码，因为它不能排除别名（参见<strong>8.3 编译器优化的障碍：指针别名</strong>）。</li><li>当行长度在编译时是未知的，矩阵或多维数组的效率较低，因为在每次访问时需要额外的工作来计算行地址。编译器可能无法使用归纳变量对其进行优化。</li></ol><p>在决定是否使用动态内存分配时，权衡利弊是很重要的。当数组的大小或对象的数量在编译时已知或可以知道合理的上限时，没有理由使用动态内存分配。</p><p>当分配的数量有限时，动态内存分配的成本可以忽略不计。因此，当一个程序有一个或几个可变大小的数组时，动态内存分配是有利的。另一种解决方案是将数组设置得非常大，以覆盖最坏的情况，但这会浪费缓存空间。如果一个程序有几个大数组，并且每个数组的大小是关键步长（参见<strong>9.2 缓存结构</strong>）的倍数，那么很可能会在数据缓存中引起竞争。</p><p>如果一个数组中的元素数量在程序执行期间增长，那么最好从一开始就分配最终的数组大小，而不是一步一步地分配更多的空间。在大多数系统中，你无法增加已经分配的内存块的大小。如果最终大小无法预测，或者预测结果太小，那么就需要分配一个新的更大内存块，并将旧内存块的内容复制到新的更大内存块的开头。当然，这是低效的，并且会导致堆空间变得碎片化。另一种方法是保留多个内存块，要么以链表的形式，要么以内存块的索引的形式。具有多个内存块的方法使得对单个数组元素的访问更加复杂和耗时。</p><p>一个可变数量的对象集合通常被实现为一个链表。链表中的每个元素都有自己的内存块和指向下一个块的指针。链表的效率不如线性数组，原因如下：</p><ol><li>每个对象都是单独分配的。分配、释放和垃圾收集需要大量的时间。</li><li>对象没有连续地存储在内存中。这会降低数据缓存的效率。</li><li>额外的内存空间用于链接指针和堆管理器为每个分配的块存储的信息。</li><li>遍历链表比遍历线性数组要花费更多的时间。在加载前一个元素指针之前，不能加载任何指针。这就形成了一个关键的依赖链，这会妨碍乱序执行。</li></ol><p>为所有对象分配一个大内存块（内存池）通常比为每个对象分配一个小内存块效率更高。</p><p>使用 <code>new</code> 和 <code>delete</code> 分配可变大小的数组的一个鲜为人知的替代方法是使用 <code>alloca</code> 分配来代替。这是一个在栈上而不是堆上分配内存的函数。内存空间在当从调用 <code>alloca</code> 的函数返回时会被自动释放。在使用 <code>alloca</code> 时，不需要显式地释放空间。与 <code>new</code> 和 <code>delete</code> 或 <code>malloc</code> 和 <code>free</code> 相比，<code>alloca</code> 的优势有：</p><ol><li>分配过程的开销很小，因为微处理器有硬件支持对栈的操作。</li><li>由于堆栈的先入后出特性，内存空间不会变得支离破碎。</li><li>重新分配没有成本，因为它在函数返回时将自动执行。不需要垃圾收集。</li><li>所分配的内存与栈上的其他对象是连续的，这使得数据缓存非常高效。</li></ol><p>下面的例子将展示如何适应<code>alloca</code>分配可变大小的数组：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SomeFunction</span> <span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">// Make dynamic array of n floats:</span></span><br><span class="line">        <span class="type">float</span> * DynamicArray = (<span class="type">float</span> *)<span class="built_in">alloca</span>(n * <span class="built_in">sizeof</span>(<span class="type">float</span>));</span><br><span class="line">    <span class="comment">// (Some compilers use the name _alloca)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            DynamicArray[i] = <span class="built_in">WhateverFunction</span>(i);</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，函数不应该返回任何使用 <code>alloca</code> 分配的指针或引用，因为它在函数返回时被释放。<code>alloca</code> 可能与结构化异常处理不兼容。有关使用 <code>alloca</code> 的限制，请参阅编译器手册。</p><p><em>C99</em> 扩展支持可变大小的数组。这个特性是有争议的，并且只在 <em>C</em> 中可用，而不能在<em>C++</em> 中使用。你可以使用 <code>alloca</code> 而不是可变大小的数组，因为它提供了相同的功能。</p><h3 id="6-容器类"><a href="#6-容器类" class="headerlink" title="6.容器类"></a>6.容器类</h3><p>当使用动态内存分配，建议使用容器类，因为容器类有析构函数可以避免内存泄漏和空指针等问题。容器类还可以添加边界检查等功能。</p><p>可以使用c++STL标准模板库，然而STL的特点是通用性和灵活性，在内存分配时会浪费内存。如 <code>list</code>、<code>set</code> 和 <code>map</code>，甚至可能分配比容器中对象更大的内存块。<em>STL</em>  <code>deque</code>（双向链表）为每四个对象分配一个内存块。<em>STL</em>  <code>vector</code> 将所有的对象都存储在同一个内存块中，当这快内存被填满时会重新分配，这种情况经常发生，因为块大小每次只增长 50%或更少。针对<code>vector</code>，可以创建<code>vector</code>后调用<code>vector::reserve</code>重新分配预估的大小避免多次进行内存分配。其他 <em>STL</em> 容器没有预先分配内存的功能。</p><p>anger实现了一组示例容器类来提高效率<a href="https://www.agner.org/optimize/cppexamples.zip">www.agner.org/optimize/cppexamples.zip</a></p><p>在为特定用途选择容器时，应考虑以下因素：</p><ol><li>包含一个还是多个元素？如果容器包含一个元素，那么可以使用智能指针（见<strong>7.9 智能指针</strong>）。</li><li>编译时是否知道大小？如果在编译时已知元素的数量，或者可以设置不太大的上限，那么最优解决方案是一个固定大小的数组或容器，而不需要动态内存分配。但是，如果数组或容器对于栈来说太大的时候，则可能需要动态内存分配。</li><li>在存储第一个元素之前，大小是否已知？如果在存储第一个元素之前可以知道元素的总数（或者有一个合理的估计），那么最好使用允许预先分配（<code>reserve</code>）内存的容器,而不是分段分配内存或当内存块太小的时候重新分配。</li><li>对象是连续编号的么？如果对象是由连续的索引或有限范围内的键标识的，那么简单的数组是高效的解决方案。</li><li>对象是以先进先出的方式访问的么？如果在先进先出（<strong>FIFO</strong>）的基础上访问对象，则使用队列。将队列作为循环缓冲区而不是链表使用更高效。</li><li>对象是以先进后出的方式访问的么？如果对象是在先入后出（<strong>FILO</strong>）的基础上访问的，那么使用带有栈顶部索引的线性数组。</li><li>对象是由键标识的么？如果键值被限制在一个较窄的范围内，那么可以使用一个简单的数组。如果对象的数量很多，那么最高效的解决方案可能是二叉树或哈希图。</li><li>对象有顺序吗？如果你需要做这样的搜素：“离元素 x 最近的是哪个？”或者 “在 x 和 y之间有多少个元素？”，那么你可以使用有序列表或者二叉树。</li><li>添加所有对象之后是否需要搜索？如果需要搜索工具，但必须在容器中存储了所有对象之后，那么线性数组将是一个高效的解决方案。在添加所有元素之后对数组进行排序，然后使用二分搜索来查找元素。哈希表也可能是一种高效的解决方案。</li><li>添加所有对象之前是否需要搜索？如需要搜索工具，并且可以随时添加新对象，那么解决方案就更复杂了。如果元素的总数很少，那么有序列表是最高效的解决方案，因为它的简单。但是如果列表很大，有序列表会非常低效，因为在列表中插入一个新元素会导致所有后续元素都需要移动。在这种情况下我们需要二叉树或者哈希表。如果元素是有序的，并且在一定间隔后就会有搜素请求，那么可以使用二叉树。哈希表则可以在元素没有特定顺序但又唯一的键标识时使用。</li><li>对象是否具有混合类型或大小？可以在同一个内存池中存储不同类型的对象或不同长度的字符串。见 <a href="https://www.agner.org/optimize/cppexamples.zip">www.agner.org/optimize/cppexamples.zip</a>。如果在编译时知道元素的数量和类型，那么就不需要使用容器或内存池。</li><li>是否要对齐？一些应用程序要求数据按可以被整除的地址对齐。特别是使用向量指令时，需要对齐的地址可以被 16整出。在某些情况下，将数据结构对齐到可被缓存线大小整除的地址（通常为64）可以提高性能。</li><li>是否使用多线程？如果多个线程可以同时添加、删除或修改对象，那么容器类通常不是线程安全的。在多线程应用程序中，为每个线程设置单独的容器要比临时锁定一个容器以供每个线程独占访问高效的多。</li><li>有指向包含的对象的指针么？将指针指向包含的对象可能是不安全的，因为容器可能在需要重新分配内存时移动对象。容器内的对象应该通过其在容器中的索引或键来标识，而不是通过指针或引用。但是，如果没有其他线程访问容器，则可以将指向此类对象的指针或引用传递给不添加或删除任何对象的函数。</li><li>容器可以被回收么？创建和删除容器的消耗很大。如果程序的逻辑允许，复用一个容器可能比删除它再重新创建一个更高效。</li></ol><h3 id="7-字符串"><a href="#7-字符串" class="headerlink" title="7.字符串"></a>7.字符串</h3><p>常用的字符串一般是<code>char*</code> <code>string</code> <code>cstring </code> <code>char*</code>是最原始的字符串，<code>string</code>是STL库中的，<code>cstring</code>是是包含一些C字符串的操作函数.</p><p>补充一下：包含头文件时，若有<code>.h</code>后缀表示是c的头文件，若没有<code>.h</code>后缀表示是cpp的头文件，同时cpp还有一些c开头的头文件，比如<code>cmath</code>,<code>cstring</code>，这意味着保留了c风格的cpp库</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span><span class="comment">//cpp</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span><span class="comment">//c</span></span></span><br></pre></td></tr></table></figure><p>使用c风格的string处理函数如 <code>strcpy</code>、<code>strcat</code>、<code>strlen</code>、<code>sprintf</code>效率会高些。如果你想在不损害安全的情况下提高速度，你可以将所有字符串存储在内存池中，如上所述。anger手册的附录(<a href="http://www.agner.org/optimize/cppexamples.zip)%E4%B8%AD%E6%8F%90%E4%BE%9B%E4%BA%86%E7%A4%BA%E4%BE%8B">www.agner.org/optimize/cppexamples.zip)中提供了示例</a></p><h3 id="8-按顺序访问数据"><a href="#8-按顺序访问数据" class="headerlink" title="8.按顺序访问数据"></a>8.按顺序访问数据</h3><p>这一小节其实是对cpu缓存的应用，当你按顺序访问数据时，cpucache命中会增多，程序效率就高，比如经典的行访问和列访问的例子。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example 9.4</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> NUMROWS = <span class="number">100</span>, NUMCOLUMNS = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> matrix[NUMROWS][NUMCOLUMNS];</span><br><span class="line"><span class="type">int</span> row, column;</span><br><span class="line"><span class="keyword">for</span> (row = <span class="number">0</span>; row &lt; NUMROWS; row++)</span><br><span class="line">    <span class="keyword">for</span> (column = <span class="number">0</span>; column &lt; NUMCOLUMNS; column++)</span><br><span class="line">        matrix[row][column] = row + column;</span><br></pre></td></tr></table></figure><p>不要交换这两个循环的顺序（除非是在 <em>Fortran</em> 中，具有相反的存储顺序）。</p><h3 id="9-在大数据结构中的缓存冲突"><a href="#9-在大数据结构中的缓存冲突" class="headerlink" title="9.在大数据结构中的缓存冲突"></a>9.在大数据结构中的缓存冲突</h3><p>按顺序访问多维数组并不总是可能的。一些应用程序（例如，在线性代数中）需要其他访问模式。如果一个大矩阵中的行之间的距离恰好等于关键步长，就会导致严重的延迟，如<strong>9.2 缓存组织</strong>所述。如果矩阵行的大小（以字节为单位）是 2 的高次幂，就会发生这种情况。</p><p>下面的例子说明了这一点。我的例子是一个对二次矩阵进行转置的函数，即每个元素矩阵 <code>[r][c]</code> 与元素矩阵 <code>[c][r]</code> 交换。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example 9.5a</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SIZE = <span class="number">64</span>;<span class="comment">// number of rows/columns in matrix</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">transpose</span><span class="params">(<span class="type">double</span> a[SIZE][SIZE])</span><span class="comment">// function to transpose matrix</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// define a macro to swap two array elements:</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> swapd(x,y) &#123;temp=x; x=y; y=temp;&#125;</span></span><br><span class="line">    <span class="type">int</span> r, c; <span class="type">double</span> temp;</span><br><span class="line">    <span class="keyword">for</span> (r = <span class="number">1</span>; r &lt; SIZE; r++)</span><br><span class="line">    &#123; <span class="comment">// loop through rows</span></span><br><span class="line">        <span class="keyword">for</span> (c = <span class="number">0</span>; c &lt; r; c++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// loop columns below diagonal</span></span><br><span class="line">            <span class="built_in">swapd</span>(a[r][c], a[c][r]); <span class="comment">// swap elements</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __declspec(__align(<span class="number">64</span>))     <span class="comment">// align by cache line size</span></span><br><span class="line">    <span class="type">double</span> matrix[SIZE][SIZE]; <span class="comment">// define matrix</span></span><br><span class="line">    <span class="built_in">transpose</span>(matrix);         <span class="comment">// call transpose function</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>矩阵的转置和以对角线为轴做镜像是一样的。对角线以下的每个元素矩阵 <code>[r][c]</code> 在对角线以上的镜像位置与元素矩阵 <code>[c][r] </code>交换。<strong>例 9.5a</strong>中的循环 <em>c</em>   从最左边的列到对角线。对角线上的元素保持不变。</p><p>这段代码的问题是，如果对角线以下的元素矩阵 <code>[r][c]</code> 是逐行访问的，那么对角线以上的镜像元素矩阵 <code>[c][r]</code> 是逐列访问的。</p><p>假设现在我们在奔腾4电脑上运行这段代码，矩阵的大小是 64。电脑的一级缓存为 <code>8 kb = 8192 bytes</code>，4 路，行大小为 64。每个缓存行可以保存8个 <code>double</code> 变量，每个变量的大小为8个字节。关键步长为 $8192&#x2F;4&#x3D;2048  bytes &#x3D; 4 rows$。</p><p>让我们看看循环内部发生了什么，例如当 <code>r = 28</code> 时。我们从对角线以下的第  28行取出元素，并将这些元素与对角线以上的第 28列交换。第 28行中的前 8个元素共享同一缓存线。因为缓存线按行而不是按列缓存，在第 28列中的 8个元素将进入 8个不同的缓存行中。每四个高速缓存线属于同一组高速缓存。当我们操作到第 28列中的16号元素时，缓存将收回该列中0号使用的缓存线。17号元素将覆盖1号元素使用的缓存线，18号元素将覆盖 2号元素使用的缓存线，依此类推。这意味着当我们将第 29列与第 29行交换时，对角线以上使用的所有缓存线都被覆盖了。因为在我们需要下一个元素之前，它会被删除，每个缓存线必须重新加载 8次。我已经通过使用不同矩阵大小的奔腾4上的<strong>示例9.5a</strong>来测量转置矩阵所需的时间来证实这一点。我的实验结果如下，时间单位是每个数组元素所需要要的时钟周期。</p><center><table><thead><tr><th align="center">Matrix Size</th><th align="center">Total kilobytes</th><th align="center">Time per element</th></tr></thead><tbody><tr><td align="center">63*63</td><td align="center">31</td><td align="center">11.6</td></tr><tr><td align="center">64*64</td><td align="center">32</td><td align="center">16.4</td></tr><tr><td align="center">65*65</td><td align="center">33</td><td align="center">11.8</td></tr><tr><td align="center">127*127</td><td align="center">126</td><td align="center">12.2</td></tr><tr><td align="center">128*128</td><td align="center">128</td><td align="center">17.4</td></tr><tr><td align="center">129*129</td><td align="center">130</td><td align="center">14.4</td></tr><tr><td align="center">511*511</td><td align="center">2040</td><td align="center">38.7</td></tr><tr><td align="center">512*512</td><td align="center">2048</td><td align="center">230.7</td></tr><tr><td align="center">513*513</td><td align="center">2056</td><td align="center">38.1</td></tr></tbody></table><p><strong>Table 9.1. Time for transposition of different size matrices, clock cycles per element.</strong></p></center><p>从表中可以看出，当矩阵的大小是一级缓存大小的倍数时，转置矩阵要多花 40%的时间。这是因为关键步长是矩阵行的倍数。由于无序执行机制可以预先加载数据，延迟比一级缓存从二级缓存中重新加载数据的时间少。</p><p>当竞争发生在二级缓存中时，这种效果更为显著。二级缓存$512 kb$，8路。二级缓存的关键步长是$512 kb &#x2F; 8 &#x3D; 64 kb$。这对应于$512*512$矩阵中的16行数据。我在<strong>表 9.1</strong>中的实验结果表明，在二级缓存中发生竞争时，转置矩阵所需的时间是不发生竞争时的 6倍。这种效果在二级缓存竞争中比在一级缓存竞争中强得多的原因是二级缓存一次不能预加载多行。</p><p>解决这个问题的一个简单方法是使矩阵中的行比需要的长，以避免关键步长是矩阵行大小的倍数。我试着让矩阵的大小为$512*520$，包含不使用最后 8列。这消除了竞争，时间消耗减少到 36个时钟周期。</p><p>在某些情况下，不可能向矩阵中添加未使用的列。例如，一个数学函数库应该能够有效地处理所有大小的矩阵。在这种情况下，一个有效的解决方案是将矩阵分成更小的正方形，一次处理一个正方形。这被称为<strong>square blocking <strong>或</strong>tiling</strong>。<strong>示例9.5b</strong>演示了这种技术：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example 9.5b</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">transpose</span><span class="params">(<span class="type">double</span> a[SIZE][SIZE])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Define macro to swap two elements:</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> swapd(x,y) &#123;temp=x; x=y; y=temp;&#125;</span></span><br><span class="line">    <span class="comment">// Check if level-2 cache contentions will occur:</span></span><br><span class="line">    <span class="keyword">if</span> (SIZE &gt; <span class="number">256</span> &amp;&amp; SIZE % <span class="number">128</span> == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Cache contentions expected. Use square blocking:</span></span><br><span class="line">        <span class="type">int</span> r1, r2, c1, c2; <span class="type">double</span> temp;</span><br><span class="line">        <span class="comment">// Define size of squares:</span></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> TILESIZE = <span class="number">8</span>; <span class="comment">// SIZE must be divisible by TILESIZE</span></span><br><span class="line">        <span class="comment">// Loop r1 and c1 for all squares:</span></span><br><span class="line">        <span class="keyword">for</span> (r1 = <span class="number">0</span>; r1 &lt; SIZE; r1 += TILESIZE)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (c1 = <span class="number">0</span>; c1 &lt; r1; c1 += TILESIZE)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="comment">// Loop r2 and c2 for elements inside sqaure:</span></span><br><span class="line">                <span class="keyword">for</span> (r2 = r1; r2 &lt; r1+TILESIZE; r2++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span> (c2 = c1; c2 &lt; c1+TILESIZE; c2++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">swapd</span>(a[r2][c2],a[c2][r2]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">           <span class="comment">// At the diagonal there is only half a square.</span></span><br><span class="line">           <span class="comment">// This triangle is handled separately:</span></span><br><span class="line">            <span class="keyword">for</span> (r2 = r1+<span class="number">1</span>; r2 &lt; r1+TILESIZE; r2++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (c2 = r1; c2 &lt; r2; c2++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">swapd</span>(a[r2][c2],a[c2][r2]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// No cache contentions. Use simple method.</span></span><br><span class="line">        <span class="comment">// This is the code from example 9.5a:</span></span><br><span class="line">        <span class="type">int</span> r, c; <span class="type">double</span> temp;</span><br><span class="line">        <span class="keyword">for</span> (r = <span class="number">1</span>; r &lt; SIZE; r++)</span><br><span class="line">        &#123; <span class="comment">// loop through rows</span></span><br><span class="line">            <span class="keyword">for</span> (c = <span class="number">0</span>; c &lt; r; c++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// loop columns below diagonal</span></span><br><span class="line">                <span class="built_in">swapd</span>(a[r][c], a[c][r]); <span class="comment">// swap elements</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在我的实验中，使用这段代码，对于512*512的矩阵来说，每个元素消耗50个时钟周期。</p><p>二级缓存中竞争的代价是如此的昂贵，因此对它们采取措施非常重要。因此，你应该了解矩阵中列数为 2的高次幂的情况。一级缓存中的竞争消耗较少，可能不值得为了一级缓存中使用像<strong>square blocking</strong>这么复杂的技术。</p><p><strong>Squre blocking</strong>以及类似的技术在 S. Goedecker 和 A. Hoisie 2001年出版的 “Performance Optimization of Numerically Intensive Codes”一书中有更详细的描述。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h2 id=&quot;七、内存访问优化&quot;&gt;&lt;a href=&quot;#七、内存访问优化&quot; class=&quot;headerlink&quot; title=&quot;七、内存访问优化&quot;&gt;&lt;/a&gt;七、内存访问优化&lt;/h2&gt;&lt;h3 id=&quot;1-缓存&quot;&gt;&lt;a href=&quot;#1-缓存&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    
    <category term="hpc" scheme="https://mightcoder.com/tags/hpc/"/>
    
    <category term="cpp" scheme="https://mightcoder.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>linux查漏补缺</title>
    <link href="https://mightcoder.com/2022/03/30/linux%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"/>
    <id>https://mightcoder.com/2022/03/30/linux%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/</id>
    <published>2022-03-30T13:33:57.000Z</published>
    <updated>2022-07-15T08:13:03.060Z</updated>
    
    <content type="html"><![CDATA[<h1 id="linux查漏补缺"><a href="#linux查漏补缺" class="headerlink" title="linux查漏补缺"></a>linux查漏补缺</h1><blockquote><p>查漏补缺，打好基础</p></blockquote><h2 id="一、linux系统目录"><a href="#一、linux系统目录" class="headerlink" title="一、linux系统目录"></a>一、linux系统目录</h2><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/202203302134588.jpeg" alt="img"></p><p><code>/bin</code>：binaries二进制文件的缩写，里面都是二进制文件，且都是普通用户可以使用的命令</p><p><code>/boot</code>：引导程序，内核存放的目录</p><p><code>/sbin</code>：与bin类似，但是里面存放的都是超级（root）用户可以使用的命令</p><p><code>/lib</code>：根目录下所有程序所需的共享库</p><p><code>/dev</code>：设备文件目录(Linux中设备以文件形式存在，实体设备以设备文件的形式被Linux得知，并通过设备驱动被linux使用)</p><p><code>/home</code>：此目录下存放所有普通用户的主目录，一般每个用户都在&#x2F;home下有一个子目录，目录名为用户名</p><p><code>/root</code>：root用户的主目录</p><p><code>/etc</code>：全局的配置文件存放目录，当程序在用户主目录下时，会将配置文件在用户主目录下生成，系统也会优先去用户主目录下加载配置，若没有再去&#x2F;etc下加载。</p><p><code>/opt</code>：optional的简称，可以将自定义软件包或第三方软件安装在此目录下</p><p><code>/mnt</code>：临时挂载目录，用于挂载存储设备的，比如磁盘光驱网络文件系统等，例如WSL2的目录<code>/mnt/c</code>就是我们Windows下的c盘。</p><p><code>/media</code>：用于挂载媒体设备，比如u盘等。</p><p><code>/proc</code>：这是一个虚拟文件系统,以文件系统目录和文件形式,提供一个指向内核数据结构的接口，通过它能够查看和改变各种系统属性，详细信息可以参考这个链接 <a href="https://blog.spoock.com/2019/10/08/proc/">&#x2F;proc目录介绍</a></p><p><code>/sys</code>：该文件系统是内核设备树的一个直观反映。当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。与<code>/dev</code>相似却不同，<code>/sys</code>是更偏内核方面的。</p><p><code>/tmp</code>：存放临时文件，定期清理。</p><p><code>/var</code>：variable的缩写，<code>/var </code>包括系统运行时要改变的数据。var目录存在的目的是把usr目录在运行过程中需要更改的文件或者临时生成的文件及目录提取出来，由此可以使usr目录挂载为只读的方式。隐含要求var目录必须挂载为可以读写的方式。</p><p><code>/run</code>：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。<code>/var/run</code>是个指向<code>/run</code>的链接。</p><p><code>/usr</code>：usr不是user，而是unix System resources(系统资源) 的缩写，这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于C:&#x2F;windows 目录。</p><p><code>/usr</code>下比较重要的几个目录：</p><p><code>/usr/bin</code>：与&#x2F;bin类似，也是存放二进制文件命令，但是<code>/bin</code>下一般为系统自带的，<code>/usr/bin</code>一般为用户后来安装的</p><p><code>/usr/sbin</code>：root用户的命令</p><p><code>/usr/include</code>：存放c程序的头文件</p><p><code>/usr/local</code>：用户的程序目录，相当于C:&#x2F;windows:Program Files。<code>/usr/local</code>下也有<code>/bin</code>和<code>/lib</code> <code>/sbin</code>等。</p><p>比较一下<code>/bin</code> <code>/usr/bin</code> <code>/usr/local/bin</code></p><ul><li><code>/bin</code> 放置系统的关键程序，比如 <code>ls</code> <code>cat</code> ，对于“关键”的定义，不同的发行版会有不同的理解；</li><li><code>/usr/bin</code> 放置发行版管理的程序，比如 Ubuntu 自带 <code>md5sum</code> ，这个 binary 就会在这个目录下；</li><li><code>/usr/local/bin</code> 放置用户自己的程序，比如你编译了一个 gcc，那么 gcc 这个可执行 binary 应该在这个目录下；</li></ul><h2 id="二、环境变量"><a href="#二、环境变量" class="headerlink" title="二、环境变量"></a>二、环境变量</h2><p><strong>一、环境变量文件介绍</strong>  </p><p>Linux 中环境变量包括系统级和用户级，系统级的环境变量是每个登录到系统的用户都要读取的系统变量，而用户级的环境变量则是该用户使用系统时加载的环境变量，所以管理<a href="https://so.csdn.net/so/search?q=%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F&spm=1001.2101.3001.7020">环境变量</a>的文件也分为系统级和用户级的。</p><p><strong>二、Linux 的变量种类</strong></p><p>按变量的生存周期来划分，Linux 变量可分为两类：</p><ol><li><p>永久的：需要修改配置文件，变量永久生效</p></li><li><p>临时的：使用 export 命令声明即可，变量在关闭 shell 时失效</p></li></ol><p><strong>三、Linux 环境变量文件</strong></p><p>linux 变量文件有 &#x2F; etc&#x2F;environment 或 &#x2F;etc&#x2F;profile 或 <del>&#x2F;.profile 或 &#x2F;etc&#x2F;bash.bashrc 或 ~&#x2F;.bashrc, 以及</del>&#x2F;.bash_profile(一般是用户在自己目录下新建的)，~&#x2F;.bash_logout.</p><p><strong>系统级：</strong></p><p>1.&#x2F;etc&#x2F;environment: 是系统在登录时读取的第一个文件，该文件设置的是整个系统的环境，只要启动系统就会读取该文件，用于为所有进程设置环境变量。系统使用此文件时并不是执行此文件中的命令，而是根据而是根据 KEY&#x3D;VALUE 模式的代码，对 KEY 赋值以 VALUE，因此文件中如果要定义 PATH 环境变量，只需加入一行形如 PATH&#x3D;$PATH:&#x2F;xxx&#x2F;bin 的代码即可</p><p>2.&#x2F;etc&#x2F;profile: 此文件是系统登录时执行的第二个文件。 为系统的每个用户设置环境信息，当用户第一次登录时，该文件被执行。并从 &#x2F; etc&#x2F;profile.d 目录的配置文件中搜集 shell 的设置。（&#x2F;etc&#x2F;profile 可以用于设定针对全系统所有用户的环境变量，环境变量周期是永久性）</p><p>3.&#x2F;etc&#x2F;bashrc: 是针对所有用户的 bash 初始化文件，在此中设定的环境变量将应用于所有用户的 shell 中，此文件会在用户每次打开 shell 时执行一次。（即每次新开一个终端，都会执行 &#x2F; etc&#x2F;bashrc）。</p><p><strong>用户级（这些文件处于家目录下）：</strong></p><ol><li>~&#x2F;.profile: 对应当前登录用户的 profile 文件，用于定制当前用户的个人工作环境 (变量是永久性)，每个用户都可使用该文件输入专用于自己使用的 shell 信息, 当用户登录时, 该文件仅仅执行一次! 默认情况下, 他设置一些环境变量, 执行用户的. bashrc 文件。<strong>这里是推荐放置个人设置的地方</strong></li></ol><p>2.<del>&#x2F;.bashrc: 该文件包含专用于你的 bash shell 的 bash 信息，当登录时以及每次打开新的 shell 时，该文件被读取。(</del>&#x2F;.bashrc 只针对当前用户，变量的生命周期是永久的)</p><p><strong>不推荐放到这儿，因为每开一个 shell，这个文件会读取一次，效率肯定有影响。</strong></p><p>3.<del>&#x2F;.bash_profile or ~.&#x2F;bash_login:_**</del>&#x2F;.bash_profile 是交互式 login 方式进入 bash 运行的，<del>&#x2F;.bashrc 是交互式 non-login 方式进入 bash 运行的通常二者设置大致相同，所以通常前者会调用后者**_。每个用户都可使用该文件输入专用于自己使用的 shell 信息，当用户登录时，该文件仅仅执行一次。默认情况下，他设置一些环境变量，执行用户的. bashrc 文件。（如果</del>&#x2F; 目录下没有. bash_profile 则新建立一个）这里是推荐放置个人设置的地方</p><p>当一个 shell 关闭时，在 bash_profile 中定义的系统变量则会失效。因此，每打开一个新的 shell 时都要运行一次 source bash_profile. 而且针对当前用户。</p><p>4.~&#x2F;.pam_environment: 用户级的环境变量设置文件，没有做测试，不知道管不管用。</p><p>5.<del>&#x2F;.bash_logout: 当每次退出系统（退出 bash shell）时，执行该文件。另外,&#x2F;etc&#x2F;profile 中设定的变量 (全局) 的可以作用于任何用户, 而</del>&#x2F;.bashrc 等中设定的变量 (局部) 只能继承 &#x2F;etc&#x2F;profile 中的变量, 他们是 “父子” 关系。</p><p><strong>四、Linux 环境变量文件执行顺序</strong></p><ol><li>在登录 Linux 时要执行文件的过程如下：</li></ol><p>在刚登录 Linux 时，</p><p>首先启动 &#x2F;etc&#x2F;profile 文件，</p><p>然后再启动用户目录下的 ~&#x2F;.bash_profile、 ~&#x2F;.bash_login 或 ~&#x2F;.profile 文件中的其中一个，用户主目录下文件的执行的顺序为：</p><p>　　　　　　　　　　~&#x2F;.bash_profile -&gt; ~&#x2F;.bash_login -&gt; ~&#x2F;.profile。</p><p>如果 ~&#x2F;.bash_profile 文件存在的话，一般还会执行 ~&#x2F;.bashrc 文件。</p><p>因为在 ~&#x2F;.bash_profile 文件中一般会有下面的代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if [ -f ~/.bashrc ] ; then</span><br><span class="line">   . ./bashrc</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>~&#x2F;.bashrc 中，一般还会有以下代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if [ -f /etc/bashrc ] ; then</span><br><span class="line">   . /etc/bashrc</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>所以，~&#x2F;.bashrc 会调用 &#x2F;etc&#x2F;bashrc 文件。最后，在退出 shell 时，还会执行 ~&#x2F;.bash_logout 文件。</p><p>执行顺序为： <strong>&#x2F;etc&#x2F;profile -&gt; (~&#x2F;.bash_profile | ~&#x2F;.bash_login | ~&#x2F;.profile) -&gt; ~&#x2F;.bashrc -&gt; &#x2F;etc&#x2F;bashrc -&gt; ~&#x2F;.bash_logout</strong></p><p><strong>&#x2F;etc&#x2F;profile 和 &#x2F; etc&#x2F;environment 等各种环境变量设置文件的用处</strong></p><p>1）先将 export LANG&#x3D;zh_CN 加入 &#x2F; etc&#x2F;profile，退出系统重新登录，登录提示显示英文。</p><p>2）先将 &#x2F; etc&#x2F;profile 中的 export LANG&#x3D;zh_CN 删除，将 LNAG&#x3D;zh_CN 加入 &#x2F; etc&#x2F;environment，退出系统重新登录，登录提示显示中文。</p><p>用户环境建立的过程中总是先执行 &#x2F; etc&#x2F;profile，然后再读取 &#x2F; etc&#x2F;environment。</p><p><strong>为什么会有如上所叙的不同呢？而不是先执行 &#x2F; etc&#x2F;environment，后执行 &#x2F; etc&#x2F;profile 呢？</strong></p><p>这是因为： &#x2F;etc&#x2F;environment 是设置整个系统的环境，而 &#x2F; etc&#x2F;profile 是设置所有用户的环境，前者与登录用户无关，后者与登录用户有关。</p><p>系统应用程序的执行与用户环境可以是无关的，但与系统环境是相关的，所以当你登录时，你看到的提示信息，如日期、时间信息的显示格式与系统环境的 LANG 是相关的，缺省 LANG&#x3D;en_US，如果系统环境 LANG&#x3D;zh_CN，则提示信息是中文的，否则是英文的。</p><p><strong>对于用户的 shell 初始化而言是先执行 &#x2F; etc&#x2F;profile，再读取文件 &#x2F; etc&#x2F;environment；对整个系统而言是先执行 &#x2F; etc&#x2F;environment。这样理解正确吗？</strong></p><p><strong>登陆系统时的顺序应该是：</strong></p><p><strong>&#x2F;etc&#x2F;enviroment –&gt; &#x2F;etc&#x2F;profile –&gt;<em>HOME</em>&#x2F;._profile_−−&gt;HOME&#x2F;.env (如果存在)</strong></p><p>&#x2F;etc&#x2F;profile 是所有用户的环境变量</p><p>&#x2F;etc&#x2F;enviroment 是系统的环境变量</p><p><strong>登陆系统时 shell 读取的顺序应该是：</strong></p><p><strong>&#x2F;etc&#x2F;profile -&gt;&#x2F;etc&#x2F;enviroment –&gt;<em>HOME</em>&#x2F;._profile_−−&gt;HOME&#x2F;.env</strong></p><p>原因应该是用户环境和系统环境的区别了，如果同一个变量在用户环境 (&#x2F;etc&#x2F;profile) 和系统环境 (&#x2F;etc&#x2F;environment) 有不同的值，那应该是以用户环境为准了。</p><p><strong>五、Linux 中常见的环境变量及其作用</strong></p><p>Linux 中常见的环境变量有：</p><p>1.PATH：指定命令的搜索路径</p><p>2.HOME：指定用户的主工作目录（即用户登陆到 Linux 系统中时，默认的目录）</p><p>3.HISTSIZE：指保存历史命令记录的条数。</p><p>4.LOGNAME：指当前用户的登录名。</p><p>5.HOSTNAME：指主机的名称，许多应用程序如果要用到主机名的话，通常是从这个环境变量中来取得的。</p><p>6.SHELL：指当前用户用的是哪种 Shell。</p><p>7.LANG&#x2F;LANGUGE：和语言相关的环境变量，使用多种语言的用户可以修改此环境变量。</p><p>8.MAIL：指当前用户的邮件存放目录。</p><p>9.PS1：命令基本提示符，对于 root 用户是 #，对于普通用户是 $。</p><p>10.PS2：附属提示符，默认是 “&gt;”。</p><p>备注：可以通过修改此环境变量来修改当前的命令符，比如下列命令会将提示符修改成字符串 “Hello,MyNewPrompt”。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PS1=&quot;Hello,My NewPrompt&quot;</span><br></pre></td></tr></table></figure><p>注意：上述变量的名字并不固定，如 HOSTNAME 在某些 Linux 系统中可能设置成 HOST</p><p>当然，我所列举的上述环境变量并非穷尽列出！</p><p><strong>Linux 也提供了修改和查看环境变量的命令！下面通过几个实例来说明：</strong></p><p>1.echo 显示某个环境变量值 echo $PATH</p><p>2.export 设置一个新的环境变量 export HELLO&#x3D;”hello” (可以无引号)，在 shell 的命令行下直接使用 [export 变量名 &#x3D; 变量值] 定义变量，该变量只在当前的 shell(BASH) 或其子 shell(BASH)下是有效的，shell 关闭了，变量也就失效了，再打开新 shell 时就没有这个变量，需要使用的话还需要重新定义。</p><p>3.env 显示所有环境变量</p><p>4.set 显示本地定义 (系统中已经存在) 的 shell 变量以及设置 shell 变量的新变量值, 如果未指定值，则该变量值将被设为 NULL。</p><p>5.unset 清除环境变量 unset HELLO</p><p>6.readonly 设置只读环境变量 readonly HELLO , 如果使用了 readonly 命令的话，变量就不可以被修改或清除了</p><h2 id="三、常用技巧"><a href="#三、常用技巧" class="headerlink" title="三、常用技巧"></a>三、常用技巧</h2><h2 id="1-输入光标移动快捷键"><a href="#1-输入光标移动快捷键" class="headerlink" title="1.输入光标移动快捷键"></a>1.输入光标移动快捷键</h2><ul><li>ctrl+左右键 : 在单词之间跳转</li><li>ctrl+a : 跳到本行的行首</li><li>ctrl+e : 跳到页尾</li><li>Ctrl+u ：删除当前光标前面的文字 （还有剪切功能）</li><li>ctrl+k ：删除当前光标后面的文字(还有剪切功能)</li><li>Ctrl+L：进行清屏操作</li><li>Ctrl+y : 粘贴Ctrl+u或ctrl+k剪切的内容</li><li>Ctrl+w : 删除光标前面的单词的字符（以空格隔开的字符串）</li><li>Alt – d ：由光标位置开始，往右删除单词，往行尾删</li><li>Ctrl+r : 搜索执行过的命令</li><li>! + 最近执行过的命令中的某个字符 ：可快速执行最近执行过的命令</li><li>fs -l :显示部分历史命令</li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;linux查漏补缺&quot;&gt;&lt;a href=&quot;#linux查漏补缺&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    
    <category term="linux" scheme="https://mightcoder.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>optimizing_cpp(6)</title>
    <link href="https://mightcoder.com/2022/03/30/optimizing-cpp-6/"/>
    <id>https://mightcoder.com/2022/03/30/optimizing-cpp-6/</id>
    <published>2022-03-30T13:11:37.000Z</published>
    <updated>2022-07-15T08:13:03.059Z</updated>
    
    <content type="html"><![CDATA[<h2 id="六、编译器层次的优化"><a href="#六、编译器层次的优化" class="headerlink" title="六、编译器层次的优化"></a>六、编译器层次的优化</h2><h3 id="1-编译器如何优化"><a href="#1-编译器如何优化" class="headerlink" title="1.编译器如何优化"></a>1.编译器如何优化</h3><h4 id="1-1内联函数"><a href="#1-1内联函数" class="headerlink" title="1.1内联函数"></a>1.1内联函数</h4><p>编译器可以自动在调用函数时将函数名替换为函数体，即转为内联函数。</p><p>内联函数优点：</p><ol><li>节约了调用、返回和参数传递的开销。</li><li>因为代码变得连续了，代码缓存的效率会更高。</li><li>如果只调用一次内联函数，那么代码就会变得更小。</li><li>函数内联可以使其他优化成为可能，下面会详细描述。</li></ol><h4 id="1-2常量折叠（constant-folding）和常量传播-constant-propagation"><a href="#1-2常量折叠（constant-folding）和常量传播-constant-propagation" class="headerlink" title="1.2常量折叠（constant folding）和常量传播(constant propagation)"></a>1.2常量折叠（constant folding）和常量传播(constant propagation)</h4><p>常量折叠是指只包含常量的表达式或子表达式将会被计算结果替换：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Example 8.2a</span><br><span class="line">double a, b;</span><br><span class="line">a = b + 2.0 / 3.0;</span><br></pre></td></tr></table></figure><p>编译器将会替换成下面的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Example 8.2b</span><br><span class="line">a = b + 0.666666666666666666667;</span><br></pre></td></tr></table></figure><p>常量传播指在依赖链上，若上游结果为常量，下游结果也为常量，则都会被替换成常量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Example 8.3a</span><br><span class="line"></span><br><span class="line">float parabola (float x)</span><br><span class="line">&#123;</span><br><span class="line">    return x * x + 1.0f;</span><br><span class="line">&#125;</span><br><span class="line">float a, b;</span><br><span class="line">a = parabola (2.0f);</span><br><span class="line">b = a + 1.0f;</span><br></pre></td></tr></table></figure><p>有可能被编译器替换成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Example 8.3b</span><br><span class="line"></span><br><span class="line">a = 5.0f;</span><br><span class="line">b = 6.0f;</span><br></pre></td></tr></table></figure><p>当表达式包含不能被内联的函数或者不能再编译时期计算的时候，常量折叠和常量传播就不可能起作用。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Example 8.4</span><br><span class="line"></span><br><span class="line">double a = sin(0.8);</span><br></pre></td></tr></table></figure><p><code>sin</code>函数是在一个单独的函数库中定义的，不能期望编译器能够内联这个函数并在编译时计算它。一些编译器能够在编译时计算最常见的数学函数，如 <code>sqrt</code> 和 <code>pow</code>，但不能计算更复杂的函数，比如 <code>sin</code>。</p><h4 id="1-3消除指针"><a href="#1-3消除指针" class="headerlink" title="1.3消除指针"></a>1.3消除指针</h4><p>如果指向的目标已知，则可以消除指针或引用。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Example 8.5a</span><br><span class="line"></span><br><span class="line">void Plus2 (int * p)</span><br><span class="line">&#123;</span><br><span class="line">    *p = *p + 2;</span><br><span class="line">&#125;</span><br><span class="line">int a;</span><br><span class="line">Plus2 (&amp;a);</span><br></pre></td></tr></table></figure><p>可能被编译器替换成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Example 8.5b</span><br><span class="line"></span><br><span class="line">a += 2;</span><br></pre></td></tr></table></figure><h4 id="1-4消除公共子表达式"><a href="#1-4消除公共子表达式" class="headerlink" title="1.4消除公共子表达式"></a>1.4消除公共子表达式</h4><p>如果相同的子表达式出现多次，那么编译器可能只会计算一次。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Example 8.6a</span><br><span class="line"></span><br><span class="line">int a, b, c;</span><br><span class="line">b = (a+1) * (a+1);</span><br><span class="line">c = (a+1) / 4;</span><br></pre></td></tr></table></figure><p>可能被编译器替换成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Example 8.6b</span><br><span class="line"></span><br><span class="line">int a, b, c, temp;</span><br><span class="line">temp = a+1;</span><br><span class="line">b = temp * temp;</span><br><span class="line">c = temp / 4;</span><br></pre></td></tr></table></figure><h4 id="1-5寄存器变量"><a href="#1-5寄存器变量" class="headerlink" title="1.5寄存器变量"></a>1.5寄存器变量</h4><p>最常用的变量存储被在寄存器中</p><p>在 32位系统中，整数寄存器变量的最大数量大约是 6个，在 64位系统中大约是 14个。</p><p>在 32位系统中，浮点寄存器变量的最大数量为 8个，在 64位系统中为 16个。一些编译器很难在 32位系统中生成浮点寄存器变量，除非启用了<em>SSE2</em>（或更高版本）指令集。</p><p>编译器将选择最常用的变量做为寄存器变量。这包括指针和引用，它们可以存储在整数寄存器中。寄存器变量的典型候选对象是临时中间变量、循环计数器、函数参数、指针、引用、<code>this</code> 指针、公共子表达式和归纳变量（见下文）。</p><p>如果一个变量被取地址，也就是有指针指向它，此时它一定在内存中就不能在寄存器中，因此，对于可能受益于寄存器存储的变量，尽量避免指针或者引用。</p><h4 id="1-6活动范围分析"><a href="#1-6活动范围分析" class="headerlink" title="1.6活动范围分析"></a>1.6活动范围分析</h4><p>变量的活动范围是指变量被使用的代码范围。对于活动范围不重叠的变量，编译器优化可以使用相同的寄存器。这在可用寄存器数量有限的时候是非常有用的。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// Example 8.7</span><br><span class="line">int SomeFunction (int a, int x[])</span><br><span class="line">&#123;</span><br><span class="line">    int b, c;</span><br><span class="line">    x[0] = a;</span><br><span class="line">    b = a + 1;</span><br><span class="line">    x[1] = b;</span><br><span class="line">    c = b + 1;</span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在本例中，<code>a</code>、<code>b</code> 和 <code>c</code> 可以共享同一个寄存器，因为它们的活动范围不重叠。如果 <code>c = b + 1</code> 更改为 <code>c = a + 2</code>，那么 <code>a</code> 和 <code>b</code> 就不能使用相同的寄存器，因为它们的活动范围现在重叠了。</p><p>编译器通常不会将此原则用于存储在内存中的对象。对于不同的对象，它不会使用相同的内存区域，即使它们的活动范围不重叠。</p><h4 id="1-7合并相同的分支"><a href="#1-7合并相同的分支" class="headerlink" title="1.7合并相同的分支"></a>1.7合并相同的分支</h4><p>通过合并相同的代码片段，可以使代码更加紧凑。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// Example 8.8a</span><br><span class="line"></span><br><span class="line">double x, y, z; bool b;</span><br><span class="line">if (b)</span><br><span class="line">&#123;</span><br><span class="line">    y = sin(x);</span><br><span class="line">    z = y + 1.;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">    y = cos(x);</span><br><span class="line">    z = y + 1.;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可能被编译器替换为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// Example 8.8b</span><br><span class="line"></span><br><span class="line">double x, y; bool b;</span><br><span class="line">if (b)</span><br><span class="line">&#123;</span><br><span class="line">    y = sin(x);</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">    y = cos(x);</span><br><span class="line">&#125;</span><br><span class="line">z = y + 1.;</span><br></pre></td></tr></table></figure><h4 id="1-8消除跳转"><a href="#1-8消除跳转" class="headerlink" title="1.8消除跳转"></a>1.8消除跳转</h4><p>可以通过复制它跳转到的代码来避免跳转。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int SomeFunction (int a, bool b)</span><br><span class="line">&#123;</span><br><span class="line">    if (b)</span><br><span class="line">    &#123;</span><br><span class="line">        a = a * 2;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        a = a * 3;</span><br><span class="line">    &#125;</span><br><span class="line">    return a + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码从<code>a=a*2</code>跳转到<code>return a+1;</code>,。编译器可以通过复制<code>return</code>语句来消除这个跳转：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// Example 8.9b</span><br><span class="line"></span><br><span class="line">int SomeFunction (int a, bool b)</span><br><span class="line">&#123;</span><br><span class="line">    if (b)</span><br><span class="line">    &#123;</span><br><span class="line">        a = a * 2;</span><br><span class="line">        return a + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        a = a * 3;</span><br><span class="line">        return a + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果条件可以被简化为永远为真或永远为假，则可以消除分支：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// Example 8.10a</span><br><span class="line"></span><br><span class="line">if (true)</span><br><span class="line">&#123;</span><br><span class="line">    a = b;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">    a = c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以被简化为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Example 8.10b</span><br><span class="line"></span><br><span class="line">a = b;</span><br></pre></td></tr></table></figure><p>如果可以从前一个分支知道某个分支的情况，那么也可以删除该分支。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// Example 8.11a</span><br><span class="line"></span><br><span class="line">int SomeFunction (int a, bool b)</span><br><span class="line">&#123;</span><br><span class="line">    if (b)</span><br><span class="line">    &#123;</span><br><span class="line">        a = a * 2;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        a = a * 3;</span><br><span class="line">    &#125;</span><br><span class="line">    if (b)</span><br><span class="line">    &#123;</span><br><span class="line">        return a + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        return a - 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器可能会把这个简化成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// Example 8.11b</span><br><span class="line"></span><br><span class="line">int SomeFunction (int a, bool b)</span><br><span class="line">&#123;</span><br><span class="line">    if (b)</span><br><span class="line">    &#123;</span><br><span class="line">        a = a * 2;</span><br><span class="line">        return a + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        a = a * 3;</span><br><span class="line">        return a - 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-9循环展开"><a href="#1-9循环展开" class="headerlink" title="1.9循环展开"></a>1.9循环展开</h4><p>如果循环体非常小，或者它使进一步优化成为可能，那么这可能是有利的。重复计数非常小的循环可以完全展开，以避免循环开销。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Example 8.12a</span><br><span class="line"></span><br><span class="line">int i, a[2];</span><br><span class="line">for (i = 0; i &lt; 2; i++)</span><br><span class="line">    a[i] = i+1;</span><br></pre></td></tr></table></figure><p>编译器可能会把这个简化成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Example 8.12b</span><br><span class="line"></span><br><span class="line">int a[2];</span><br><span class="line">a[0] = 1;</span><br><span class="line">a[1] = 2;</span><br></pre></td></tr></table></figure><p>这样就可以发挥流水线的优势。</p><p>不幸的是，一些编译器展开太多。过多的循环展开不是最优的，因为它会占用太多的代码缓存空间，并且会填满某些微处理器的循环缓冲区。在某些情况下，关闭编译器中的循环展开选项是有用的。</p><h4 id="1-10移动循环中的不变代码"><a href="#1-10移动循环中的不变代码" class="headerlink" title="1.10移动循环中的不变代码"></a>1.10移动循环中的不变代码</h4><p>如果计算独立于循环计数器，则可以将其移出循环。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Example 8.13a</span><br><span class="line"></span><br><span class="line">int i, a[100], b;</span><br><span class="line">for (i = 0; i &lt; 100; i++)</span><br><span class="line">&#123;</span><br><span class="line">    a[i] = b * b + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可能会被编译器改成这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Example 8.13b</span><br><span class="line"></span><br><span class="line">int i, a[100], b, temp;</span><br><span class="line">temp = b * b + 1;</span><br><span class="line">for (i = 0; i &lt; 100; i++)</span><br><span class="line">&#123;</span><br><span class="line">    a[i] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-11归纳变量（Induction-variables）"><a href="#1-11归纳变量（Induction-variables）" class="headerlink" title="1.11归纳变量（Induction variables）"></a>1.11归纳变量（Induction variables）</h4><p>循环计数器的线性函数表达式可以通过在前一个值上添加一个常数来计算。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Example 8.14a</span><br><span class="line"></span><br><span class="line">int i, a[100];</span><br><span class="line">for (i = 0; i &lt; 100; i++)</span><br><span class="line">&#123;</span><br><span class="line">    a[i] = i * 9 + 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器可能会将其改成下面的形式以避免乘法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Example 8.14b</span><br><span class="line"></span><br><span class="line">int i, a[100], temp;</span><br><span class="line">temp = 3;</span><br><span class="line">for (i = 0; i &lt; 100; i++)</span><br><span class="line">&#123;</span><br><span class="line">    a[i] = temp;</span><br><span class="line">    temp += 9;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>归纳变量常用于计算数组元素的地址。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Example 8.15a</span><br><span class="line"></span><br><span class="line">struct S1 &#123;double a; double b;&#125;;</span><br><span class="line">S1 list[100]; int i;</span><br><span class="line">for (i = 0; i &lt; 100; i++)</span><br><span class="line">&#123;</span><br><span class="line">    list[i].a = 1.0;</span><br><span class="line">    list[i].b = 2.0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了访问 <code>list</code> 的元素，编译器必须计算它的地址。<code>list[i]</code> 的地址等于 <code>list</code> 的起始地址加上 <code>i*sizeof(S1)</code>。这是一个关于  <code>i</code> 的线性函数，这是可以通过归纳变量计算的。编译器可以使用相同的归纳变量来访问 <code>list[i].a</code> 和 <code>list[i].b</code>。当可以提前计算归纳变量的最终值时，也可以消去 <code>i</code>，用归纳变量作为循环计数器。这可以将代码简化为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Example 8.15b</span><br><span class="line"></span><br><span class="line">struct S1 &#123;double a; double b;&#125;;</span><br><span class="line">S1 list[100], *temp;</span><br><span class="line">for (temp = &amp;list[0]; temp &lt; &amp;list[100]; temp++)</span><br><span class="line">&#123;</span><br><span class="line">    temp-&gt;a = 1.0;</span><br><span class="line">    temp-&gt;b = 2.0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因子 <code>sizeof(S1) = 16</code> 实际上隐藏在<strong>例 8.15b</strong>中的<em>C++</em> 语法后面。<code>&amp;list[100]</code> 的整数表示形式为 <code>(int)(&amp;list[100]) = (int)(&amp;list[0]) + 100*16</code>，而 <code>temp++</code> 实际上是在 <code>temp</code> 的整数值上加上 16。</p><p>编译器不需要归纳变量来计算简单类型的数组元素的地址，当地址可以表示为一个基地址加上一个常数加上索引乘以一个系数1，2，4或8（但不是任何其他因数）， CPU 中有硬件支持这样的计算。如果在<strong>例 8.15a</strong>中的 <code>a</code> 和 <code>b</code> 是 <code>float</code> 而不是 <code>double</code>，那么 <code>sizeof(S1)</code> 的值将是 8，那么就不需要归纳变量了，因为 CPU 有硬件可以寄计算 <code>index</code> 乘上 8。</p><h4 id="1-12排序"><a href="#1-12排序" class="headerlink" title="1.12排序"></a>1.12排序</h4><p>编译器可以为了并行执行对指令重新排序。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Example 8.16</span><br><span class="line"></span><br><span class="line">float a, b, c, d, e, f, x, y;</span><br><span class="line">x = a + b + c;</span><br><span class="line">y = d + e + f;</span><br></pre></td></tr></table></figure><p>在这个例子中，编译器可以交错这两个公式，先算 <code>a + b</code>，然后是 <code>d + e</code>，然后将 <code>c</code> 加到第一个和中，之后 <code>f</code> 被加到第二个和中，第一个结果是存储在 <code>x</code> 中，最后第二个结果存储在 <code>y</code> 中。这样做的目的是帮助<em>CPU</em> 同时进行多个计算。现代<em>CPU</em> 实际上可以在没有编译器帮助的情况下对指令进行重新排序（参见<strong>乱序执行</strong>），但是编译器可以使<em>CPU</em> 更容易地对指令进行重新排序。</p><h4 id="1-13代数化简"><a href="#1-13代数化简" class="headerlink" title="1.13代数化简"></a>1.13代数化简</h4><p>多数编译器可以使用代数的基本定律来化简简单的代数表达式。例如，编译器可以将表达式 <code>-(-a)</code> 更改为 <code>a</code>。</p><p>我不认为程序员会经常写出像 <code>-(-a)</code> 这样的表达式，但是这种表达式可能是其他优化（如函数内联）的结果。可化简的表达式也经常作为宏展开的结果出现。</p><p>然而，程序员经常编写可以化简的表达式。这可能是因为未化简的表达式更好地解释了程序背后的逻辑，或者因为程序员没有考虑代数化简的可能性。例如，程序员可能更喜欢使用 <code>if(!a &amp;&amp; !b)</code> 而不是同等的 <code>if(!(a || b))</code> 即使后者少用一个运算符。幸运的是，在这种情况下，所有编译器都能够进行化简。</p><p>你不能指望编译器化简复杂的代数表达式。例如，在我测试的编译器中，只有一个编译器能够将 <code>(a*b*c)+(c*b*a)</code> 化简为 <code>a*b*c*2</code>。在编译器中实现很多代数规则是相当困难的。一些编译器可以化简某些类型的表达式，而另一些编译器可以化简其他类型的表达式，但我所见过的编译器都不能化简所有类型的表达式。在布尔代数中，可以实现一种通用算法（例如，<em>Quine-McCluskey</em> 或者 <em>Espresso</em>）来化简任何表达式，但我测试过的编译器似乎都没有这样做。</p><p>编译器在化简整数表达式上比浮点表达式做得更好，尽管这两种情况下的代数规则是相同的。这是因为浮点表达式的代数操作可能会产生我们不希望的效果。这种效果可以用下面的例子来说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Example 8.17</span><br><span class="line"></span><br><span class="line">char a = -100, b = 100, c = 100, y;</span><br><span class="line">y = a + b + c;</span><br></pre></td></tr></table></figure><p>这里 <code>y</code> 的值是 $-100+100+100 &#x3D; 100$。现在，根据代数规则，我们可以这样写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y = c + b + a;</span><br></pre></td></tr></table></figure><p>如果子表达式 <code>c+b</code> 可以在其他地方重用，那么这可能很有用。在这个例子中，我们使用的是 8 位整数，范围从-128到+127。整数溢出将使值反转（wrap around）。127 加 1 等于 -128，减 1 等于 -128。计算 <code>c+b</code> 会产生溢出，结果是 <code>-56</code> 而不是 <code>200</code>。接下来，我们将 <code>-100</code> 加到 <code>-56</code> 中，这将产生一个下溢，得到 <code>100</code>，而不是 <code>-156</code>。令人惊讶的是，我们得到了正确的结果，因为向上溢出和向下溢出相互抵消了。这就是为什么对整数表达式使用代数操作是安全的（<code>&lt;</code>、<code>&lt;=</code>、<code>&gt;</code> 和 <code>&gt;=</code> 运算符除外）。</p><p>同样的讨论不适用于浮点表达式。浮点变量在上溢和下溢时，不会反转。浮点变量的范围非常大，除了在特殊的数学应用中，我们不必太担心上溢和下溢。但是我们必须担心精度的损失。让我们用浮点数重复上面的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Example 8.18</span><br><span class="line"></span><br><span class="line">float a = -1.0E8, b = 1.0E8, c = 1.23456, y;</span><br><span class="line">y = a + b + c;</span><br></pre></td></tr></table></figure><p>这里的计算结果先得出 <code>a+b=0</code>，然后 <code>0+1.23456 = 1.23456</code>。但是如果我们改变操作数的顺序，先加 <code>b</code> 和 <code>c</code>，就不会得到相同的结果。<code>b + c = 100000001.23456</code>。浮点类型的精度大约为7位有效数字，因此 <code>b+c</code> 的值四舍五入为 <code>100000000</code>。把 <code>a</code> 加到这个数上得到 <code>0</code>，而不是 <code>1.23456</code>。</p><p>这里讨论的结果是，改变浮点操作数的顺序，就有丢失精度的风险。除非你指定一个允许不需要精确的浮点运算的选项，否则编译器不会这么做。即使打开了所有相关的优化选项，编译器也不会执行诸如 <code>0/a = 0</code>这样的明显简化，因为如果 <code>a</code> 为 0、无穷大或 <code>NAN</code>（不是一个数字），这将是无效的。不同的编译器的行为不同，因为对于哪些不精确应该被允许，哪些不应该被允许，存在不同的观点。</p><p>不能依赖编译器对浮点代码执行任何代数消减，只能依赖于对整数代码进行最简单的缩减。手动消减会更安全。我测试了在7个不同的编译器，简化各种代数表达式的能力。结果如下表8.1所示。</p><h4 id="1-14去虚拟化（Devirtualization）"><a href="#1-14去虚拟化（Devirtualization）" class="headerlink" title="1.14去虚拟化（Devirtualization）"></a>1.14去虚拟化（Devirtualization）</h4><p>如果知道所需要虚函数的版本，编译器优化可以绕过虚函数表查找，直接调用虚函数。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// Example 8.19. Devirtualization</span><br><span class="line"></span><br><span class="line">class C0</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void f();</span><br><span class="line">&#125;;</span><br><span class="line">class C1 : public C0</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void f();</span><br><span class="line">&#125;;</span><br><span class="line">void g()</span><br><span class="line">&#123;</span><br><span class="line">    C1 obj1;</span><br><span class="line">    C0 * p = &amp; obj1;</span><br><span class="line">    p-&gt;f(); // Virtual call to C1::f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不进行优化，编译器需要在虚函数表中查找 <code>p-&gt;f()</code> 调用是否要转到 <code>C0::f</code> 或 <code>C1::f</code>。但是编译器优化将看到 <code>p</code> 总是指向类 <code>C1</code> 的对象，因此它可以直接调用 <code>C1::f</code>，而不使用虚函数表。不幸的是，很少有编译器能够进行这种优化。</p><h3 id="2-不同编译器的比较"><a href="#2-不同编译器的比较" class="headerlink" title="2.不同编译器的比较"></a>2.不同编译器的比较</h3><p>Agner Fog对不同编译器做了比较，如下表，可以作为参考</p><table><thead><tr><th align="left"><strong>Optimization method</strong></th><th align="center"><strong>Microsoft</strong></th><th align="center"><strong>Borland</strong></th><th align="center"><strong>Intel</strong></th><th align="center"><strong>Gnu</strong></th><th align="center"><strong>PathScale</strong></th><th align="center"><strong>PGI</strong></th><th align="center"><strong>Digital Mars</strong></th><th align="center"><strong>Watcom</strong></th><th align="center"><strong>Codeplay</strong></th></tr></thead><tbody><tr><td align="left">Function inlining</td><td align="center">X</td><td align="center">-</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">-</td><td align="center">-</td><td align="center">X</td></tr><tr><td align="left">Constant folding</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td></tr><tr><td align="left">Constant propagation</td><td align="center">X</td><td align="center">-</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">-</td><td align="center">-</td><td align="center">X</td></tr><tr><td align="left">Pointer elimination</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td></tr><tr><td align="left">Common subexpression elimin, integer</td><td align="center">X</td><td align="center">(X)</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td></tr><tr><td align="left">Common subexpression elimin,  float</td><td align="center">X</td><td align="center">-</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">-</td><td align="center">X</td><td align="center">X</td></tr><tr><td align="left">Register variables, integer</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td></tr><tr><td align="left">Register variables, float</td><td align="center">X</td><td align="center">-</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">-</td><td align="center">X</td><td align="center">X</td></tr><tr><td align="left">Live range analysis</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td></tr><tr><td align="left">Join identical branches</td><td align="center">X</td><td align="center">-</td><td align="center">-</td><td align="center">X</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">X</td><td align="center">-</td></tr><tr><td align="left">Eliminate jumps</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">-</td><td align="center">X</td><td align="center">X</td></tr><tr><td align="left">Eliminate branches</td><td align="center">X</td><td align="center">-</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">-</td><td align="center">-</td><td align="center">-</td></tr><tr><td align="left">Remove branch that is always true&#x2F;false</td><td align="center">X</td><td align="center">-</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td></tr><tr><td align="left">Loop unrolling</td><td align="center">X</td><td align="center">-</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">-</td><td align="center">-</td><td align="center">X</td></tr><tr><td align="left">Loop invariant code motion</td><td align="center">X</td><td align="center">-</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td></tr><tr><td align="left">Induction variables for array elements</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td></tr><tr><td align="left">Induction variables for other integer expressions</td><td align="center">X</td><td align="center">-</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">-</td><td align="center">X</td><td align="center">X</td><td align="center">X</td></tr><tr><td align="left">Induction variables for float expressions</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td></tr><tr><td align="left">Automatic vectorization</td><td align="center">-</td><td align="center">-</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">-</td><td align="center">-</td><td align="center">X</td></tr><tr><td align="left">Devirtualization</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">X</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td></tr><tr><td align="left">Profile-guided optimization</td><td align="center">X</td><td align="center">-</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">-</td><td align="center">-</td><td align="center">-</td></tr><tr><td align="left">Whole program optimization</td><td align="center">X</td><td align="center">-</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td></tr><tr><td align="left"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="left"><strong>Integer algebra reductions:</strong></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="left"><code>a+b = b+a</code></td><td align="center">X</td><td align="center">(X)</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">-</td><td align="center">X</td><td align="center">X</td></tr><tr><td align="left"><code>a*b = b*a</code></td><td align="center">X</td><td align="center">(X)</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">-</td><td align="center">X</td><td align="center">X</td></tr><tr><td align="left"><code>a+b+c = a+(b+c)</code></td><td align="center">X</td><td align="center">-</td><td align="center">X</td><td align="center">X</td><td align="center">-</td><td align="center">-</td><td align="center">X</td><td align="center">X</td><td align="center">-</td></tr><tr><td align="left"><code>a+b+c = c+a+b</code></td><td align="center">X</td><td align="center">-</td><td align="center">-</td><td align="center">X</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td></tr><tr><td align="left"><code>a+b+c+d = (a+b)+(c+d)</code></td><td align="center">-</td><td align="center">-</td><td align="center">X</td><td align="center">X</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td></tr><tr><td align="left"><code>a*b+a*c = a*(b+c)</code></td><td align="center">X</td><td align="center">-</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">X</td></tr><tr><td align="left"><code>a*x*x*x+b*x*x+c*x+d = &lt;br&gt;((a*x+b)*x+c)*x+d&lt;/br&gt;</code></td><td align="center">X</td><td align="center">-</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">-</td><td align="center">X</td><td align="center">X</td><td align="center">X</td></tr><tr><td align="left"><code>X*X*X*X*X*X=((X&lt;sup&gt;2&lt;/sup&gt;)&lt;sup&gt;2&lt;/sup&gt;)&lt;sup&gt;2&lt;/sup&gt;</code></td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">X</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td></tr><tr><td align="left"><code>a+a+a+a=a*4</code></td><td align="center">X</td><td align="center">-</td><td align="center">X</td><td align="center">X</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">X</td></tr><tr><td align="left"><code>-(-a)=a</code></td><td align="center">X</td><td align="center">-</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">-</td></tr><tr><td align="left"><code>a-(-b)=a+b</code></td><td align="center">X</td><td align="center">-</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">-</td><td align="center">X</td><td align="center">-</td></tr><tr><td align="left"><code>a-a = 0</code></td><td align="center">X</td><td align="center">-</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td></tr><tr><td align="left"><code>a+0 = a</code></td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td></tr><tr><td align="left"><code>a*0 = 0</code></td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">-</td><td align="center">X</td></tr><tr><td align="left"><code>a*1 = a</code></td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td></tr><tr><td align="left"><code>(-a)*(-b) = a*b</code></td><td align="center">X</td><td align="center">-</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td></tr><tr><td align="left"><code>a/a = 1</code></td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">X</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">X</td></tr><tr><td align="left"><code>a/1 = a</code></td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td></tr><tr><td align="left"><code>0/a = 0</code></td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">X</td><td align="center">X</td><td align="center">-</td><td align="center">-</td><td align="center">X</td><td align="center">X</td></tr><tr><td align="left"><code>(-a == -b) = (a == b)</code></td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">X</td><td align="center">X</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td></tr><tr><td align="left"><code>(a-c == b+c) = (a == b)</code></td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">X</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td></tr><tr><td align="left"><code>!(a &lt; b) = (a &gt;= b)</code></td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td></tr><tr><td align="left"><code>(a&lt;b &amp;&amp; b&lt;c &amp;&amp; a&lt;c) = (a&lt;b &amp;&amp; b&lt;c)</code></td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td></tr><tr><td align="left">Multiply by constant &#x3D; shift and add</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">-</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">-</td></tr><tr><td align="left">Divide by constant &#x3D; multiply and shift</td><td align="center">X</td><td align="center">-</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">(-)</td><td align="center">X</td><td align="center">-</td><td align="center">-</td></tr><tr><td align="left"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="left"><strong>Floating point algebra reductions:</strong></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="left"><code>a+b = b+a</code></td><td align="center">X</td><td align="center">-</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">-</td><td align="center">-</td><td align="center">X</td></tr><tr><td align="left"><code>a*b = b*a</code></td><td align="center">X</td><td align="center">-</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">-</td><td align="center">-</td><td align="center">X</td></tr><tr><td align="left"><code>a+b+c = a+(b+c)</code></td><td align="center">X</td><td align="center">-</td><td align="center">X</td><td align="center">X</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td></tr><tr><td align="left"><code>(a+b)+c = a+(b+c)</code></td><td align="center">-</td><td align="center">-</td><td align="center">X</td><td align="center">X</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td></tr><tr><td align="left"><code>a*b*c = a*(b*c)</code></td><td align="center">X</td><td align="center">-</td><td align="center">X</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td></tr><tr><td align="left"><code>a+b+c+d = (a+b)+(c+d)</code></td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">X</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td></tr><tr><td align="left"><code>a*b+a*c = a*(b+c)</code></td><td align="center">X</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">X</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td></tr><tr><td align="left"><code>a*x*x*x+b*x*x+c*x+d = &lt;br&gt;((a*x+b)*x+c)*x+d&lt;/br&gt;</code></td><td align="center">X</td><td align="center">-</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td></tr><tr><td align="left"><code>X*X*X*X*X*X=((X&lt;sup&gt;2&lt;/sup&gt;)&lt;sup&gt;2&lt;/sup&gt;)&lt;sup&gt;2&lt;/sup&gt;</code></td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">X</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td></tr><tr><td align="left"><code>a+a+a+a=a*4</code></td><td align="center">X</td><td align="center">-</td><td align="center">X</td><td align="center">X</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td></tr><tr><td align="left"><code>-(-a)=a</code></td><td align="center">-</td><td align="center">-</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">-</td></tr><tr><td align="left"><code>a-(-b)=a+b</code></td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">-</td><td align="center">X</td><td align="center">-</td></tr><tr><td align="left"><code>a+0 = a</code></td><td align="center">X</td><td align="center">-</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">-</td></tr><tr><td align="left"><code>a*0 = 0</code></td><td align="center">-</td><td align="center">-</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">-</td><td align="center">X</td><td align="center">X</td></tr><tr><td align="left"><code>a*1 = a</code></td><td align="center">X</td><td align="center">-</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">-</td><td align="center">X</td></tr><tr><td align="left"><code>(-a)*(-b) = a*b</code></td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">-</td><td align="center">-</td><td align="center">-</td></tr><tr><td align="left"><code>a/a = 1</code></td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">X</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">X</td></tr><tr><td align="left"><code>a/1 = a</code></td><td align="center">X</td><td align="center">-</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">-</td><td align="center">X</td><td align="center">-</td><td align="center">-</td></tr><tr><td align="left"><code>0/a = 0</code></td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">X</td><td align="center">X</td><td align="center">-</td><td align="center">-</td><td align="center">X</td><td align="center">X</td></tr><tr><td align="left"><code>(-a == -b) = (a == b)</code></td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">X</td><td align="center">X</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td></tr><tr><td align="left"><code>(-a &gt; -b) = (a &lt; b)</code></td><td align="center">-</td><td align="center">-</td><td align="center">X</td><td align="center">X</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">X</td></tr><tr><td align="left">Divide by constant &#x3D; multiply by reciprocal</td><td align="center">X</td><td align="center">X</td><td align="center">-</td><td align="center">X</td><td align="center">X</td><td align="center">-</td><td align="center">-</td><td align="center">X</td><td align="center">-</td></tr><tr><td align="left"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="left"><strong>Boolean algebra reductions:</strong></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="left"><code>!(!a) = a</code></td><td align="center">X</td><td align="center">-</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td></tr><tr><td align="left"><code>(a&amp;&amp;b)||(a&amp;&amp;c) = a&amp;&amp;(b||c)</code></td><td align="center">X</td><td align="center">-</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td></tr><tr><td align="left"><code>!a &amp;&amp; !b = !(a||b)</code></td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td></tr><tr><td align="left"><code>a &amp;&amp; !a = false</code>,<code>a || !b = true</code></td><td align="center">X</td><td align="center">-</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">-</td><td align="center">-</td><td align="center">-</td></tr><tr><td align="left"><code>a &amp;&amp; true = a</code>,<code>a || false = a</code></td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">-</td></tr><tr><td align="left"><code>a &amp;&amp; false = false</code>,<code>a || true = true</code></td><td align="center">X</td><td align="center">-</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">-</td></tr><tr><td align="left"><code>a &amp;&amp; a = a</code></td><td align="center">X</td><td align="center">-</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">-</td><td align="center">-</td><td align="center">-</td></tr><tr><td align="left"><code>(a&amp;&amp;b) || (a&amp;&amp;!b) = a</code></td><td align="center">X</td><td align="center">-</td><td align="center">-</td><td align="center">X</td><td align="center">X</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td></tr><tr><td align="left"><code>(a&amp;&amp;b) || (!a&amp;&amp;c) = a ? b : c</code></td><td align="center">X</td><td align="center">-</td><td align="center">X</td><td align="center">X</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td></tr><tr><td align="left"><code>(a&amp;&amp;b) || (!a&amp;&amp;c) || (b&amp;&amp;c) = a ? b : c</code></td><td align="center">X</td><td align="center">-</td><td align="center">-</td><td align="center">X</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td></tr><tr><td align="left"><code>(a&amp;&amp;b) || (a&amp;&amp;b&amp;&amp;c) = a&amp;&amp;b</code></td><td align="center">X</td><td align="center">-</td><td align="center">-</td><td align="center">X</td><td align="center">X</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td></tr><tr><td align="left"><code>(a&amp;&amp;b) || (a&amp;&amp;c) || (a&amp;&amp;b&amp;&amp;c) = a&amp;&amp;(b||c)</code></td><td align="center">X</td><td align="center">-</td><td align="center">-</td><td align="center">X</td><td align="center">X</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td></tr><tr><td align="left"><code>(a&amp;&amp;!b) || (!a&amp;&amp;b) = a XOR b</code></td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td></tr><tr><td align="left"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="left"><strong>Bit vector algebra reductions:</strong></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="left"><code>~(~a) = a</code></td><td align="center">X</td><td align="center">-</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">-</td><td align="center">-</td></tr><tr><td align="left"><code>(a&amp;b)|(a&amp;c) = a&amp;(b|c)</code></td><td align="center">X</td><td align="center">-</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">-</td><td align="center">-</td><td align="center">X</td></tr><tr><td align="left"><code>(a|b)&amp;(a|c) = a|(b&amp;c)</code></td><td align="center">X</td><td align="center">-</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">-</td><td align="center">-</td><td align="center">X</td></tr><tr><td align="left"><code>~a &amp; ~b = ~(a | b)</code></td><td align="center">-</td><td align="center">-</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">-</td><td align="center">-</td><td align="center">-</td></tr><tr><td align="left"><code>a &amp; a = a</code></td><td align="center">X</td><td align="center">-</td><td align="center">-</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">-</td><td align="center">-</td><td align="center">X</td></tr><tr><td align="left"><code>a &amp; ~a = 0</code></td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">-</td><td align="center">-</td><td align="center">-</td></tr><tr><td align="left"><code>a &amp; -1 = a</code>,<code>a | 0 = a</code></td><td align="center">X</td><td align="center">-</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td></tr><tr><td align="left"><code>a &amp; 0 = 0</code>,<code>a | -1 = -1</code></td><td align="center">X</td><td align="center">-</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td></tr><tr><td align="left"><code>(a&amp;b) | (~a&amp;c) | (b&amp;c) = (a&amp;b) | (~a&amp;c)</code></td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td></tr><tr><td align="left"><code>a&amp;b&amp;c&amp;d = (a&amp;b)&amp;(c&amp;d)</code></td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">X</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td></tr><tr><td align="left"><code>a ^ 0 = a</code></td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">-</td><td align="center">X</td><td align="center">X</td><td align="center">X</td></tr><tr><td align="left"><code>a ^ -1 = ~a</code></td><td align="center">X</td><td align="center">-</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">-</td><td align="center">X</td><td align="center">X</td><td align="center">-</td></tr><tr><td align="left"><code>a ^ a = 0</code></td><td align="center">X</td><td align="center">-</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">-</td><td align="center">X</td><td align="center">X</td></tr><tr><td align="left"><code>a ^ ~a = -1</code></td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">-</td><td align="center">-</td><td align="center">-</td></tr><tr><td align="left"><code>(a&amp;~b) | (~a&amp;b) = a ^ b</code></td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td></tr><tr><td align="left"><code>~a ^ ~b = a ^ b</code></td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">X</td><td align="center">X</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td></tr><tr><td align="left"><code>a&lt;&lt;b&lt;&lt;c = a&lt;&lt;(b+c)</code></td><td align="center">X</td><td align="center">-</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">-</td><td align="center">-</td><td align="center">X</td><td align="center">X</td></tr><tr><td align="left"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="left"><strong>Integer XMM (vector) reductions:</strong></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="left">Common subexpression elimination</td><td align="center">X</td><td align="center">n.a.</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">-</td><td align="center">n.a.</td><td align="center">n.a.</td><td align="center">X</td></tr><tr><td align="left">Constant folding</td><td align="center">-</td><td align="center">n.a.</td><td align="center">-</td><td align="center">X</td><td align="center">-</td><td align="center">-</td><td align="center">n.a.</td><td align="center">n.a.</td><td align="center">-</td></tr><tr><td align="left"><code>a+b = b+a</code>, <code>a*b = b*a</code></td><td align="center">-</td><td align="center">n.a.</td><td align="center">-</td><td align="center">X</td><td align="center">-</td><td align="center">-</td><td align="center">n.a.</td><td align="center">n.a.</td><td align="center">X</td></tr><tr><td align="left"><code>(a+b)+c = a+(b+c)</code></td><td align="center">-</td><td align="center">n.a.</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">n.a.</td><td align="center">n.a.</td><td align="center">-</td></tr><tr><td align="left"><code>a*b+a*c = a*(b+c)</code></td><td align="center">-</td><td align="center">n.a.</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">n.a.</td><td align="center">n.a.</td><td align="center">-</td></tr><tr><td align="left"><code>X*X*X*X*X*X=((X&lt;sup&gt;2&lt;/sup&gt;)&lt;sup&gt;2&lt;/sup&gt;)&lt;sup&gt;2&lt;/sup&gt;</code></td><td align="center">-</td><td align="center">n.a.</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">n.a.</td><td align="center">n.a.</td><td align="center">-</td></tr><tr><td align="left"><code>a+a+a+a = a*4</code></td><td align="center">-</td><td align="center">n.a.</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">n.a.</td><td align="center">n.a.</td><td align="center">-</td></tr><tr><td align="left"><code>-(-a) = a</code></td><td align="center">-</td><td align="center">n.a.</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">n.a.</td><td align="center">n.a.</td><td align="center">-</td></tr><tr><td align="left"><code>a-a = 0</code></td><td align="center">-</td><td align="center">n.a.</td><td align="center">X</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">n.a.</td><td align="center">n.a.</td><td align="center">-</td></tr><tr><td align="left"><code>a+0 = a</code></td><td align="center">-</td><td align="center">n.a.</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">n.a.</td><td align="center">n.a.</td><td align="center">-</td></tr><tr><td align="left"><code>a*0 = 0</code></td><td align="center">-</td><td align="center">n.a.</td><td align="center">-</td><td align="center">X</td><td align="center">-</td><td align="center">-</td><td align="center">n.a.</td><td align="center">n.a.</td><td align="center">-</td></tr><tr><td align="left"><code>a*1 = a</code></td><td align="center">-</td><td align="center">n.a.</td><td align="center">-</td><td align="center">X</td><td align="center">-</td><td align="center">-</td><td align="center">n.a.</td><td align="center">n.a.</td><td align="center">-</td></tr><tr><td align="left"><code>(-a)*(-b) = a*b</code></td><td align="center">-</td><td align="center">n.a.</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">n.a.</td><td align="center">n.a.</td><td align="center">-</td></tr><tr><td align="left"><code>!(a &lt; b) = (a &gt;= b)</code></td><td align="center">-</td><td align="center">n.a.</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">n.a.</td><td align="center">n.a.</td><td align="center">-</td></tr><tr><td align="left"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="left"><strong>Floating point XMM (vector) reductions:</strong></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="left"><code>a+b = b+a</code>, <code>a*b = b*a</code></td><td align="center">X</td><td align="center">n.a.</td><td align="center">-</td><td align="center">X</td><td align="center">-</td><td align="center">-</td><td align="center">n.a.</td><td align="center">n.a.</td><td align="center">X</td></tr><tr><td align="left"><code>(a+b)+c = a+(b+c)</code></td><td align="center">-</td><td align="center">n.a.</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">n.a.</td><td align="center">n.a.</td><td align="center">-</td></tr><tr><td align="left"><code>a*b+a*c = a*(b+c)</code></td><td align="center">-</td><td align="center">n.a.</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">n.a.</td><td align="center">n.a.</td><td align="center">-</td></tr><tr><td align="left"><code>-(-a) = a</code></td><td align="center">-</td><td align="center">n.a.</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">n.a.</td><td align="center">n.a.</td><td align="center">-</td></tr><tr><td align="left"><code>a-a = 0</code></td><td align="center">-</td><td align="center">n.a.</td><td align="center">-</td><td align="center">X</td><td align="center">-</td><td align="center">-</td><td align="center">n.a.</td><td align="center">n.a.</td><td align="center">-</td></tr><tr><td align="left"><code>a+0 = a</code></td><td align="center">-</td><td align="center">n.a.</td><td align="center">X</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">n.a.</td><td align="center">n.a.</td><td align="center">-</td></tr><tr><td align="left"><code>a*0 = 0</code></td><td align="center">-</td><td align="center">n.a.</td><td align="center">X</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">n.a.</td><td align="center">n.a.</td><td align="center">-</td></tr><tr><td align="left"><code>a*1 = a</code></td><td align="center">-</td><td align="center">n.a.</td><td align="center">-</td><td align="center">X</td><td align="center">-</td><td align="center">-</td><td align="center">n.a.</td><td align="center">n.a.</td><td align="center">-</td></tr><tr><td align="left"><code>a/1 = a</code></td><td align="center">-</td><td align="center">n.a.</td><td align="center">-</td><td align="center">X</td><td align="center">-</td><td align="center">-</td><td align="center">n.a.</td><td align="center">n.a.</td><td align="center">-</td></tr><tr><td align="left"><code>0/a = 0</code></td><td align="center">-</td><td align="center">n.a.</td><td align="center">X</td><td align="center">X</td><td align="center">-</td><td align="center">-</td><td align="center">n.a.</td><td align="center">n.a.</td><td align="center">-</td></tr><tr><td align="left">Divide by constant &#x3D; multiply by reciprocal</td><td align="center">-</td><td align="center">n.a.</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">n.a.</td><td align="center">n.a.</td><td align="center">-</td></tr><tr><td align="left"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="left"><strong>Boolean XMM (vector) reductions:</strong></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="left"><code>~(~a) = a</code></td><td align="center">-</td><td align="center">n.a.</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">n.a.</td><td align="center">n.a.</td><td align="center">-</td></tr><tr><td align="left"><code>(a&amp;b)|(a&amp;c) = a&amp;(b|c)</code></td><td align="center">-</td><td align="center">n.a.</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">n.a.</td><td align="center">n.a.</td><td align="center">-</td></tr><tr><td align="left"><code>a &amp; a = a</code>, <code>a | a = a</code></td><td align="center">-</td><td align="center">n.a.</td><td align="center">X</td><td align="center">X</td><td align="center">-</td><td align="center">-</td><td align="center">n.a.</td><td align="center">n.a.</td><td align="center">-</td></tr><tr><td align="left"><code>a &amp; ~a = 0</code></td><td align="center">-</td><td align="center">n.a.</td><td align="center">-</td><td align="center">X</td><td align="center">-</td><td align="center">-</td><td align="center">n.a.</td><td align="center">n.a.</td><td align="center">-</td></tr><tr><td align="left"><code>a &amp; -1 = a</code>, <code>a | 0 = a</code></td><td align="center">-</td><td align="center">n.a.</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">n.a.</td><td align="center">n.a.</td><td align="center">-</td></tr><tr><td align="left"><code>a &amp; 0 = 0</code></td><td align="center">-</td><td align="center">n.a.</td><td align="center">-</td><td align="center">X</td><td align="center">-</td><td align="center">-</td><td align="center">n.a.</td><td align="center">n.a.</td><td align="center">-</td></tr><tr><td align="left"><code>a | -1 = -1</code></td><td align="center">-</td><td align="center">n.a.</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">n.a.</td><td align="center">n.a.</td><td align="center">-</td></tr><tr><td align="left"><code>a ^ a = 0</code></td><td align="center">-</td><td align="center">n.a.</td><td align="center">X</td><td align="center">X</td><td align="center">-</td><td align="center">-</td><td align="center">n.a.</td><td align="center">n.a.</td><td align="center">-</td></tr><tr><td align="left"><code>andnot(a,a) = 0</code></td><td align="center">-</td><td align="center">n.a.</td><td align="center">-</td><td align="center">X</td><td align="center">-</td><td align="center">-</td><td align="center">n.a.</td><td align="center">n.a.</td><td align="center">-</td></tr><tr><td align="left"><code>a&lt;&lt;b&lt;&lt;c = a&lt;&lt;(b+c)</code></td><td align="center">-</td><td align="center">n.a.</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">n.a.</td><td align="center">n.a.</td><td align="center">-</td></tr></tbody></table><p><strong>Tabel 8.1. Comparison of optimizations in different C++ compilers</strong></p><p>测试中所有相关的优化选项都被打开，包括放宽浮点精度。被测试的编译器版本如下：</p><ol><li>Microsoft C++ Compiler v. 14.00 for 80x86 &#x2F; x64 (Visual Studio 2005).</li><li>Borland C++ 5.82 (Embarcadero&#x2F;CodeGear&#x2F;Borland C++ Builder 5, 2009).</li><li>Intel C++ Compiler v. 11.1 for IA-32&#x2F;Intel64, 2009.</li><li>Gnu C++ v. 4.1.0, 2006 (Red Hat).</li><li>PathScale C++ v. 3.1, 2007.</li><li>PGI C++ v. 7.1-4, 2008.</li><li>Digital Mars Compiler v. 8.42n, 2004.</li><li>Open Watcom C&#x2F;C++ v. 1.4, 2005.</li><li>Codeplay VectorC v. 2.1.7, 2004.</li></ol><p>没有发现<em>Microsoft</em>、<em>Intel</em>、<em>Gnu</em> 和<em>PathScale</em> 编译器的 32位和 64位代码的优化功能有任何差异。</p><h3 id="3-编译器优化的障碍"><a href="#3-编译器优化的障碍" class="headerlink" title="3.编译器优化的障碍"></a>3.编译器优化的障碍</h3><h4 id="3-1无法跨模块优化"><a href="#3-1无法跨模块优化" class="headerlink" title="3.1无法跨模块优化"></a>3.1无法跨模块优化</h4><p>编译器除了正在编译的模块外，没有关于其他模块中的函数的信息。这阻止了它对函数调用进行优化。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// Example 8.20</span><br><span class="line">//module1.cpp</span><br><span class="line"></span><br><span class="line">int Func1(int x)</span><br><span class="line">&#123;</span><br><span class="line">    return x*x + 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//module2.cpp</span><br><span class="line">int Func2()</span><br><span class="line">&#123;</span><br><span class="line">    int a = Func1(2);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>假如 <code>Func1</code> 和 <code>Func2</code> 在同一个模块中，那么编译器将能够进行函数内联和常量传播，并将 <code>a</code> 化简为常量5。但是在编译 <em>module2.cpp</em> 时，编译器没有关于 <code>Func1</code> 的必要信息。</p><p>解决这个问题最简单的方法是使用 <code>#include</code> 指令将多个 <em>.cpp</em> 模块组合成一个模块。这个方法适用于所有编译器。有些编译器有一个称为“全程序优化”的特性，它将支持跨模块的优化</p><h4 id="3-2指针别名（pointer-aliasing）"><a href="#3-2指针别名（pointer-aliasing）" class="headerlink" title="3.2指针别名（pointer aliasing）"></a>3.2指针别名（pointer aliasing）</h4><p>当通过指针或引用访问变量时，编译器可能无法完全排除所指向的变量与代码中的其他变量相同的可能性。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// Example 8.21</span><br><span class="line"></span><br><span class="line">void Func1 (int a[], int * p)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    for (i = 0; i &lt; 100; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i] = *p + 2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Func2()</span><br><span class="line">&#123;</span><br><span class="line">    int list[100];</span><br><span class="line">    Func1(list, &amp;list[8]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，需要重新加载 <code>*p</code> 并计算 <code>*p+2</code> 100次，因为 <code>p</code> 所指向的值与循环过程中会发生变化的 <code>a[]</code> 中的一个元素相同。不允许假定 <code>*p+2</code> 是可以移出循环的循环不变代码。<strong>例 8.21</strong>确实是一个非常刻意的例子，但关键是编译器不能排除这种刻意的例子存在的理论可能性。因此，编译器不能假设 <code>*p+2</code> 是一个可以移动到循环外部的循环不变表达式。</p><p>大多数编译器都有一个假设没有指针别名（*&#x2F;Oa* ）的选项。克服可能的指针别名障碍的最简单方法是打开这个选项。这要求你仔细分析代码中的所有指针和引用，以确保在代码的同一部分中没有以一种以上的方式访问任何变量或对象。如果编译器支持的，还可以通过使用关键字 <code>__restrict</code> 或 <code>__restrict__</code> 告诉编译器某个特定指针不是任何变量的别名。</p><p>我们永远不能确定编译器是否接受关于没有指针别名的提示。确保代码得到优化的唯一方法是显式地进行优化。在<strong>例 8.21</strong>中，如果你确信指针不是数组中的任何元素的别名，那么可以先计算 <code>*p+2</code> 并将其存储在循环外部的临时变量中。这种方法要求你能够预先知道优化的障碍在哪里。</p><h4 id="3-3动态内存分配"><a href="#3-3动态内存分配" class="headerlink" title="3.3动态内存分配"></a>3.3动态内存分配</h4><p>动态分配（使用<code>new</code>或<code>malloc</code>）的任何数组或对象都必须通过指针进行访问。对于程序员来说，指向不同动态分配的对象的指针没有重叠或混淆是很明显的，但是编译器通常看不到这一点。它还阻止了编译器以最佳的方式来对齐数据，或者阻止编译器知道对象是对齐的。最好在需要的函数中声明对象和固定大小的数组。</p><h4 id="3-4纯函数（Pure-functions）"><a href="#3-4纯函数（Pure-functions）" class="headerlink" title="3.4纯函数（Pure functions）"></a>3.4纯函数（Pure functions）</h4><p>纯函数的定义是：</p><ol><li>如果函数的调用参数相同，则永远返回相同的结果。它不依赖于程序执行期间函数外部任何状态或数据的变化，必须只依赖于其输入参数。</li><li>该函数不会产生任何可观察的副作用，例如网络请求，输入和输出设备或数据突变（mutation）。</li></ol><p>多次使用相同参数调用纯函数肯定会得到相同的结果。编译器可以消除包含纯函数调用的常见子表达式，并且可以移出包含纯函数调用的循环不变代码。不幸的是，如果函数是在不同的模块或函数库中定义的，编译器则无法知道函数是否为纯函数。</p><p>因此，当涉及纯函数调用时，如公共子表达式消除、常量传播和移动循环不变代码这种优化应该手动优化。</p><p><em>Gnu</em> 编译器和用于<em>Linux</em> 的<em>Intel</em> 编译器都有一个属性，该属性可以用于声明函数原型，以告诉编译器这是一个纯函数。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// Example 8.22</span><br><span class="line"></span><br><span class="line">#ifdef __GNUC__</span><br><span class="line">#define pure_function __attribute__((const))</span><br><span class="line">#else</span><br><span class="line">#define pure_function</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">double Func1(double) pure_function ;</span><br><span class="line">double Func2(double x)</span><br><span class="line">&#123;</span><br><span class="line">    return Func1(x) * Func1(x) + 1.;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，<em>Gnu</em> 编译器将只调用 <code>Func1</code>一次，而其他编译器将会调用两次。</p><p>其他一些编译器（<em>Microsoft</em>，<em>Intel</em> )知道像 <code>sqrt</code>、<code>pow</code>和 <code>log</code> 这样的标准库函数是纯函数，但不幸的是，无法告诉这些编译器用户定义的函数是纯函数。</p><h4 id="3-5虚函数和函数指针"><a href="#3-5虚函数和函数指针" class="headerlink" title="3.5虚函数和函数指针"></a>3.5虚函数和函数指针</h4><p>编译器几乎不可准确地预测将调用虚函数的哪个版本，或者函数指针指向什么。因此，它不能内联这些函数，也不能对函数调用进行优化。</p><h4 id="3-6代数化简"><a href="#3-6代数化简" class="headerlink" title="3.6代数化简"></a>3.6代数化简</h4><p>大多数编译器可以做简单的代数化简，比如<code>-(a) = a</code>，但是它们不能做更复杂的化简。代数化简是一个复杂的过程，这很难在编译器中实现。</p><p>由于数学的纯粹性（mathematical purity），许多代数化简是不被允许的。在许多情况下，可以构造一些晦涩的例子，其中化简会导致溢出或精度损失，特别是在浮点表达式中（参见第74页TODO）。编译器不能排除特定情况下某个特定化简无效的可能性，但是程序员可以。因此，在许多情况下有必要显式地进行代数化简。</p><p>整数表达式不太容易出现溢出和精度损失的问题，原因见<strong>代数化简</strong>。因此，编译器可以对整数表达式进行比浮点数表达式更多的化简。大多数涉及整数加法、减法和乘法的化简在所有情况下都是被允许的，而许多涉及除法和关系运算符（如“<code>&gt;</code>”）的化简，由于数学的纯粹性是不被允许的。例如，由于存在隐藏的溢出的可能性，编译器不能将整数表达式 <code>-a &gt; -b</code> 化简为 <code>a &lt; b</code>。</p><p><strong>六.2不同编译器的比较</strong>显示了编译器在某些情况下，能够进行哪些化简，以及不能进行哪些化简。编译器无法完成的所有化简都必须由程序员手动完成。</p><h4 id="3-7浮点归纳变量"><a href="#3-7浮点归纳变量" class="headerlink" title="3.7浮点归纳变量"></a>3.7浮点归纳变量</h4><p>编译器不能生成浮点归纳变量的原因与它们不能对浮点表达式进行代数化简的原因相同。因此，有必要手动完成这项工作。当循环计数器的函数通过以前的值计算比使用循环计数器计算更有效时，这个方法就很有用。循环计数器的$n$次多项式的任何表达式都可以通过$n$次加法来计算，而不需要使用乘法。下面的例子展示了使用加法二阶多项式的原理：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Example 8.23a. Loop to make table of polynomial</span><br><span class="line"></span><br><span class="line">const double A = 1.1, B = 2.2, C = 3.3;  // Polynomial coefficients</span><br><span class="line">double Table[100];                       // Table</span><br><span class="line">int x; // Loop counter</span><br><span class="line">for (x = 0; x &lt; 100; x++)</span><br><span class="line">&#123;</span><br><span class="line">    Table[x] = A*x*x + B*x + C;          // Calculate polynomial</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个多项式的计算通过两个归纳变量，只需要两个加法就可以完成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// Example 8.23b. Calculate polynomial with induction variables</span><br><span class="line"></span><br><span class="line">const double A = 1.1, B = 2.2, C = 3.3; // Polynomial coefficients</span><br><span class="line">double Table[100];                      // Table</span><br><span class="line">int x;                                  // Loop counter</span><br><span class="line">const double A2 = A + A;                // = 2*A</span><br><span class="line">double Y = C;                           // = A*x*x + B*x + C</span><br><span class="line">double Z = A + B;                       // = Delta Y</span><br><span class="line">for (x = 0; x &lt; 100; x++)</span><br><span class="line">&#123;</span><br><span class="line">    Table[x] = Y;                       // Store result</span><br><span class="line">    Y += Z;                             // Update induction variable Y</span><br><span class="line">    Z += A2;                            // Update induction variable Z</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>例8.23b</strong>中的循环中有两个循环依赖链（<em>loop-carried dependency chain</em>），即两个归纳变量 <code>Y</code> 和 <code>Z</code>。每个依赖链都有一个延迟，这个延迟与浮点加法的延迟相同。这个延迟足够小，说明该方法是合适的。一个较长的循环依赖链会使归纳变量方法变得不利，除非该值是从一个两次或多次迭代的值计算出来的。</p><p>如果你考虑到每个值都是从序列中位于 <code>r</code> 位置之前的值计算出来的，其中 <code>r</code> 是一个向量中的元素数或循环展开因子，那么归纳变量的方法也可以向量化。要在每种情况下找到正确的公式，需要一点数学知识。</p><h4 id="3-8内联函数的非内联副本"><a href="#3-8内联函数的非内联副本" class="headerlink" title="3.8内联函数的非内联副本"></a>3.8内联函数的非内联副本</h4><p>函数内联的复杂性在于，同一个函数可能从另一个模块调用。为了在另一个模块中调用该函数，编译器必须生成一个内联函数的非内联的副本，如果没有其他模块调用这个函数，那么这个非内联副本就是无用代码。这种代码片段降低了缓存的效率。</p><p>有很多方法可以解决这个问题。如果一个函数没有被任何其他模块引用，那么将关键字 <code>static</code> 添加到函数定义中。这将告诉编译器不能从任何其他模块调用该函数。静态声明使编译器更容易评估使函数内联是否是最优的，并防止编译器生成未使用的内联函数副本。<code>static</code>关键字还使各种其他优化成为可能，由于这些函数在其他模块中是无法访问的，因此编译器不必遵守任何特定的函数调用约定。可以用 <code>static</code> 声明所有本地非成员函数。</p><p>不幸的是，这个方法并不适用于类成员函数，因为 <code>static</code> 关键字对于成员函数有不同的含义。可以通过在类定义中声明函数体来强制使成员函数内联。这将防止编译器生成函数的非内联副本，但它的缺点是，即使在不适合内联的情况下（例如，如果成员函数很大，并且从许多不同的地方调用），函数也总是内联的。</p><p>一些编译器有一个选项(<em>Windows</em>：<code>/Gy</code>,* Linux*：<code>- fffunction -sections</code>)，允许链接器删除未引用的函数。建议打开此选项</p><h3 id="4-cpu优化的障碍"><a href="#4-cpu优化的障碍" class="headerlink" title="4.cpu优化的障碍"></a>4.cpu优化的障碍</h3><p>现代 <em>CPU</em> 可以通过乱序执行指令来进行很多优化，阻碍其优化的障碍就是第五节提到的依赖链。因此要避免长依赖链尤其是具有长延迟的循环依赖链。</p><h3 id="5-编译器优化选项"><a href="#5-编译器优化选项" class="headerlink" title="5.编译器优化选项"></a>5.编译器优化选项</h3><p>一下介绍下常见的编译器优化选项</p><p>debug与release，调试版本在开发期间使用，发行版本最终使用。</p><p>大小优化与速度优化，当代码非常快时，希望可执行文件尽量小，或者当代码缓存非常关键时也希望软件大小尽量小。当cpu访问和内存访问消耗巨大时，应进行速度优化。</p><p>一些编译器提供配置分析引导的优化。其工作方式如下。首先，编译程序并使之支持分析。然后使用分析器进行测试运行，分析器确定程序流以及每个函数和分支执行的次数。然后，编译器可以使用这些信息来优化代码，并将不同的函数按最佳顺序排列。</p><p>一些编译器支持全程序优化。这可以通过两个步骤进行编译。所有源文件首先被编译成中间文件格式，而不是通常的目标文件格式。然后在第二步中将中间文件链接在一起后完成编译。寄存器分配和函数内联是在第二步中完成的。中间文件格式没有标准化。它甚至不兼容同一编译器的不同版本。因此，不可能以这种格式分发函数库。</p><p>其他编译器提供了将多个 <code>.cpp</code> 文件编译为单个对象文件的可能性。这使编译器能够在启用过程间优化时进行跨模块优化。一种更原始但更有效的方法是通过 <code>#include</code> 指令将所有源文件连接到一个文件中，并声明所有函数为静态或内联的。这将使编译器能够对整个程序进行过程间优化。</p><p>可以使用SSE2，AVX等向量指令集进行优化。</p><p>可以选择使用较新的指令集（当不需要兼容旧版本的cpu时）</p><p>可以选择关闭异常处理使代码更高效，前提是不需要异常处理。</p><p>可以关闭对运行时类型识别（<strong>RTTI</strong>）的支持。</p><p>如果你确定代码没有指针别名，请使用“假设没有指针混叠“（<em>assume no pointer aliasing</em>）选项。（在3.2中提到过）</p><p>如果选项“函数级链接”（<em>function level linking</em>）可用，可以打开该选项。</p><p>许多编译器都有“标准栈帧”（<em>standard stack frame</em>）或“帧指针“（<em>frame pointer</em>）选项。标准栈帧用于调试和异常处理。省略标准堆栈帧可以使函数调用更快，并节省出一个额外的寄存器用于其他目的。这是有利的，因为寄存器是一种稀缺资源。除非程序依赖异常处理，否则不要使用堆栈帧。</p><h3 id="6-优化指令"><a href="#6-优化指令" class="headerlink" title="6.优化指令"></a>6.优化指令</h3><p>某些关键字可以使编译器给出特定的优化，当然许多指令使特定于编译器的。</p><h4 id="6-1适用于所有c-编译器的关键字"><a href="#6-1适用于所有c-编译器的关键字" class="headerlink" title="6.1适用于所有c++编译器的关键字"></a>6.1适用于所有c++编译器的关键字</h4><p><code>register</code>：告诉编译器这是寄存器变量</p><p><code>volatile</code>：告诉编译器不要优化此变量，此变量会一直在内存中</p><p><code>const</code>：常量，编译器在许多情况下会优化常量，如常量展开和常量传递。</p><p><code>static</code>：使用static修饰内联函数会使内联函数更加高效</p><h4 id="6-2特定编译器的关键字"><a href="#6-2特定编译器的关键字" class="headerlink" title="6.2特定编译器的关键字"></a>6.2特定编译器的关键字</h4><p>快速函数调用。<code>__fastcall</code>或者 <code>__attribute__((fastcall))</code>。<code>fastcall</code> 修饰符可以使函数调用在 32位模式下更快。前两个整型参数将会在寄存器而不是栈中传递（对于 <code>CodeGear编译器</code> 则是前三个参数）。快速调用函数在编译器之间不兼容。在 64位模式下不需要快速调用，因为参数已经在寄存器中传递的。</p><p>纯函数。<code>__attribute__((const))</code>（Linux only），制定函数位纯函数。这将允许消除公共子表达式和移动循环不变代码。</p><p>假设没有指针别名。<code>__declspec(noalias)</code> 或 <code>__restrict</code> 或 <code>#pragma optimize(&quot;a&quot;, on)</code>，假设没有指针别名。</p><p>数据对齐。<code>__declspec(align(16))</code> 或 <code>__atrribute__((aligned(16)))</code>，指定数组和结构体的对齐。</p><h3 id="7-如何知道编译器做了什么"><a href="#7-如何知道编译器做了什么" class="headerlink" title="7.如何知道编译器做了什么"></a>7.如何知道编译器做了什么</h3><p>可以在编译器选中中加flag设置输出汇编语言。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h2 id=&quot;六、编译器层次的优化&quot;&gt;&lt;a href=&quot;#六、编译器层次的优化&quot; class=&quot;headerlink&quot; title=&quot;六、编译器层次的优化&quot;&gt;&lt;/a&gt;六、编译器层次的优化&lt;/h2&gt;&lt;h3 id=&quot;1-编译器如何优化&quot;&gt;&lt;a href=&quot;#1-编译器如何优化&quot;</summary>
        
      
    
    
    
    
    <category term="hpc" scheme="https://mightcoder.com/tags/hpc/"/>
    
    <category term="cpp" scheme="https://mightcoder.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>optimizing_cpp(5)</title>
    <link href="https://mightcoder.com/2022/03/29/optimizing-cpp-5/"/>
    <id>https://mightcoder.com/2022/03/29/optimizing-cpp-5/</id>
    <published>2022-03-29T03:11:37.000Z</published>
    <updated>2022-07-15T08:13:03.058Z</updated>
    
    <content type="html"><![CDATA[<h2 id="五-不同c-结构的效率"><a href="#五-不同c-结构的效率" class="headerlink" title="五.不同c++结构的效率"></a>五.不同c++结构的效率</h2><h3 id="1-不同种类变量存储"><a href="#1-不同种类变量存储" class="headerlink" title="1.不同种类变量存储"></a>1.不同种类变量存储</h3><p>变量和对象如果在cpp中声明的方式不同，它们在内存中的位置也不同，这会影响数据缓存的效率，如果数据在内存中分散那么数据缓存效率就会很差，所以要了解变量存储的方式。</p><h4 id="1-1栈（stack）"><a href="#1-1栈（stack）" class="headerlink" title="1.1栈（stack）"></a>1.1栈（stack）</h4><p>在函数内部声明的变量和对象存储在栈上（特殊情况会在下面声明）</p><p>栈是前进后出的（FILO），主要存储函数返回地址（即函数被调用的地方），函数参数，局部变量，以及保存函数返回前必须恢复的寄存器（的值）。每次调用函数都会在栈中分配所需的空间，然后在函数返回时释放该部分空间，这就意味着这部分内存空间被一次又一次的重复利用，所以栈是存储数据的最有效的存储空间，这部分内存被镜像在一级数据缓存中，访问速度很快。</p><p>从中我们学到，尽可能的将变量和对象声明在它们被使用的函数中而不是函数外。</p><h4 id="1-2全局（global）或者静态（static）存储"><a href="#1-2全局（global）或者静态（static）存储" class="headerlink" title="1.2全局（global）或者静态（static）存储"></a>1.2全局（global）或者静态（static）存储</h4><p>静态内存区主要存储全局变量和静态变量（static修饰的变量），在函数之外声明的变量称为全局变量（当然了函数内部的是局部变量），被static修饰的变量有几种情况</p><ul><li>修饰局部变量时，这个局部变量只初始化一次，并且延长了这个局部变量的生命周期，直到程序运行结束后才释放</li><li>修饰全局变量时，这个全局变量只能在本文件中访问，不能再其他文件中访问，即使是extern外部声明都不行</li><li>（如果static修饰函数，则表示这个函数只能在本文件中调用）</li></ul><p>除此之外静态内存区还存储浮点常量，字符串常量，数组初始化列表，switch语句跳转表和虚函数表。</p><p>尽量不要将变量设置为全局变量，除非是不同线程间的通信这种情况才必须设置全局变量。</p><p>尽量将查找表静态化（查找表就是下面代码展现的结构）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">float</span> list[]=&#123;<span class="number">1.1</span>,<span class="number">0.3</span>,<span class="number">-2.0</span>,<span class="number">4.4</span>,<span class="number">2.5</span>&#125;;</span><br><span class="line">  <span class="keyword">return</span> list[x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要先介绍下这个数组是如何初始化的，用浮点常数来初始化数组，其实是将浮点数存储在静态内存区，然后从静态内存区复制到栈中的（整形常量通常包含在指令中，所以不会有这种缓存问题）。</p><p>我们在这里将其声明为<code>static</code>，就是让这个数组只初始化一次，不会每次调用函数都会优化，然后将其声明为<code>const</code>,其实是告诉编译器这是个常量，如果不声明<code>const</code>函数不知道这是第一次调用还是之后的调用，每次都会进行检查，使用<code>const</code>则提高了效率</p><h4 id="1-3寄存器（register）"><a href="#1-3寄存器（register）" class="headerlink" title="1.3寄存器（register）"></a>1.3寄存器（register）</h4><p>有限数量的变量可以之间存储在cpu的寄存器中，但是数量很少</p><h4 id="1-4Volatile"><a href="#1-4Volatile" class="headerlink" title="1.4Volatile"></a>1.4Volatile</h4><p>volatite关键字声明的变量可以被某些编译器未知的因素更改，比如操作系统、硬件或者其他线程。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。特别要注意的是volatile并不保证原子性。</p><h4 id="1-5线程本地存储（thread-local-storage-TLS）"><a href="#1-5线程本地存储（thread-local-storage-TLS）" class="headerlink" title="1.5线程本地存储（thread-local storage TLS）"></a>1.5线程本地存储（thread-local storage TLS）</h4><p>我们知道多线程共享同一个进程的地址空间，对全局变量来说，某一个线程对其修改会影响其他所有线程。如果我们需要一个变量在每个线程中都能访问，并且值在每个线程中互不影响，这就是 Thread Local Storage。</p><p>通过<code>thread_local</code>, <code>__thread</code> or <code>__declspec(thread) </code>关键字声明的变量，每个线程将会拥有一个实例，称为全局的线程本地存储。线程本地存储是低效的，因为它是通过存储在线程环境块中的指针进行访问的。我们应该尽量将变量存储在栈上（即在函数内部声明的局部变量），存储在栈上的变量总是属于创建它们的线程。</p><h4 id="1-6动态内存分配"><a href="#1-6动态内存分配" class="headerlink" title="1.6动态内存分配"></a>1.6动态内存分配</h4><p>使用<code>new</code> <code>delete</code> <code>molloc</code> <code>free</code>完成的内存分配和回收称为动态内存分配，从内存中选取一部分称为堆用于分配内存。动态内存分配若没有回收则会造成内存泄漏，若在释放对象后访问指针还会造成空指针错误。</p><h4 id="1-7类中声明的变量"><a href="#1-7类中声明的变量" class="headerlink" title="1.7类中声明的变量"></a>1.7类中声明的变量</h4><p>在cpp中，数据和函数是分开存放的，函数在代码区，数据主要在栈、堆、静态内存区。</p><p>类的静态成员变量在编译时被分配到静态内存区，非静态成员变量只有在初始化对象时才被分配内存。</p><p>静态成员函数（静态方法）和非静态成员函数（非静态方法）都是存储在代码区的。</p><p>接下来说一下对象在内存中是如何存储的：当对象在函数内部被创建时（即局部变量），对象的成员变量存储在栈；当对象是全局变量，则对象的成员变量存储在静态区；当对象是<code>static</code>修饰的局部变量，对象的成员变量存储在静态区；如果对象是通过new创建出来的，对象的成员变量存储在堆区。</p><p>有必要说明一下cpp中的对象有两种创建方式，直接创建和通过new创建，前者存储在栈或者静态区，后者存储在堆上</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//存储在栈或者静态区</span></span><br><span class="line"><span class="function">ClassName <span class="title">object</span><span class="params">(param)</span></span>;</span><br><span class="line"><span class="comment">//存储在堆上，必须delete否则内存泄漏</span></span><br><span class="line">ClassName *object=<span class="keyword">new</span> <span class="built_in">ClassName</span>(param);</span><br><span class="line"><span class="keyword">delete</span> object;</span><br></pre></td></tr></table></figure><p>（再扯一嘴，看起来用new创建对象好像很麻烦没有必要比较低效，但是好处是一不用担心内存空间不足，因为是动态拓展的，二即使是在函数内部创建对象，只要不delete，对象就一直存在，解决了对象的生命周期问题。）</p><h3 id="2-整型变量"><a href="#2-整型变量" class="headerlink" title="2.整型变量"></a>2.整型变量</h3><h4 id="2-1整数大小"><a href="#2-1整数大小" class="headerlink" title="2.1整数大小"></a>2.1整数大小</h4><p>不同类型的整型变量有不同的大小，大小和在stdint.h中的名称可以参照下图</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20220317144109932.png" alt="image-20220317144109932"></p><p>因为不同平台声明特定大小整型的方式不同，所以如果<code>stdint.h</code> or <code>inttypes.h  </code>存在，可以用它们来定义特定大小的整型，以达到可移植的目的。</p><p>在大小无关紧要，不存在溢出风险的情况下建议使用默认大小的整型，比如简单的变量，循环计数器等等。</p><p>在大型数组中，推荐使用够用的最小类型的正数，以便能够更好的使用数据缓存。</p><p>无符号整数类型<code>size_t</code>在32位系统中为32位，在62位系统中为64位，此类型常用于表示数组大小和数组索引，能够确保不会发生溢出。</p><p>在进行整型计算时，最重要的就是检查是否会发生溢出，比如<code>a=(b*c)/d</code>，即使abc都小于最大值，<code>(b*c)</code>也有可能溢出。</p><h4 id="2-2无符号数和有符号数"><a href="#2-2无符号数和有符号数" class="headerlink" title="2.2无符号数和有符号数"></a>2.2无符号数和有符号数</h4><p>无符号数在除以常量及取模时比有符号数快。</p><p>有符号数转换为浮点数比无符号数快。</p><p>关于溢出：无符号数溢出会变为较小的正数（相当于取模），有符号数溢出一般会变成负值</p><p>另外需要特别注意的是不要混合使用有符号数和无符号数，在进行两者的计算或比较时，会将有符号数转为无符号数比较（可以参考csapp的笔记），尽量避免无符号数除非进行模运算或者使用变量代表位的集合。</p><h4 id="2-3整型运算"><a href="#2-3整型运算" class="headerlink" title="2.3整型运算"></a>2.3整型运算</h4><p>加法、减法、比较、移位基本只需要一个时钟周期。</p><p>乘法可能需要3-4个时钟周期，除法需要40-80个时钟周期，具体取决于cpu</p><h3 id="3-浮点变量"><a href="#3-浮点变量" class="headerlink" title="3.浮点变量"></a>3.浮点变量</h3><p>X86架构的现代cpu有两种不同类型的浮点寄存器，以及对应的两种不同类型的浮点指令。</p><p>最开始执行浮点操作的方法涉及到8个浮点寄存器（称为FPU），它们组织成寄存器栈，称为x87寄存器。这些寄存器都以long double(80 bits)存储数据，当其他类型数据压入寄存器时，会自动拓展成80位。</p><p>这类寄存器栈的优点为：</p><ul><li>所有计算以long double类型完成</li><li>不同精度之间的转换不需要额外的时间</li><li>某些数学函数比如对数和三角函数使用内部指令完成</li><li>代码紧凑，在代码缓存中占用很少空间</li></ul><p>缺点：</p><ul><li>由于使用寄存器栈，编译器很难创建寄存器变量</li><li>除非启用Pentium-II 或者更高的版本，否则浮点计算较为缓慢</li><li>整数和浮点数转换效率低下</li><li>使用long double导致除法、平方根等数学函数耗时更长</li></ul><p>另一种新的浮点运算使用八个或者更多的向量寄存器（XMM,YMM,ZMM），浮点运算使用单精度或者双精度，中间结果的精度总是与操作数相同。</p><p>这类向量寄存器的优点为：</p><ul><li>很容易创建寄存器变量</li><li>可以向量化运算，即SIMD并行计算</li></ul><p>缺点：</p><ul><li>不支持long double</li><li>如果涉及混合精度的计算，需要显示的进行精度转换，这可能会很耗时（而上文提到的方式精度转换不需要额外的时间）</li><li>执行数学函数必须依赖写好的数学库，但这通常要比内在硬件函数要快</li></ul><p>关于单双精度执行计算的速度问题，当使用矢量计算时，单精度除法、平方根和数学函数的计算速度要快于双精度，不使用矢量寄存器时，加减乘等速度相同。（有待细化考究）</p><p>当使用XMM这种类似寄存器时，不要混合使用单精度和双精度，另外，尽量避免浮点变量和整数的转换。</p><h3 id="4-布尔变量"><a href="#4-布尔变量" class="headerlink" title="4.布尔变量"></a>4.布尔变量</h3><p>布尔运算有短路现象，可以利用这一特点加快程序运行</p><p>布尔变量是超定的？？？</p><h3 id="5-指针和引用"><a href="#5-指针和引用" class="headerlink" title="5.指针和引用"></a>5.指针和引用</h3><ul><li>指针和引用其实在做同样的事，它们经过编译器编译后的结果是相同的，引用可以看作常量指针。</li><li>使用引用语法更简单（引用直接代表所指变量的值，而指针代表地址，需要<code>*p</code>才能得到所指变量的值）</li><li>引用比指针更加安全，因为引用在定义时必须进行初始化，而指针很可能因为未初始化导致空指针问题</li><li>引用和指针计算的意义不同，指针加减某数或者自增自减都是改变地址，指向了另一块内存，而引用的计算直接改变的是引用的值</li></ul><p>在计算出指针的值后大约需要两个时钟周期才能访问指向的对象，所以<code>x = *(p++)</code> 比<code>x = *(++p)</code> 更有效</p><h3 id="6-智能指针"><a href="#6-智能指针" class="headerlink" title="6.智能指针"></a>6.智能指针</h3><p>将基本类型指针封装为类对象指针（这个类肯定是个模板，以适应不同基本类型的需求），并在析构函数里编写delete语句删除指针指向的内存空间。</p><p>通过智能指针访问对象和普通指针一样不需要付出额外的代价，，但是当智能指针创建、删除、复制或者从一个函数转移到另一个函数时都会产生额外的成本。</p><h3 id="7-类型转换"><a href="#7-类型转换" class="headerlink" title="7.类型转换"></a>7.类型转换</h3><h4 id="7-1无符号到有符号转换"><a href="#7-1无符号到有符号转换" class="headerlink" title="7.1无符号到有符号转换"></a>7.1无符号到有符号转换</h4><p>只是编译器以不同的方式解释整数的位，转换不需要额外的时间</p><h4 id="7-2整型大小转换"><a href="#7-2整型大小转换" class="headerlink" title="7.2整型大小转换"></a>7.2整型大小转换</h4><p>整型拓展：无符号数添0拓展，有符号数通过拓展符号位来将整数转换为更长的大小</p><p>整型缩小：简单的忽略高位，不做溢出检查，不需要额外的时间，当然，如果数太大就会溢出</p><h4 id="7-3浮点数精度转换"><a href="#7-3浮点数精度转换" class="headerlink" title="7.3浮点数精度转换"></a>7.3浮点数精度转换</h4><p>这涉及到前面讲的两种浮点计算单元，如果是浮点寄存器栈，双、单、半精度的转换不需要额外的时间。如果使用XMM寄存器，就需要2-15个时钟周期，使用向量浮点计算时，做精度转换的成本很高。</p><h4 id="7-4整数到浮点数"><a href="#7-4整数到浮点数" class="headerlink" title="7.4整数到浮点数"></a>7.4整数到浮点数</h4><p>有符号数转浮点需要4到16个时钟周期，无符号数更长。如果没有溢出风险，先将无符号数转为有符号数再转浮点会更快。</p><h4 id="7-5浮点到整数的转换"><a href="#7-5浮点到整数的转换" class="headerlink" title="7.5浮点到整数的转换"></a>7.5浮点到整数的转换</h4><p>除非开启SSE2或者更高版本的指令集，否则将浮点转整数需要很长的时间，通常50-100个时钟周期。 原因是C&#x2F;C++标准规定使用截断模式，因浮点舍入模式要更改为截断，然后再次改回来。</p><p>如果在代码的关键部分中存在浮点到整数转换，那么是有必要做一些事情是。 可能的解决方案是：</p><ul><li>通过使用不同类型的变量来避免转换。</li><li>将中间结果存储为浮点数，把转换移出最内层循环。</li><li>使用64位模式或启用SSE2指令集（需要支持此功能的微处理器）。</li><li>使用舍入而不是截断，并使用汇编语言创建舍入函数。有关舍入的详细信息，后面会进行说明</li></ul><h4 id="7-6指针类型转换"><a href="#7-6指针类型转换" class="headerlink" title="7.6指针类型转换"></a>7.6指针类型转换</h4><p>指针的类型是可以转换的，并且不会产生额外的代码，只是以不同的方式解释相同数据位，当然，这种转换并不安全。</p><p>我们来看个例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> x;</span><br><span class="line">*(<span class="type">int</span>*)&amp;x|=<span class="number">0x80000000</span></span><br></pre></td></tr></table></figure><p>第一眼看上去会很奇怪不知道在干什么，其实慢慢从右往左看，先取了x的地址，得到一个float类型的指针，然后将其强转为int指针，再用*取指针所指的值进行计算，进行的是一个位或计算，将其最高位置为1，所以这行代码的功能就是将x转为int类型并且符号位置为1，即负数。</p><p>通过对其地址进行类型转换，可以使编译器将变量或对象视为具有不同的类型</p><h4 id="7-7常量强制转换"><a href="#7-7常量强制转换" class="headerlink" title="7.7常量强制转换"></a>7.7常量强制转换</h4><p><code>const_cast</code>运算符用于规避常量指针的常量限制</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">c1</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> x; <span class="comment">// constant data</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">c1</span>() : <span class="built_in">x</span>(<span class="number">0</span>) &#123;&#125;; <span class="comment">// constructor initializes x to 0</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">xplus2</span><span class="params">()</span> </span>&#123; <span class="comment">// this function can modify x</span></span><br><span class="line">        *<span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(&amp;x) += <span class="number">2</span>; <span class="comment">// add 2 to x</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="8-分支和switch语句"><a href="#8-分支和switch语句" class="headerlink" title="8.分支和switch语句"></a>8.分支和switch语句</h3><p>现代微处理器的高速度是通过流水线获得的。然而，流水线结构有一个大问题。一旦代码中有分支出现（例如，<code>if-else</code>），微处理器并不能预先知道该把两个分支中的哪一个送入流水线。 如果错误的分支被喂给了流水线，该错误直到10至20个时钟周期后才能被发现，这期间所有的取指，解码，甚至推测性指令执行工作都被浪费掉了。</p><p>现代微处理器使用先进的算法，根据该分支及附近分支的历史数据来预测分支的走向，在微处理器做出正确预测的情况下，分支指令通常需要0-2个时钟周期。从分支错误预测中恢复，所需的时间大约为12-25个时钟周期，具体取决于处理器。 这被称为分支错误预测惩罚</p><p>for循环或while循环也是一种分支。每次循环迭代后，会决定是重复循环还是退出。 如果循环计数很小并且不变，循环分支通常可以很好的被预测。 可以完美预测的最大循环计数通常介于9到64之间，具体取决于处理器。 仅仅某些处理器上可以较好地预测嵌套循环。 在许多处理器上，一个循环内包含多个分支，不能很好地被预测</p><p>switch 语句是一种超过两条路的分支。 下面情形 switch 语句最为高效：</p><ul><li>每个 case 的标签遵循一个序列</li><li>在该序列中，某个标签的当前值等于上一个标签加一。</li></ul><p>这是因为，这种情况可以使用跳转目标表来实现。 具有许多标签的 switch 语句，并且标签的值离得很远，该情形是很低效的，因为编译器必须将其转换为分支树。</p><p>在程序的关键部分，分支和switch语句的数量最好保持较小，特别是如果分支的可预测性很差。如果可以消除分支，则展开循环可能很有用。下一段将会细讲。</p><h3 id="9-循环"><a href="#9-循环" class="headerlink" title="9.循环"></a>9.循环</h3><p>循环的效率取决于微处理器对于循环控制分支预测的好坏，一个固定重复计数器并且没有分支的循环能够被完美预测，而嵌套循环只在一些有特定循环预测器的处理器上预测的很好，在其他的处理器上只有内部循环被预测的很好。</p><h4 id="9-1循环展开"><a href="#9-1循环展开" class="headerlink" title="9.1循环展开"></a>9.1循环展开</h4><p>在某些情况下循环展开是一个优势，例如:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">FuncA</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">FuncB</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FuncC</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该循环重复20次并交替调用<code>FuncA</code>和<code>FuncB</code>，然后调用<code>FuncC</code>。 将循环展开两次代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example 7.30b</span></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">FuncA</span>(i);</span><br><span class="line">    <span class="built_in">FuncC</span>(i);</span><br><span class="line">    <span class="built_in">FuncB</span>(i+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">FuncC</span>(i+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样做有三个优势：</p><ol><li>这样做循环执行10次而不是20次</li><li>重复次数减少到10，意味着在某些处理器上可以完美预测</li><li>移除了if分支</li></ol><p>只有在可以获得特定优势的情况下才应使用循环展开。 如果循环包含浮点计算并且循环计数器是整数，那么通常可以假设整个计算时间由浮点代码而不是循环控制分支确定。 在这种情况下，通过展开循环没有任何好处。</p><p>在具有微操作高速缓存（例如，Sandy Bridge）的处理器上应该避免循环展开，因为重要的是节省微操作高速缓存的使用。 如果看上去有好处，编译器通常会自动展开循环。</p><p><strong>程序员不必手动展开循环，除非能获得特别的好处，比如上面的代码例子消除了if分支</strong></p><h4 id="9-2循环控制条件"><a href="#9-2循环控制条件" class="headerlink" title="9.2循环控制条件"></a>9.2循环控制条件</h4><p>如果循环控制分支依赖于循环内的计算，则效率很低，所以尽量将循环控制条件脱离循环内部，比如：</p><p>以下示例将以零结尾的ASCII字符串转换为小写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example 7.31a</span></span><br><span class="line"><span class="type">char</span> string[<span class="number">100</span>], *p = string;</span><br><span class="line"><span class="keyword">while</span> (*p != <span class="number">0</span>) *(p++) |= <span class="number">0x20</span>;</span><br></pre></td></tr></table></figure><p>如果已知字符串的长度，则使用循环计数器更有效：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example 7.31b</span></span><br><span class="line"><span class="type">char</span> string[<span class="number">100</span>], *p = string; <span class="type">int</span> i, StringLength;</span><br><span class="line"><span class="keyword">for</span> (i = StringLength; i &gt; <span class="number">0</span>; i--) *(p++) |= <span class="number">0x20</span>;</span><br></pre></td></tr></table></figure><p>循环计数器应该优先选择整数，如果循环需要浮点数，可以再创建一个整数作为循环计数器</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example 7.32a</span></span><br><span class="line"><span class="type">double</span> x, n, factorial = <span class="number">1.0</span>;</span><br><span class="line"><span class="keyword">for</span> (x = <span class="number">2.0</span>; x &lt;= n; x++) factorial *= x;</span><br></pre></td></tr></table></figure><p>这可以<strong>通过添加整数计数器，并在循环控制条件中使用整数来加以改进：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example 7.32b</span></span><br><span class="line"><span class="type">double</span> x, n, factorial = <span class="number">1.0</span>; <span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = (<span class="type">int</span>)n - <span class="number">2</span>, x = <span class="number">2.0</span>; i &gt;= <span class="number">0</span>; i--, x++) factorial *= x;</span><br></pre></td></tr></table></figure><h4 id="9-3不要使用循环复制或者清除数组"><a href="#9-3不要使用循环复制或者清除数组" class="headerlink" title="9.3不要使用循环复制或者清除数组"></a>9.3不要使用循环复制或者清除数组</h4><p>将循环用于琐碎的任务，例如复制数组或将数组设置为全零，可能不是最佳选择。 例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example 7.33a</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> size = <span class="number">1000</span>; <span class="type">int</span> i;</span><br><span class="line"><span class="type">float</span> a[size], b[size];</span><br><span class="line"><span class="comment">// set a to zero</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++) a[i] = <span class="number">0.0</span>;</span><br><span class="line"><span class="comment">// copy a to b</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++) b[i] = a[i];</span><br></pre></td></tr></table></figure><p>使用函数 <code>memset</code> 和 <code>memcpy</code> 一般更快一些：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example 7.33b</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> size = <span class="number">1000</span>;</span><br><span class="line"><span class="type">float</span> a[size], b[size];</span><br><span class="line"><span class="comment">// set a to zero</span></span><br><span class="line"><span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="built_in">sizeof</span>(a));</span><br><span class="line"><span class="comment">// copy a to b</span></span><br><span class="line"><span class="built_in">memcpy</span>(b, a, <span class="built_in">sizeof</span>(b));</span><br></pre></td></tr></table></figure><p>至少在简单的情况下，大多数编译器会通过调用memset和memcpy自动替换这样的循环。 显式使用<code>memset</code>和<code>memcpy</code>是不安全的，因为如果size参数大于目标数组，则可能发生严重错误。 但是如果循环计数太大，循环也会发生相同的错误。</p><h3 id="10-函数"><a href="#10-函数" class="headerlink" title="10.函数"></a>10.函数</h3><p>调用函数可能会降低程序速度。原因如下：</p><ul><li>函数调用会让微处理器跳转到不同的代码地址然后返回。这可能需要多达4个时钟周期。 在大多数情况下，微处理器能够将调用及返回操作与其他计算重叠运行以节省时间。</li><li>如果代码碎片化地分散在内存中，代码缓存的效率会降低。</li><li>函数参数以32位模式存储在堆栈中。 将参数存储在堆栈上并再次读取它们需要额外的时间。 如果某个参数处于关键依赖链条中，因此带来的延时是需要重视的。</li><li>设置堆栈帧，保存和恢复寄存器，以及保存异常处理信息（可能需要，也可能不需要），都需要额外的时间。</li><li>每个函数调用语句占用分支目标缓冲区（BTB）中的一个单元。 如果程序的关键部分有很多函数调用和分支，BTB中的争用可能导致分支预测错误</li></ul><p>可以采用以下方法解决此问题</p><h4 id="10-1避免非必要的函数"><a href="#10-1避免非必要的函数" class="headerlink" title="10.1避免非必要的函数"></a>10.1避免非必要的函数</h4><p>可以牺牲部分代码的重用性，将多行代码合为一个函数，以加快速度（当然这里要见仁见智）</p><h4 id="10-2使用内联函数"><a href="#10-2使用内联函数" class="headerlink" title="10.2使用内联函数"></a>10.2使用内联函数</h4><p>使用<code>inline</code>关键字定义内联函数</p><h4 id="10-3避免在嵌套循环的最内层出现函数嵌套"><a href="#10-3避免在嵌套循环的最内层出现函数嵌套" class="headerlink" title="10.3避免在嵌套循环的最内层出现函数嵌套"></a>10.3避免在嵌套循环的最内层出现函数嵌套</h4><p>调用其他函数的函数叫帧函数，不调用其他函数的函数叫叶函数，叶函数效率更高。如果在嵌套循环的最内层包含对帧函数的调用，可以通过以下方法来改进</p><ul><li>内联帧函数</li><li>把帧函数转换为叶函数（具体方法就是内联帧函数中被调用的函数）</li></ul><h4 id="10-4使用宏代替函数"><a href="#10-4使用宏代替函数" class="headerlink" title="10.4使用宏代替函数"></a>10.4使用宏代替函数</h4><p>使用<code>#define</code>声明的宏肯定会被内联</p><h4 id="10-5使用fastcall函数"><a href="#10-5使用fastcall函数" class="headerlink" title="10.5使用fastcall函数"></a>10.5使用<code>fastcall</code>函数</h4><ul><li>在32位模式下，关键字<code>__fastcall</code>更改函数调用方法，以便前两个（CodeGear编译器上是三个）整型参数使用寄存器传输，而不是用堆栈传输。 这可以提高具有整型参数函数的速度。浮点参数不受<code>__fastcall</code>的影响。 类的成员函数中的隐式“this”指针也被视为参数，因此可能只剩下一个空闲寄存器来传输其他参数。 因此，在使用<code>__fastcall</code>时，请确保最关键的整型参数首先出现在函数参数中。</li><li>在64位模式下，函数参数默认传输到寄存器中。 因此，在64位模式下无法识别<code>__fastcall</code>关键字。</li></ul><h4 id="10-6函数本地化"><a href="#10-6函数本地化" class="headerlink" title="10.6函数本地化"></a>10.6函数本地化</h4><p>将关键字static添加到函数声明中，使得函数被设置为本地函数</p><h4 id="10-7使用64位模式"><a href="#10-7使用64位模式" class="headerlink" title="10.7使用64位模式"></a>10.7使用64位模式</h4><p>参数传输在64位模式下比32位模式下更高效，在64位Linux中比在64位Windows中更高效。</p><ul><li>在64位Linux中，前六个整数参数和前八个浮点参数在寄存器中传输，总计最多十四个寄存器参数。</li><li>在64位Windows中，前四个参数在寄存器中传输，无论它们是整数还是浮点数。</li></ul><p>因此，如果函数具有四个以上的参数，则64位Linux比64位Windows更有效。 在参数传递这方面，32位Linux和32位Windows之间没有区别</p><h3 id="11-函数参数"><a href="#11-函数参数" class="headerlink" title="11.函数参数"></a>11.函数参数</h3><p>在大多数情况下，函数参数按值传输。这意味着参数的值将复制到局部变量。 这对于简单类型（如int，float，double，bool，enum以及指针和引用）都很有效。</p><p>数组总是作为指针传递，除非它们被封装到类或结构中。</p><p>如果参数具有复合类型（例如结构或类），则情况会更复杂。 如果满足以下所有条件，则复合类型参数的传输效率可以很高：</p><ul><li>对象足够小，可以装进单个寄存器</li><li>对象没有复制构造函数，也没有析构函数</li><li>对象没有虚拟成员（虚拟函数）</li><li>对象不使用运行时类型标识（RTTI）（什么是RTTI参考这个连接 [C++中的RTTI](<a href="https://www.jianshu.com/p/3b4a80adffa7">C++中的RTTI机制 - 简书 (jianshu.com)</a>)）</li></ul><p>如果上述某一或某些条件不满足，则将使用指向对象的指针或引用来传递对象通常会更快。 如果对象很大，那么复制整个对象显然需要时间。</p><ul><li>将对象复制到参数时，必须调用复制构造函数，</li><li>并且函数返回之前，如果有析构函数的话，还必须调用析构函数</li></ul><p>将复合对象传递给函数的<strong>首选方法是使用const引用</strong>。 const引用确保不修改原始对象。 与指针或非const引用不同，const引用允许函数参数是表达式或匿名对象。 如果函数被内联，编译器可以轻松地优化掉const引用。</p><p>另一种方法是使该函数成为对象类或结构的成员。 这种方法效率同等的高。</p><p>简单的函数参数</p><ul><li>在32位系统中传输到堆栈中，</li><li>但在64位系统的寄存器中传输。</li></ul><p>后者更有效率。</p><ul><li>64位Windows允许在寄存器中传输最多四个参数。</li><li>64位Unix系统允许在寄存器中传输多达14个参数（8个浮点数或2个加6个整数，指针或引用参数）。</li></ul><p>成员函数中的this指针也计入一个参数。进一步的细节在手册5中给出：“不同的C++编译器和操作系统调用约定”。</p><h3 id="12-函数返回类型"><a href="#12-函数返回类型" class="headerlink" title="12.函数返回类型"></a>12.函数返回类型</h3><p>函数返回类型最好是</p><ul><li>简单类型</li><li>指针</li><li>引用</li><li>void</li></ul><p>返回复合类型太复杂且效率低下，如果要返回一个复合对象的话，有几种解决方法</p><ul><li>使该函数成为该对象的构造函数</li><li>修改已有的对象而不创建新对象，函数参数通过指针或者引用传对象，返回值也通过指针或者引用返回对象</li><li>在函数内部创建静态对象并返回指针，这样效率高，但是有风险， 返回的指针或引用仅在下次调用函数前有效，此对象也可能被在不同的线程中改写。 如果您忘记将此本地对象设置为静态，则只要函数返回它就会立即失效。</li><li>使用new在函数内部创建对象，但是效率低，且有内存泄漏的风险</li></ul><h3 id="13-函数尾调用优化"><a href="#13-函数尾调用优化" class="headerlink" title="13.函数尾调用优化"></a>13.函数尾调用优化</h3><p>尾调用：指某个函数的最后一步是调用另一个函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面情况是尾调用</span></span><br><span class="line"><span class="function">function <span class="title">f</span><span class="params">(x)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">g</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//但是下面两种就不属于尾调用了</span></span><br><span class="line"><span class="comment">// 情况一</span></span><br><span class="line"><span class="function">function <span class="title">f</span><span class="params">(x)</span></span>&#123;</span><br><span class="line">  let y = <span class="built_in">g</span>(x);</span><br><span class="line">  <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 情况二</span></span><br><span class="line"><span class="function">function <span class="title">f</span><span class="params">(x)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">g</span>(x) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道，函数调用会在内存形成一个”调用记录”，又称”调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用记录上方，还会形成一个B的调用记录。等到B运行结束，将结果返回到A，B的调用记录才会消失。如果函数B内部还调用函数C，那就还有一个C的调用记录栈，以此类推。所有的调用记录，就形成一个<a href="https://zh.wikipedia.org/wiki/%E8%B0%83%E7%94%A8%E6%A0%88">“调用栈”</a>（call stack）。</p><p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015041002.png" alt="img"></p><p>尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用记录，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用记录，取代外层函数的调用记录就可以了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> m = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> n = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">g</span>(m + n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">f</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">g</span>(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">f</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="title function_">g</span>(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>上面代码中，如果函数g不是尾调用，函数f就需要保存内部变量m和n的值、g的调用位置等信息。但由于调用g之后，函数f就结束了，所以执行到最后一步，完全可以删除 f() 的调用记录，只保留 g(3) 的调用记录。</p><p>这就叫做”尾调用优化”（Tail call optimization），即只保留内层函数的调用记录。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用记录只有一项，这将大大节省内存。这就是”尾调用优化”的意义。</p><p>另一个非常重要的应用是尾递归,递归非常耗费内存，因为需要同时保存成千上百个调用记录，很容易发生”栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用记录，所以永远不会发生”栈溢出”错误。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">factorial</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> n * <span class="title function_">factorial</span>(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">factorial</span>(<span class="number">5</span>) <span class="comment">// 120</span></span><br></pre></td></tr></table></figure><p>上面代码是一个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n) 。</p><p>如果改写成尾递归，只保留一个调用记录，复杂度 O(1) 。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">factorial</span>(<span class="params">n, total</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">factorial</span>(n - <span class="number">1</span>, n * total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">factorial</span>(<span class="number">5</span>, <span class="number">1</span>) <span class="comment">// 120</span></span><br></pre></td></tr></table></figure><p>递归尾调用虽然效率会高一些，但是仍然比循环效率低，尽量将递归变为循环。</p><h3 id="14-结构体和类"><a href="#14-结构体和类" class="headerlink" title="14.结构体和类"></a>14.结构体和类</h3><p>如今，编程教科书推荐使用面向对象编程，使软件开发更加清晰和模块化。 对象是结构和类的实例。 面向对象的编程风格对程序性能，既有正面又有负面的影响。积极影响是：</p><ul><li>如果一组变量是相同结构或类的成员，则它们一起使用，也存储在一起。这使数据缓存更有效。</li><li>类成员变量不需要作为参数传递给类成员函数，避免了参数传输的开销。</li></ul><p>面向对象编程的负面影响是：</p><ul><li><p>非静态成员函数有一个’<code>this</code>‘指针，它作为隐式参数传递给函数。所有非静态成员函数都会产生’<code>this</code>‘参数传输的开销。</p></li><li><p>‘<code>this</code>‘指针占用一个寄存器。寄存器是32位系统中的稀缺资源。</p></li><li><p>虚拟成员函数效率较低</p></li></ul><p>关于面向对象编程的正面影响，还是负面影响占主导地位，没有一般性的定论。至少，可以说使用类和成员函数，代价并不昂贵。 你可以使用面向对象的编程风格：<br>如果它对程序的逻辑结构和清晰度有好处，只要在程序的最关键部分避免过多的函数调用，<br>单纯结构的使用（没有成员函数）对性能没有负面影响。</p><h4 id="14-1实例变量"><a href="#14-1实例变量" class="headerlink" title="14.1实例变量"></a>14.1实例变量</h4><p>无论在什么时间创建类或结构的实例，其数据成员都按照它们被声明的顺序连续存储。 将数据组织到类或结构中，并不会导致性能损失。 访问类或结构对象的数据成员并不会比访问简单变量花费更多的时间。大多数编译器会将数据成员与地址对齐，以便优化访问。</p><p>结构或类中如果混有不同大小的数据成员，数据对齐会导致某些字节未被使用，比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S1</span> &#123;</span><br><span class="line">   <span class="type">short</span> <span class="type">int</span> a; <span class="comment">// 2个字节. 第一个在偏移位置0, 第二个在位置1</span></span><br><span class="line">   <span class="comment">// 6个未使用的字节</span></span><br><span class="line">   <span class="type">double</span> b; <span class="comment">// 8个字节. 第一个在偏移位置8, 最后一个在位置15</span></span><br><span class="line">   <span class="type">int</span> d; <span class="comment">// 4个字节. 第一个在偏移位置16, 最后一个在位置19</span></span><br><span class="line">   <span class="comment">// 4个未使用字节</span></span><br><span class="line">&#125;;</span><br><span class="line">S1 ArrayOfStructures[<span class="number">100</span>];</span><br></pre></td></tr></table></figure><p>上面的结构体由于对其浪费了8个字节，在整个数组中浪费了800个字节。</p><p>我们可以通过调整数据成员声明的顺序来避免浪费。</p><p>通过重新安排数据成员的编码顺序，通常可以使结构和类对象更小。 如果类有至少一个虚拟函数，则在第一个数据成员之前，或最后一个成员之后，有一个指向虚拟表的指针。 该指针在32位系统中为4个字节，在64位系统中为8个字节。 如果你对结构或其每个成员的大小有疑问，可以使用<code>sizeof</code>运算符进行测试。 <code>sizeof</code>运算符返回的值包括对象末尾的任何未使用的字节的大小。</p><ul><li><strong>如果数据成员相对于结构或类的开头的偏移量小于128，则生成的访问数据成员的代码更为紧凑，因为偏移量可以表示为8位有符号数。</strong></li><li>如果相对于结构或类的开头的偏移量大于等于128字节，则偏移量必须表示为32位数（指令集在介于8位和32位偏移之间，没有任何区别）。</li></ul><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example 7.40</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">S2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="type">int</span> a[<span class="number">100</span>]; <span class="comment">// 400字节. 首字节偏移量0, 尾字节偏移量399</span></span><br><span class="line">   <span class="type">int</span> b; <span class="comment">// 4字节. 首字节偏移量400, 尾字节偏移量403</span></span><br><span class="line">   <span class="function"><span class="type">int</span> <span class="title">ReadB</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> b;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里<code>b</code>的偏移量为400。通过指针或成员函数（如<code>ReadB</code>）访问<code>b</code>的任何代码都需要将偏移量编码为32位数。 如果交换<code>a</code>和<code>b</code>，则可以使用编码为8位有符号数的偏移量访问这两个变量，或者根本不用偏移。 这使代码更紧凑，从而更有效地使用代码缓存。 因此，对于大型数组和其他大型对象，建议在结构或类声明中排在最后。并且最常用的数据成员放在前面。 如果不能把所有数据成员包含前128个字节内，则将最常用的成员放在前128个字节中</p><h4 id="14-2方法（类成员函数）"><a href="#14-2方法（类成员函数）" class="headerlink" title="14.2方法（类成员函数）"></a>14.2方法（类成员函数）</h4><p>所有的类成员函数都把隐含的this指针作为参数。</p><p>因此下面三个方法一样快</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">S3</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="type">int</span> a;</span><br><span class="line">   <span class="type">int</span> b;</span><br><span class="line">   <span class="function"><span class="type">int</span> <span class="title">Sum1</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> a + b;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Sum2</span><span class="params">(S3 * p)</span> </span>&#123;<span class="keyword">return</span> p-&gt;a + p-&gt;b;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Sum3</span><span class="params">(S3 &amp; r)</span> </span>&#123;<span class="keyword">return</span> r.a + r.b;&#125;</span><br></pre></td></tr></table></figure><p>但是有些编译器会通过寄存器传递this指针而不是堆栈，所以会导致Sum1的效率略高些</p><h4 id="14-3虚函数"><a href="#14-3虚函数" class="headerlink" title="14.3虚函数"></a>14.3虚函数</h4><p>先回顾一下面向对象中多态的概念，多态分为静态多态和动态多态，也叫编译时多态和与运行时多态。前者即静态多态指函数重载和模板编程，后者动态多态指父类的指针（对象引用变量）指向不同类的对象时，所调用的方法会有不同的效果，需要注意cpp中只有虚函数才能被重写，如果没有<code>virtual</code>修饰，父类指针始终调用父类的方法，而不会调用子类中重写的方法。</p><p>虚函数的实现原理：</p><p>存在虚函数的类中都有一个一维的表叫做虚表，每一个类的对象都有一个指向虚表头部的虚指针，每一个类对应一个虚表，每一个对象对应一个虚表指针。</p><p>编译器在编译的时候，发现Base类中有虚函数，此时编译器会为每个包含虚函数的类创建一个虚表（即vtable），该表是一个一维数组（而不是一个链表），在这个数组中存放每个虚函数的地址。由于Base类和Derive类都包含了一个虚函数func()，编译器会为这两个类都建立一个虚表。</p><p>那么如何定位虚表呢？编译器另外还为每个带有虚函数的类的对象自动创建一个虚表指针（即vptr），这个指针指向了对象所属类的虚表。在程序运行时，根据对象的类型去初始化vptr，从而让vptr正确的指向所属类的虚表。所以在调用虚函数时，就能够找到正确的函数。对于上述程序，由于实际指向的对象类型是Derive，因此vptr指向的Derive类的vtable，当调用func()时，根据虚表中的函数地址找到的就是Derive类的func()函数。</p><p>正是由于每个对象调用的虚函数都是通过虚表指针来索引的，也就决定了虚表指针的正确初始化是非常重要的。换句话说，在虚表指针没有正确初始化之前，我们不能够去调用虚函数。那么虚表指针在什么时候，或者说在什么地方初始化呢？<br>答案是在构造函数中进行虚表的创建和虚表指针的初始化。</p><p>构造函数的调用顺序，在构造子类对象时，要先调用父类的构造函数，之后再完成子类的构造。在调用父类的构造函数时，编译器只“看到了”父类，并不知道后面是否后还有继承者，它初始化虚表指针，将该虚表指针指向父类的虚表。当执行子类的构造函数时，虚表指针被重新赋值，指向自身的虚表。对于以上的例子，当Derive类的对象构造完毕后，其内部的虚表指针也就被初始化为指向Derive类的虚表。在类型转换后，调用func()，由于实际指向的是Derive类的对象，该对象内部的虚表指针指向的是Derive类的虚表，因此最终调用的是Derive类的func()函数。</p><p>要注意：对于虚函数调用来说，每一个对象内部都有一个虚表指针，该虚表指针被初始化为本类的虚表。所以在程序中，不管你的对象类型如何转换，但该对象内部的虚表指针是固定的，所以呢，才能实现动态的对象函数调用，这就是C++多态性实现的原理。</p><hr><p>多态性时面向对象程序比非面向对象程序效率低的主要原因之一。 如果可以避免使用虚函数，那么你可以获得面向对象编程的大部分优势，而无需支付性能成本。</p><ul><li>如果函数调用语句总是调用相同版本的虚函数，调用虚拟成员函数所花费的时间比调用非虚拟成员函数所花费的时间，只多几个时钟周期。</li><li>如果虚函数版本发生变化，那么可能会得到10到20个时钟周期的错误预测惩罚。（意味着主要性能成本来自流水线预测失败）</li></ul><p>为了效率的话，尽量使用编译时多态，或者使用模板，但是要权衡模板编程的复杂性。</p><h4 id="14-4运行时类型识别（RTTI）"><a href="#14-4运行时类型识别（RTTI）" class="headerlink" title="14.4运行时类型识别（RTTI）"></a>14.4运行时类型识别（RTTI）</h4><p>运行时类型标识会向所有类对象添加额外信息，其效率不高。 如果编译器有RTTI选项，把它关闭，寻找其它替代方法</p><h4 id="14-5继承"><a href="#14-5继承" class="headerlink" title="14.5继承"></a>14.5继承</h4><p>编译器对于派生类的对象的实现方式，与包含父类和子类成员的简单类的对象相同。 父类和子类的成员访问同样的快。通常，可以假定使用继承几乎没有任何性能损失。</p><p>由于以下原因，代码缓存性能可能会略有下降：</p><ul><li>父类数据成员的大小将添加到子类成员的偏移量中。 访问总偏移量大于127字节的数据成员的代码，会稍微变得不那么紧凑。</li><li>父和子的成员函数通常存储在不同的模块中。 这可能会导致大量跳转，代码缓存效率降低。 解决这个问题的方法是，确保彼此相邻调用的函数也存储在彼此附近。</li></ul><h4 id="14-6构造函数和析构函数"><a href="#14-6构造函数和析构函数" class="headerlink" title="14.6构造函数和析构函数"></a>14.6构造函数和析构函数</h4><p>构造函数在内部实现为成员函数，该函数返回该对象的引用。 新对象的内存分配不一定由构造函数自身完成。 因此，构造函数与任何其他成员函数效率没有区别。 此结论适用于默认构造函数，拷贝构造函数和任何其它构造函数。</p><p>一个类可以不需要构造函数。</p><ul><li>如果对象不需要初始化，可以没有默认构造函数。</li><li>如果只需复制所有数据成员就可以复制对象，则不需要拷贝构造函数。</li></ul><p>简单的构造函数可以被内联，以提高性能。</p><p>当通过赋值，函数参数或函数返回值来复制对象时，拷贝构造函数都可能被调用。 如果拷贝构造函数涉及内存或其他资源的分配，可能要花费一定时间。 有多种方法可以避免这种内存复制浪费，例如：</p><ul><li>使用指向对象的引用或指针，而不是复制对象本身。</li><li>使用“移动构造函数”来转移内存块的所有权。这需要一个支持C++ 0x的编译器。</li><li>创建一个类的成员函数，或者友元函数，或者运算符，将内存块的所有权从一个对象转移到另一个对象。 失去内存块所有权的对象应将其指针设置为<code>NULL</code>。 当然应该有一个析构函数来销毁对象拥有的任何内存块。</li></ul><p>析构函数与成员函数效率相同。如果没有必要，不要写析构函数。 虚拟析构函数与虚拟成员函数效率相同。</p><p>补充：移动构造函数</p><p>移动构造函数以及左值右值是cpp11标准引入的新标准，通过<code>std::move()</code>可以避免复制内存，提高效率。</p><p>首先介绍左值和右值，字面意义上，左值既能出现在等号左边，也能出现在等号右边。右值只能出现在等号右边。左值指指向对象的表达式，指在内存中占据地址的对象，右值是不在内存中某个可识别位置的对象的表达式，左值和右值的根本区别在于能否取内存地址。</p><p>举个栗子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> var;<span class="comment">//左值</span></span><br><span class="line">var = <span class="number">4</span>;<span class="comment">//var是左值，4是右值</span></span><br></pre></td></tr></table></figure><p>赋值操作需要左操作数是一个左值。<code>var</code> 是一个有内存位置的对象，因此它是左值。然而，下面的写法则是错的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span> = var;       <span class="comment">// 错误！不能将左值赋给右值</span></span><br><span class="line">(var + <span class="number">1</span>) = <span class="number">4</span>; <span class="comment">// 错误！（var+1）也是右值，不能将右值赋给另一个右值</span></span><br></pre></td></tr></table></figure><p>接下来说明下左值引用和右值引用。</p><p>左值引用和右值引用都是引用，只不过一个用作左值，一个只能用作右值即只能给别的变量赋值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> &amp;a=<span class="number">2</span>;<span class="comment">//左值引用</span></span><br><span class="line"><span class="type">int</span> &amp;&amp;b=a;<span class="comment">//右值引用</span></span><br></pre></td></tr></table></figure><p>接下来说会移动构造函数，在cpp中通过一个已有对象初始化另一个对象要通过复制构造函数，而当对象中有指针类型的成员变量时，复制构造函数执行的是深拷贝，这是低效且占用内存空间的，而如果不深拷贝的话，多个指针指向同一个地址会造成对该内存空间的多次释放。由此引入了移动构造函数，即将原对象的内存空间移动给新对象，同时将原对象的指针为<code>NULL</code>，避免重复释放同一块内存地址。</p><p>移动构造函数的代码实现就是将右值引用作为参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">demo</span>(demo &amp;&amp;d):<span class="built_in">num</span>(d.num)&#123;<span class="comment">//右值引用</span></span><br><span class="line">   d.num = <span class="literal">NULL</span>;</span><br><span class="line">   cout&lt;&lt;<span class="string">&quot;move construct!&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">demo</span>(<span class="type">const</span> demo &amp;d):<span class="built_in">num</span>(<span class="keyword">new</span> <span class="built_in">int</span>(*d.num))&#123;<span class="comment">//左值引用</span></span><br><span class="line">   cout&lt;&lt;<span class="string">&quot;copy construct!&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="15-unions"><a href="#15-unions" class="headerlink" title="15.unions"></a>15.unions</h3><p>　共用体，也叫联合体，在一个“联合”内可以定义多种不同的数据类型， 一个被说明为该“联合”类型的变量中，允许装入该“联合”所定义的任何一种数据，这些数据共享同一段内存，以达到节省空间的目的。<strong>union变量所占用的内存长度等于最长的成员的内存长度。</strong></p><h3 id="16-模板"><a href="#16-模板" class="headerlink" title="16.模板"></a>16.模板</h3><p>模板类似宏，在编译前模板的参数被简单的被值替代。</p><p>使用模板传参比直接函数传参要更高效，当然，可读性会变差。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Multiply</span> <span class="params">(<span class="type">int</span> x, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> x * m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> m&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MultiplyBy</span> <span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> x * m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a, b;</span><br><span class="line">a = <span class="built_in">Multiply</span>(<span class="number">10</span>,<span class="number">8</span>);</span><br><span class="line">b = <span class="built_in">MultiplyBy</span>&lt;<span class="number">8</span>&gt;(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//下面的函数更高效</span></span><br></pre></td></tr></table></figure><p><strong>使用模板实现多态</strong></p><p>先举个栗子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example 7.47b. 使用模板实现编译时多态</span></span><br><span class="line"><span class="comment">// 把非多态函数放入祖父类中:</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CGrandParent</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">NotPolymorphic</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有要调用多态函数的函数放入父类。</span></span><br><span class="line"><span class="comment">// 子类类名作为父类的模板参数：</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> MyChild&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CParent</span> : <span class="keyword">public</span> CGrandParent &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">Hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;Hello &quot;</span>;</span><br><span class="line">     <span class="comment">// call polymorphic child function:</span></span><br><span class="line">     (<span class="built_in">static_cast</span>&lt;MyChild*&gt;(<span class="keyword">this</span>))-&gt;<span class="built_in">Disp</span>();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多个子类，每个子类实现一个版本的函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CChild1</span> : <span class="keyword">public</span> CParent&lt;CChild1&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">Disp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     cout &lt;&lt; <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CChild2</span> : <span class="keyword">public</span> CParent&lt;CChild2&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">Disp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     cout &lt;&lt; <span class="number">2</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">   CChild1 Object1; CChild2 Object2;</span><br><span class="line">   CChild1 * p1;</span><br><span class="line">   p1 = &amp;Object1;</span><br><span class="line">   p1-&gt;<span class="built_in">Hello</span>(); <span class="comment">// Writes &quot;Hello 1&quot;</span></span><br><span class="line">   CChild2 * p2;</span><br><span class="line">   p2 = &amp;Object2;</span><br><span class="line">   p2-&gt;<span class="built_in">Hello</span>(); <span class="comment">// Writes &quot;Hello 2&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用模板实现多态的原理就是将子类类型作为模板的参数填入，然后直接将this指针转为子类类型，从而能够直接调用子类的方法，这是静态多态，提高了效率。可读性仍然降低。 如果编译器能够自动去虚拟化（devirtualization），依靠编译器进行优化的方法，肯定比使用复杂的模板方法更方便。</p><h3 id="17-线程"><a href="#17-线程" class="headerlink" title="17.线程"></a>17.线程</h3><p>在优化多线程应用程序时，我们必须考虑多线程的四种成本：</p><ul><li>启动和停止线程的成本。<ul><li>如果任务的持续时间短于启动和停止线程所需的时间，则不要将任务放入单独的线程中。</li></ul></li><li>任务切换的成本。<ul><li>如果具有相同优先级的线程数不超过CPU核心数，则此成本最低。</li></ul></li><li>线程之间同步和通信的成本。<ul><li>信号量，互斥量等的开销很大。如果两个线程经常相互等待以便访问同一资源，那么最好将它们连接到一个线程中。</li><li>必须将多个线程之间共享的变量声明为<code>volatile</code>。这可以防止编译器把该变量进行优化消失。</li></ul></li><li>不同的线程需要单独存储。<ul><li>多个线程使用的函数或类都不应该依赖静态或全局变量。（参见第28页的线程本地存储）</li><li>线程有自己的堆栈。如果线程共享相同的缓存，则可能导致缓存争用。</li></ul></li></ul><p>多线程程序必须使用线程安全函数。 线程安全函数永远不应该使用静态变量。</p><h3 id="18-异常"><a href="#18-异常" class="headerlink" title="18.异常"></a>18.异常</h3><p>异常处理旨在检测很少发生的错误，并从错误中恢复，只要不发生错误，异常处理就不会占用额外的时间，但是一旦出现异常，程序就需要大量时间来进行恢复。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C1</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   ...</span><br><span class="line">   ~<span class="built_in">C1</span>();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">F1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   C1 x;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">F0</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="built_in">F1</span>();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">     ...</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以以上述代码为例讲解，F1方法创建了C1对象，F0方法又调用F1方法，当F0调用F1时出现异常，执行跳出F1，程序没有返回，就无法清理已经分配的内存（比如C1对象x），所以F1必须保存所有相关信息才能保证能够清理垃圾。</p><p>如果F1调用另一个函数，该函数又调用另一个函数等，并且如果在最里面的函数中发生异常，则异常处理程序需要有关函数调用链的所有信息，并且它需要通过函数调用向后跟踪路径，检查所有必要的清理工作。 这称为堆栈展开。</p><p>所有函数都必须为异常处理程序保存一些信息，即使没有异常发生。 这就是为什么在某些编译器中异常处理可能代价高昂的原因。 如果你的应用程序异常处理不是必需的，你应该禁用它，这样代码更小，也更高效。</p><ul><li><p>你可以通过关闭编译器中的异常处理选项，来禁用整个程序的异常处理。</p></li><li><p>你可以通过向函数原型添加<code>throw()</code>来禁用单个函数的异常处理：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">F1</span><span class="params">()</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></li></ul><p><code>C++11</code>推荐使用 <code>noexcept</code>，<code>throw()</code>已经过时。</p><p>这允许编译器假定<code>F1</code>永远不会抛出任何异常，因此它不必保存函数<code>F1</code>的恢复信息。 然而，如果<code>F1</code>调用另一个可能抛出异常的函数<code>F2</code>，则<code>F1</code>必须检查<code>F2</code>抛出的异常，并在<code>F2</code>实际抛出异常的情况下调用<code>std::unexpected()</code>函数。 因此，只有当<code>F1</code>调用的所有函数都使用<code>throw()</code>限定符时，才能把<code>throw()</code>应用于<code>F1</code>。<code>throw()</code>对库函数很有用。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h2 id=&quot;五-不同c-结构的效率&quot;&gt;&lt;a href=&quot;#五-不同c-结构的效率&quot; class=&quot;headerlink&quot; title=&quot;五.不同c++结构的效率&quot;&gt;&lt;/a&gt;五.不同c++结构的效率&lt;/h2&gt;&lt;h3 id=&quot;1-不同种类变量存储&quot;&gt;&lt;a</summary>
        
      
    
    
    
    
    <category term="hpc" scheme="https://mightcoder.com/tags/hpc/"/>
    
    <category term="cpp" scheme="https://mightcoder.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>DeePMD</title>
    <link href="https://mightcoder.com/2022/03/22/DeePMD/"/>
    <id>https://mightcoder.com/2022/03/22/DeePMD/</id>
    <published>2022-03-22T02:12:51.000Z</published>
    <updated>2022-07-15T08:13:03.061Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DeepMD"><a href="#DeepMD" class="headerlink" title="DeepMD"></a>DeepMD</h1><blockquote><p>参加ASC2022比赛对deepmd所做的学习，实在太菜了，贴上来做个纪念吧</p></blockquote><h2 id="赛题"><a href="#赛题" class="headerlink" title="赛题"></a>赛题</h2><p>对于该任务，参与者需要在给定的数据集上使用DeePMD-kit包对DeePMD模型进行训练，然后对训练过程进行改进和分析。更具体地说，该任务可以分为3个步骤<br>1 、工作下载DeePMD-kit的源代码,完成编译和安装。然后在给定的系统上训练三种模型,使它们的基线（baseline）被分别优化。<br>2、深入研究DeePMD-kit 训练部分代码的实现，并对其进行改进，以加快gpu上的训练过程。<br>3 、对改进进行分析，提交修改后的代码，并提供详细的报告，包括对DeePMD-kit的了解，具体的优化方法和改进。<br>分数是由相对性能提高决定的</p><h3 id="1-编译和下载DeePMD-kit"><a href="#1-编译和下载DeePMD-kit" class="headerlink" title="1.编译和下载DeePMD-kit"></a>1.编译和下载DeePMD-kit</h3><p>参考一下网址：</p><p><a href="https://github.com/deepmodeling/deepmd-kit/blob/devel/doc/install/install-from-source.md#install-the-python-interface">deepmd-kit&#x2F;install-from-source.md at devel · deepmodeling&#x2F;deepmd-kit (github.com)</a></p><h3 id="2-训练"><a href="#2-训练" class="headerlink" title="2.训练"></a>2.训练</h3><p>例如：</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20220125195044532.png" alt="image-20220125195044532"></p><p>我们的目的为优化训练的时间计算相对性能</p><h3 id="3-数据格式"><a href="#3-数据格式" class="headerlink" title="3.数据格式"></a>3.数据格式</h3><blockquote><p>The example water dataset in DeePMD-kit format can be found in  $deepmd_source_dir&#x2F;examples&#x2F;water&#x2F;data&#x2F;data_0, which contains several necessary inputs for  training models. The model takes coordinates of each atoms (set.000&#x2F;coord.npy, in numpy format,  shape : [num_of_samples, num_of_atoms_per_sample * 3]), atomic type (type_map.raw mapping the index to specific element, type.raw mapping atomic indexes in each sample to  corresponding element) and box size of each sample (set.000&#x2F;box.npy, in numpy format, shape :  [num_of_samples, 3 * 3]) as inputs, and predicts the corresponding energy of samples  (set.000&#x2F;energy.npy, in numpy format, shape : [num_of_samples, ]) and atomic forces  (set.000&#x2F;force.npy, in numpy format, shape : [num_of_samples, num_of_atoms_per_sample *  3]). </p></blockquote><p>输入数据：</p><p>原子的坐标：coord.npy文件</p><p>原子类型：raw文件（包括type_map.raw  type.raw）</p><p>每个样例的box size：box.raw</p><p>输出：</p><p>样品对应的能量：energy.npy</p><p>原子受力：force.npy</p><h3 id="4-评估"><a href="#4-评估" class="headerlink" title="4.评估"></a>4.评估</h3><blockquote><p>注意：所有团队需要使用DeePMD-kit的ASC22分支</p></blockquote><p>使用三种：Water, Copper and Al-Cu-Mg ternary alloy进行评估</p><p>包括 data_sets input.json，data_sets表示输入数据集，input.json控制DeePMD-kit的训练过程</p><p>input.json的格式参考文档[ASC22 Preliminary Round Notification (1).pdf](file:&#x2F;&#x2F;&#x2F;C:&#x2F;Users&#x2F;might&#x2F;Downloads&#x2F;edge下载&#x2F;ASC22 Preliminary Round Notification (1).pdf)，要注意的是只允许更改三个参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;model/descriptor/precision” #descriptor的精度</span><br><span class="line">&quot;model/fitting_net/precision&quot; #fitting_net的精度</span><br><span class="line">&quot;model/descriptor/type_one_side&quot; #选择网络层数方案</span><br></pre></td></tr></table></figure><h3 id="5-测试"><a href="#5-测试" class="headerlink" title="5.测试"></a>5.测试</h3><p>使用一下命令即可测试正确性</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20220126001850418.png" alt="image-20220126001850418"></p><p>要注意任何优化方法必须保证优化过的项目执行的测试结果和asc-2022分支的测试结果一致</p><h3 id="6-提交"><a href="#6-提交" class="headerlink" title="6.提交"></a>6.提交</h3><p>提交格式：</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20220126002222696.png" alt="image-20220126002222696"></p><p>示例：</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20220126002243179.png" alt="image-20220126002243179"></p><h2 id="实际安装"><a href="#实际安装" class="headerlink" title="实际安装"></a>实际安装</h2><p>先从github下源码</p><h3 id="1-python接口"><a href="#1-python接口" class="headerlink" title="1.python接口"></a>1.python接口</h3><p>先创建python3的虚拟环境（~&#x2F;ASC&#x2F;venv），然后在虚拟环境内安装tensorflow，然后回到deepmd的源码目录下，<code>pip install .</code></p><p>为了并行加速，按照教程安装Horoved和mpi4py</p><h4 id="Horoved"><a href="#Horoved" class="headerlink" title="Horoved"></a>Horoved</h4><p>1.先安装NCCL（NVIDIA Collective Communication Library）</p><blockquote><p>这里涉及到非全局安装的问题，在自己的~目录下修改<code>.bashrc</code>文件来保存<code>$PATH</code> <code>$LD_LIBRARY_PATH</code></p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20220126025215463.png" alt="image-20220126025215463"></p></blockquote><p>  因为无法root安装，采用源码编译的方式，见官方文档<a href="https://github.com/NVIDIA/nccl">NVIDIA&#x2F;nccl: Optimized primitives for collective multi-GPU communication (github.com)</a>并参考<a href="https://www.cnblogs.com/chenzhen0530/p/13885258.html">Linux下NCCL源码编译安装 - chenzhen0530 - 博客园 (cnblogs.com)</a></p><p>在编译的时候要制定安装的cuda的目录，cuda也是我从源码安装的目录为<code>/home/u2600489/cuda</code>，所以编译的时候命令为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">make -j64 src.build CUDA_HOME=/home/u2600489/cuda</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">这里要用多线程编译不然会很慢并且最后很奇怪的报错了</span></span><br></pre></td></tr></table></figure><p>编译后的文件在<code>/home/u2600489/nccl/build</code>中，这里要注意<code>NCCL_HOME</code>应该是<code>/home/u2600489/nccl/build</code>而不是<code>/home/u2600489/nccl</code></p><p>2.安装nv_peer_memory（v100会用到）</p><blockquote><p>安装地址</p><p><a href="https://github.com/Mellanox/nv_peer_memory">Mellanox&#x2F;nv_peer_memory (github.com)</a></p><p><a href="https://developer.nvidia.com/gpudirect">GPUDirect | NVIDIA Developer</a></p></blockquote><p>3.安装openmpi</p><p>本机自带，但是不能用服务器上那个！版本太低，要自行安装新版本的</p><p>4.安装horovod</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">HOROVOD_NCCL_HOME=/home/u2600489/nccl/build HOROVOD_NCCL_LIB=/home/u2600489/nccl/build/lib HOROVOD_NCCL_INCLUDE=/home/u2600489/nccl/build/include HOROVOD_GPU_ALLREDUCE=NCCL HOROVOD_WITH_MPI=1 HOROVOD_GPU_OPERATIONS=NCCL HOROVOD_WITH_TENSORFLOW=1 pip install --no-cache-dir horovod pip install --no-cache-dir horovod</span></span><br></pre></td></tr></table></figure><p>注意nccl地址不要填错，我的是<code>/home/u2600489/nccl/build</code></p><h4 id="mpi4py"><a href="#mpi4py" class="headerlink" title="mpi4py"></a>mpi4py</h4><p>pip安装即可，我们miniconda下已经安装</p><h2 id="数学原理"><a href="#数学原理" class="headerlink" title="数学原理"></a>数学原理</h2><blockquote><p>本文档只是整理训练过程的步骤，具体数学推导过程可以参照原论文和b站的一个视频<a href="https://www.bilibili.com/video/BV14L411E7nf?share_source=copy_web">https://www.bilibili.com/video/BV14L411E7nf?share_source=copy_web</a></p></blockquote><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20220127000721202.png" alt="image-20220127000721202"></p><p>要保证可拓展性和物理性质（三个不变性）</p><h3 id="设计模型："><a href="#设计模型：" class="headerlink" title="设计模型："></a>设计模型：</h3><h4 id="求势能"><a href="#求势能" class="headerlink" title="求势能"></a>求势能</h4><p>这里Ei为每个原子的势能，用每个原子的势能之和来表示系统的势能，下面的式子，Ri表示在原子子周围固定范围内的原子们（只看固定范围内的），将其先过一个装饰器D，再过一个拟合神经网络得到势能（先过装饰器的原因是为了保证对称性，再过神经网络得到单点势能）</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20220127001801330.png" alt="image-20220127001801330"></p><p>（1）计算Ri</p><p>下图Ri矩阵大小为邻居原子数*4（第一个s(rj)是相对距离，通过下面的式子求出，后面三个就是对中心原子的相对坐标）</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20220127002145700.png" alt="image-20220127002145700"></p><p>（2）过embedding层（嵌入层：将离散变量转变为连续向量）</p><p>这里把标量（上一步求出来的相对距离）作为输入，把连续向量作为输出，大小为邻居原子数*embedding输出长度</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20220127003143533.png" alt="image-20220127003143533"></p><p>（3）矩阵乘法（为了保证对称性）</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20220127003305518.png" alt="image-20220127003305518"></p><p>将四个矩阵相乘得到Di</p><p>（4）过神经网络</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20220127010451285.png" alt="image-20220127010451285"></p><p>完整的过程可以由下图表示：</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20220127010740703.png" alt="image-20220127010740703"></p><h4 id="求受力"><a href="#求受力" class="headerlink" title="求受力"></a>求受力</h4><p>受力是根据物理上的一个定义（关于能量关于坐标的一个负梯度即下面的公式）得到的</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20220127010958927.png" alt="image-20220127010958927"></p><p>这里进行两次反向求导，第一次反向求导得到受力，第二次反向求导得到loss进行反向更新</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="1-代码结构"><a href="#1-代码结构" class="headerlink" title="1.代码结构"></a>1.代码结构</h3><p>deepmd目录下是python的一些模块<br>source目录是源代码和相关的库<br>source目录下比较重要的有lib和op<br>source&#x2F;lib&#x2F;src为custom op具体实现（其实混合精度应该并不涉及这部分）<br>source&#x2F;op为custom op的具体调用</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20220127011926950.png" alt="image-20220127011926950"></p><p>蓝色是用c++实现的op，橙色的是tensorflow的标准op</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20220127012543287.png" alt="image-20220127012543287"></p><p>第一步用gpu分块比较好，所以自己实现，最后一部分是为了求受力</p><p>这里面需要注意的是拟合网络是net(s)，每一种不cd 同元素的原子我们用不同的网络，网络数由input.json中<code>type_one_side</code>参数决定，默认false则根据原子pari的种类数来决定，比如水有OH,OO,HH,HO四种，就用四种网络，若true只会考虑邻居原子的类型，如水就是两种网络</p><p>完整图如下</p><p>这里多出来的求导部分主要是为了受力的反向传播，所以又求了一次导</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20220127013153131.png" alt="image-20220127013153131"></p><p>其他注意事项</p><p>两个重要参数</p><p>代码运行过程如下，可以从man.py开始</p><p>每一次修改代码都要pip重新安装</p><p>nvprof  查找热点工具</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20220127014233055.png" alt="image-20220127014233055"></p><h3 id="2-相关文件"><a href="#2-相关文件" class="headerlink" title="2.相关文件"></a>2.相关文件</h3><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20220129233402020.png" alt="image-20220129233402020"></p><h4 id="lcurve-out"><a href="#lcurve-out" class="headerlink" title="lcurve.out"></a>lcurve.out</h4><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20220127031324127.png" alt="image-20220127031324127"></p><p>训练步长  验证loss  训练loss  能量的均方根(RMS) 验证误差  能量的RMS训练误差  力的RMS验证误差  力的RMS训练误差  学习率</p><h4 id="input-json"><a href="#input-json" class="headerlink" title="input.json"></a>input.json</h4><p>只需要关注三个参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;model/descriptor/precision” #选择装饰器用什么精度</span><br><span class="line">&quot;model/fitting_net/precision&quot; #选择拟合网络用什么精度</span><br><span class="line">&quot;model/descriptor/type_one_side&quot; #选择网络层数方案，默认为false</span><br></pre></td></tr></table></figure><p>precision:<br>type: <code>str</code>, optional, default: <code>float64</code><br>argument path: <code>model/descriptor[se_e2_a]/precision</code><br>The precision of the embedding net parameters, supported options are “default”, “float16”, “float32”, “float64”.</p><p>type_one_side:<br>type: <code>bool</code>, optional, default: <code>False</code><br>argument path: <code>model/descriptor[se_e2_a]/type_one_side</code><br>Try to build N_types embedding nets. Otherwise, building N_types^2 embedding nets</p><h4 id="model-ckpt-checkpoint"><a href="#model-ckpt-checkpoint" class="headerlink" title="model.ckpt* checkpoint"></a>model.ckpt* checkpoint</h4><p>tensorflow的检查点文件，用于保存训练的模型</p><h4 id="out-json"><a href="#out-json" class="headerlink" title="out.json"></a>out.json</h4><p>将input.json省略的默认参数补全</p><h4 id="train-log"><a href="#train-log" class="headerlink" title="train.log"></a>train.log</h4><p>滚屏信息文件,要手动在执行dp的时候重定向到train.log</p><h3 id="3-源码分析"><a href="#3-源码分析" class="headerlink" title="3.源码分析"></a>3.源码分析</h3><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20220215083225001.png" alt="image-20220215083225001"></p><h4 id="1-entrypoints"><a href="#1-entrypoints" class="headerlink" title="(1)entrypoints"></a>(1)entrypoints</h4><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20220219194736698.png" alt="image-20220219194736698"></p><h4 id="2-train-py"><a href="#2-train-py" class="headerlink" title="(2)train.py"></a>(2)train.py</h4><p>进入train.py查看训练过程</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20220219204639510.png" alt="image-20220219204639510"></p><p>其中一开始跳转到run_options.py的RunOptions类，_init_方法中首先调用_try_init_distrib方法，使用horovod做分布式训练，若HVD.size()&gt;1,则调用_init_distributed()初始化分布式训练</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20220219203057796.png" alt="image-20220219203057796"></p><p>回到train方法来,在对jdata进行一系列处理后进入_do_work，开始训练</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20220219212025761.png" alt="image-20220219212025761"></p><h4 id="3-do-work"><a href="#3-do-work" class="headerlink" title="(3)_do_work"></a>(3)_do_work</h4><p>这个函数是执行的线性训练</p><p>首先构造DPTrainer类，DPTrainer的定义在trainer.py中，从jdata（input.json）和run_opt(控制台参数)中获取DPTrainer的属性</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20220220181739558.png" alt="image-20220220181739558"></p><p>构造descrpt</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20220220190506148.png" alt="image-20220220190506148"></p><p>然后构造fitting net</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20220220190641539.png" alt="image-20220220190641539"></p><p>初始化模型</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20220220190859878.png" alt="image-20220220190859878"></p><p>初始化学习率</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20220220192738841.png" alt="image-20220220192738841"></p><p>初始化loss</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20220220192954542.png" alt="image-20220220192954542"></p><p>DPTrainer构造结束后，回到train.py的_do_work方法</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20220220195019871.png" alt="image-20220220195019871"></p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20220220201412445.png" alt="image-20220220201412445"></p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20220220201511179.png" alt="image-20220220201511179"></p><p>接下来进入trainer.py的build方法</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20220221162424074.png" alt="image-20220221162424074"></p><p>在_build_network这个方法里build了model</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20220228221832976.png" alt="image-20220228221832976"></p><p>进入model.build,在这里descript和fittiingnet进行了build</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20220228221909831.png" alt="image-20220228221909831"></p><p>需要关注_build_training这个方法</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20220221213520025.png" alt="image-20220221213520025"></p><p>最后在train.py中调用train方法，进入trainer.py中</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20220221164918323.png" alt="image-20220221164918323"></p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20220221165341097.png" alt="image-20220221165341097"></p><p>train方法首先_init_session()，</p><p>_init_session里面新建了Session，并执行了init_op（tf.global_variables_initializer()）</p><p>然后run_sess两次，第一次获得全局步长，第二次确定学习率</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20220221193532724.png" alt="image-20220221193532724"></p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20220221193543019.png" alt="image-20220221193543019"></p><p>第三次run_sess就是训练了</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20220221193606567.png" alt="image-20220221193606567"></p><p>后面又有一次run_sess是更新cur_batch</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20220221193633155.png" alt="image-20220221193633155"></p><h4 id="4-custom-op"><a href="#4-custom-op" class="headerlink" title="(4)custom_op"></a>(4)custom_op</h4><h2 id="并行训练"><a href="#并行训练" class="headerlink" title="并行训练"></a>并行训练</h2><p>并行训练不需要在input.json中指定参数，根据训练过程的数量(根据MPI上下文)和可用GPU卡的数量，DeePMD-kit将决定是以并行(分布式)模式还是串行模式启动训练</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">CUDA_VISIBLE_DEVICES=0,1,2,3 ~/openmpi/bin/mpirun -np 4 dp train input.json &gt;train.log 2&gt;&amp;1 &amp;</span></span><br></pre></td></tr></table></figure><p>用平台上自带的openmpi不行，应该是版本太老的原因，用我自己安装的openmpi（版本4.1.2）可行（太坑了，试了差不多两晚上）</p><p>在用nvprof测试速度</p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>kernel fusion</p><p>AI方面的训练加速</p><p>混合精度：自己指定哪一部分使用什么精度</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20220215065502246.png" alt="image-20220215065502246"></p><p>DeePMD文件夹下是第一次用gpu训练，没有规定环境变量，没有开启custom op的gpu运算</p><p>deepmddata是第二次训练，开启了custom op的gpu运算</p><table><thead><tr><th></th><th>gpu</th><th>gpu(custom op on gpu)</th><th>deepmddata2</th><th>dev</th></tr></thead><tbody><tr><td>copper</td><td>200.711</td><td>155.320</td><td>180.573</td><td>162.378</td></tr><tr><td>maglcu</td><td>358.963</td><td>267.503</td><td></td><td></td></tr><tr><td>water</td><td>455.878</td><td>237.085</td><td>247.641</td><td>217.556</td></tr></tbody></table><p>0:gpu float64</p><p>1:custom op with gpu float64</p><p>2:mix precision 单gpu</p><p>3:dev 单gpu custom op on gpu<br>4：单gpu oriign</p><p>tensorflow_venv:在asc2022的基础上魔改：出bug了，尝试回退一下，只进行少量修改</p><p>tensorflow_venv_v2:直接上官方dev版本</p><p>deepmd:dev</p><p>deepmd2:ori</p><p>模型压缩：compress（与本次赛题无关）</p><p>原有的compress是训练完以后进行模型压缩，以便能在推理时减少时间而不影响精度</p><p>compressed training是为了优化训练速度，面向两种情况：训练后期的模型微调和从头开始训练</p><p>模型微调需要先标准训练冻结一个标准模型，然后模型压缩，再利用压缩好的模型开始训练</p><p>从头开始训练就是先标准训练一部分然后停止，然后开始压缩训练</p><h3 id="混合精度优化尝试"><a href="#混合精度优化尝试" class="headerlink" title="混合精度优化尝试"></a>混合精度优化尝试</h3><h4 id="（1）descriptor"><a href="#（1）descriptor" class="headerlink" title="（1）descriptor"></a>（1）descriptor</h4><p>来到descriptor目录下，descriptor.py为抽象类，我们主要关注se_a.py这个实现</p><p>descriptor下的启用混合精度都是必须开启embedding net才行，那样就修改了input.json，此路不通（按照规则应该不能使用type embedding才对）</p><p>转而查看se_a.py下的所有涉及到precision的部分，尝试能否在这里不使用全局变量而单独修改精度</p><p>se_a.py</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20220228220311333.png" alt="image-20220228220311333"></p><p>fit&#x2F;ener.py</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20220228220327058.png" alt="image-20220228220327058"></p><p>源码其实已经启用了混合精度进行优化，在下面的mixed_precision.enable_mixed_precision_graph_rewrite方法会将某些操作由单精度转为半精度，并使用tensor core进行计算</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20220301191904560.png" alt="image-20220301191904560"></p><p>进一步优化：自己指定每一步的精度进行修改（能优化的比tensorflow自动混合精度更好吗）</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20220301205638928.png" alt="image-20220301205638928"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">DP_ENABLE_MIXED_PREC=fp16 CUDA_VISIBLE_DEVICES=0,1,2,3 ~/openmpi/bin/mpirun -np 4 dp train input.json &gt;train.log 2&gt;&amp;1 &amp;</span></span><br></pre></td></tr></table></figure><h3 id="kernel-fusion"><a href="#kernel-fusion" class="headerlink" title="kernel fusion"></a>kernel fusion</h3><p>先尝试开启XLA</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置开启即时编译</span></span><br><span class="line">config = tf.ConfigProto()</span><br><span class="line">config.graph_options.optimizer_options.global_jit_level = tf.OptimizerOptions.ON_1</span><br><span class="line"></span><br><span class="line">sess = tf.Session(config=config)</span><br></pre></td></tr></table></figure><p>试试这个</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">XLA_FLAGS=--xla_gpu_cuda_data_dir=/home/u2600489/cuda CUDA_VISIBLE_DEVICES=0,1,2,3 ~/openmpi/bin/mpirun -np 4 dp train input.json &gt;train.log 2&gt;&amp;1 &amp;</span></span><br></pre></td></tr></table></figure><p>xla不可用，就是负向优化</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;DeepMD&quot;&gt;&lt;a href=&quot;#DeepMD&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    
    <category term="hpc" scheme="https://mightcoder.com/tags/hpc/"/>
    
    <category term="ASC" scheme="https://mightcoder.com/tags/ASC/"/>
    
  </entry>
  
  <entry>
    <title>滑动窗口</title>
    <link href="https://mightcoder.com/2022/03/16/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    <id>https://mightcoder.com/2022/03/16/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</id>
    <published>2022-03-16T11:39:56.000Z</published>
    <updated>2022-07-15T08:13:03.056Z</updated>
    
    <content type="html"><![CDATA[<h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><h2 id="一-滑动窗口基本思想"><a href="#一-滑动窗口基本思想" class="headerlink" title="一.滑动窗口基本思想"></a>一.滑动窗口基本思想</h2><p>滑动窗口主要用来解决<strong>子串问题</strong>，先说下算法的基本逻辑：<br>使用左右指针维护一个窗口，先移动右指针直到窗口中的字符串符合要求，然后移动左指针缩短字串，直到窗口不符合要求，然后再移动右指针，再左指针，直到右指针到达数组边界。在这个过程中通过一个start和一个len来记录最小字串</p><p>基本算法思路：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> left=<span class="number">0</span>,right=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(right&lt;s.<span class="built_in">size</span>())&#123;</span><br><span class="line">  <span class="comment">//右指针右移增大窗口</span></span><br><span class="line">  window.<span class="built_in">add</span>(s[right]);</span><br><span class="line">  right++;</span><br><span class="line">  <span class="comment">//左指针右移减小窗口</span></span><br><span class="line">  <span class="comment">//如果可以缩小窗口，即窗口仍然符合要求则右移左指针</span></span><br><span class="line">  <span class="keyword">while</span>(window need shrink)&#123;</span><br><span class="line">    window.<span class="built_in">remove</span>(s[left]);</span><br><span class="line">    left++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了基本思路后我们开始编写具体代码框架，先介绍下用到的几个变量：<br>使用哈希表<code>need</code>和<code>window</code>分别记录需要凑齐的字符和窗口中的字符，使用一个变量<code>valid</code>来记录窗口中符合要求字符的个数（当<code>valid==need.size()</code>时表示窗口符合要求），使用<code>start</code>和<code>len</code>记录最小的字串，使用<code>left</code>和<code>right</code>代表窗口（注意是左闭右开的）</p><h2 id="二-滑动窗口基本框架"><a href="#二-滑动窗口基本框架" class="headerlink" title="二.滑动窗口基本框架"></a>二.滑动窗口基本框架</h2><p>所以这类算法的框架为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">slidingWindow</span><span class="params">(string s,string t)</span></span>&#123;</span><br><span class="line">  unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; need,window;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">char</span> c:t)need[c]++;</span><br><span class="line">  <span class="type">int</span> left=right=<span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> valid=<span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span>(right&lt;s.<span class="built_in">size</span>())&#123;</span><br><span class="line">    <span class="type">char</span> c=s[right];</span><br><span class="line">    right++;</span><br><span class="line">    <span class="comment">//在这里更新window中的内容和valid</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果window中字符满足需求</span></span><br><span class="line">    <span class="keyword">while</span>(valid==need.<span class="built_in">size</span>())&#123;</span><br><span class="line">      <span class="type">char</span> d=s[left];</span><br><span class="line">      left++;</span><br><span class="line">      <span class="comment">//更新window窗口和valid</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们找个具体例子试一下</p><blockquote><p>76最小覆盖字串</p><p>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>&quot;&quot;</code> 。</p></blockquote><p>虽然整体框架就是先移动右指针当符合条件再移动左指针直到不满足条件，但是有很多细节非常容易犯错，我将会再下面总结总结。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>()&lt;t.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; need,window;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c:t)need[c]++;</span><br><span class="line">        <span class="type">int</span> start=<span class="number">0</span>,len=INT_MAX;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>,right=<span class="number">0</span>,valid=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (right&lt;s.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="type">char</span> c=s[right];</span><br><span class="line">            right++;</span><br><span class="line">            <span class="comment">//当need中有这个字符时才更新window和valid</span></span><br><span class="line">            <span class="keyword">if</span>(need.<span class="built_in">count</span>(c))&#123;</span><br><span class="line">                window[c]++;</span><br><span class="line">                <span class="keyword">if</span>(window[c]==need[c])&#123;</span><br><span class="line">                    valid++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//left右移</span></span><br><span class="line">            <span class="keyword">while</span> (valid==need.<span class="built_in">size</span>())&#123;</span><br><span class="line">                <span class="keyword">if</span>(right-left&lt;len)&#123;</span><br><span class="line">                    start=left;</span><br><span class="line">                    len=right-left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">char</span> c=s[left];</span><br><span class="line">                left++;</span><br><span class="line">                <span class="keyword">if</span>(need.<span class="built_in">count</span>(c))&#123;</span><br><span class="line">                    <span class="comment">//当window和need中c数量一致，valid才减</span></span><br><span class="line">                    <span class="keyword">if</span>(window[c]==need[c])&#123;</span><br><span class="line">                        valid--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    window[c]--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len==INT_MAX?<span class="string">&quot;&quot;</span>:s.<span class="built_in">substr</span>(start,len);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>总结：<br>1.我们在移动右指针更新window和valid时，要注意只有当<code>need.count(c)</code>条件满足时才更新window，因为如果need中没有这个字符，更新了window没有意义，然后再更新window后要检测<code>window[c]==need[c]</code>，满足才能更新valid，换句话说，更新valid的条件是<code>window[c]==need[c]</code></p><p>2.进入left右移循环后更新window和valid时，要先检测<code>window[c]==need[c]</code>，如果满足再<code>valid–</code>,不满足则不变动valid，因为window[c]可能会大于need[c]，因此不是每次window[c]减少时valid都要减少。</p><p>3.关于<code>start</code>和<code>len</code>的更新，我放到了left右移循环的开头，因为每次进入这个循环都表示此时窗口中符合了条件，注意更新这个两个值的条件为<code>right-left&lt;len</code></p><h2 id="三-几种题型"><a href="#三-几种题型" class="headerlink" title="三.几种题型"></a>三.几种题型</h2><h3 id="1-双字符串不定大小滑动窗口"><a href="#1-双字符串不定大小滑动窗口" class="headerlink" title="1.双字符串不定大小滑动窗口"></a>1.双字符串不定大小滑动窗口</h3><p>以上面的leetcode76为例，求A中B的字串，这样的滑动窗口大小是不固定的，移动方法就是先右指针右移，窗口符合要求后再左指针右移，直到窗口不符合要求再移右指针，如此重复直到右指针到达边界</p><h3 id="2-双字符串固定大小滑动窗口"><a href="#2-双字符串固定大小滑动窗口" class="headerlink" title="2.双字符串固定大小滑动窗口"></a>2.双字符串固定大小滑动窗口</h3><p>以leetcode438为例</p><blockquote><p>给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p><p>异位词 指由相同字母重排列形成的字符串（包括相同的字符串）。</p></blockquote><p>这种滑动窗口就是在上面的基础上固定了窗口的大小，体现在代码上就是初始化right时<code>right=p.size()-1</code>，并且移动窗口时左右指针同时移动，每一次移动完毕以后检测<code>valid==need.size()</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findAnagrams</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>()&lt;p.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="comment">//固定窗口</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt;need ,window;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c:p) need[c]++;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>,right=p.<span class="built_in">size</span>()<span class="number">-1</span>,valid=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;=right ; ++i) &#123;</span><br><span class="line">            <span class="type">char</span> c=s[i];</span><br><span class="line">            <span class="keyword">if</span>(need.<span class="built_in">count</span>(c))&#123;</span><br><span class="line">                window[c]++;</span><br><span class="line">                <span class="keyword">if</span>(window[c]==need[c])</span><br><span class="line">                    valid++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(valid==need.<span class="built_in">size</span>())</span><br><span class="line">            result.<span class="built_in">emplace_back</span>(left);</span><br><span class="line">        <span class="keyword">while</span> (right&lt;s.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="type">char</span> c=s[left];</span><br><span class="line">            <span class="keyword">if</span>(need.<span class="built_in">count</span>(c))&#123;</span><br><span class="line">                <span class="keyword">if</span>(window[c]==need[c])</span><br><span class="line">                    valid--;</span><br><span class="line">                window[c]--;</span><br><span class="line">            &#125;</span><br><span class="line">            right++;left++;</span><br><span class="line">            c=s[right];</span><br><span class="line">            <span class="keyword">if</span>(need.<span class="built_in">count</span>(c))&#123;</span><br><span class="line">                window[c]++;</span><br><span class="line">                <span class="keyword">if</span>(window[c]==need[c])</span><br><span class="line">                    valid++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(valid==need.<span class="built_in">size</span>())</span><br><span class="line">                result.<span class="built_in">emplace_back</span>(left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-单字符串不定大小滑动窗口"><a href="#3-单字符串不定大小滑动窗口" class="headerlink" title="3.单字符串不定大小滑动窗口"></a>3.单字符串不定大小滑动窗口</h3><p>以leetcode003为例</p><blockquote><p>给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度</p></blockquote><p>解答这道题的思路就是用两个指针代表滑动窗口，先右指针右移，直到不满足条件（有重复字符），再左指针右移直至满足条件，在此过程中每当满足条件时更新字串的长度，直至右指针到达边界后结束</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先写下思路，用哈希表记录字符，得知是否含有重复子串</span></span><br><span class="line">        <span class="comment">//然后先移动右指针，直至不符合条件，再移动左指针，直至满足条件，当满足条件时更新len</span></span><br><span class="line">        <span class="comment">//最终的终止条件应该为右指针移动到尽头，左指针移动到满足条件</span></span><br><span class="line"></span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; window;</span><br><span class="line">        <span class="comment">//左开右闭</span></span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>,right=<span class="number">0</span>,len=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (right&lt;s.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="type">char</span> c=s[right];</span><br><span class="line">            right++;</span><br><span class="line">            <span class="comment">//count方法返回的是键值对的个数，这里因为前面已经建立起键值对了，虽然值为0，返回的还是1</span></span><br><span class="line">            <span class="keyword">while</span> (window[c])&#123;</span><br><span class="line">                <span class="type">char</span> l=s[left];</span><br><span class="line">                window[l]--;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            window[c]++;</span><br><span class="line">            <span class="keyword">if</span>(len&lt;right-left)</span><br><span class="line">                len=right-left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;滑动窗口&quot;&gt;&lt;a href=&quot;#滑动窗口&quot; class=&quot;headerlink&quot; title=&quot;滑动窗口&quot;&gt;&lt;/a&gt;滑动窗口&lt;/h1&gt;&lt;h2 id=&quot;一-滑动窗口基本思想&quot;&gt;&lt;a href=&quot;#一-滑动窗口基本思想&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    
    <category term="leetcode" scheme="https://mightcoder.com/tags/leetcode/"/>
    
    <category term="数组" scheme="https://mightcoder.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="滑动窗口" scheme="https://mightcoder.com/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>optimizing_cpp(1-4)</title>
    <link href="https://mightcoder.com/2022/03/15/optimizing-cpp-1-4/"/>
    <id>https://mightcoder.com/2022/03/15/optimizing-cpp-1-4/</id>
    <published>2022-03-15T02:39:37.000Z</published>
    <updated>2022-07-15T08:13:03.053Z</updated>
    
    <content type="html"><![CDATA[<h1 id="optimizing-cpp"><a href="#optimizing-cpp" class="headerlink" title="optimizing_cpp"></a>optimizing_cpp</h1><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>本笔记是对Agner Fog优化手册中cpp优化手册的笔记，记录下对自己有用的东西。</p><h2 id="二-选择最优平台"><a href="#二-选择最优平台" class="headerlink" title="二.选择最优平台"></a>二.选择最优平台</h2><p>编程语言的发展揭示了一个曲折的历史，反映了执行效率、可移植性、开发效率的冲突。</p><p>三种类型的编程语言较好的解决以上三种问题：编译型、中间代码和即时编译（intermediate code and just-in-time compilation）或者中间代码和解释器（例如某些java）、解释型。</p><p>在优化之前要选择最优的平台，步骤可以为选择硬件-选择编程语言-选择编译器-选择函数库</p><p>选择编译器时有以下几种考虑</p><ul><li>GNU：开源免费跨平台</li><li>intel：可以自动cpu调度，为不同的cpu制定多核版本代码，但是在其他品牌的cpu运行效率不好</li><li>clang：基于LLVM，性能很强</li></ul><p>选择函数库</p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/image-20220314210312761.png" alt="image-20220314210312761">cpp的安全性问题</p><p>cpp的安全性就体现在指针上，为了避免出错，要坚持几个编程原则 </p><p>①为了避免出现无效指针（nullpointer）</p><ul><li>使用引用代替指针</li><li>将指针初始化为零</li><li>一旦指针指向的对象变为无效，把指针设置为零</li><li>避免指针运算和指针类型转换</li></ul><p>②另外，为了防止数组溢出，可以使用充分测试的容器类来代替数组，例如STL库，有关如何避免动态内存分配的问题后面会说明</p><h2 id="三-寻找程序热点"><a href="#三-寻找程序热点" class="headerlink" title="三.寻找程序热点"></a>三.寻找程序热点</h2><h3 id="1-使用profiler找到热点"><a href="#1-使用profiler找到热点" class="headerlink" title="1.使用profiler找到热点"></a>1.使用profiler找到热点</h3><p>以下为几种常用的性能分析（profiling）方法</p><ul><li>插桩（Instrumentation）:编译器在每次函数调用时插入额外的代码来计算函数调用次数和执行花费的时间</li><li>debugging：在每个函数或者代码处插入断点</li><li>基于时间的采样：分析器告诉操作系统产生中断，例如，每毫秒一次。分析器计算程序每个部分中断发生的次数。这不需要修改正在测试的程序，但不太可靠</li><li>基于事件的采样：分析器告诉CPU在某些事件时产生中断，例如，每当一千次高速缓存未命中时。这样就可以发现程序的哪一部分具有最多的高速缓存未命中，分支错误预测，浮点异常等。基于事件的采样需要CPU特定的分析器。对于Intel CPU，需要使用Intel VTune，AMD CPU则使用AMD CodeAnalyst。</li></ul><p>最常用的方式就是将插桩代码直接放入代码中，而不是使用现成的分析器（这里后面会详细阐述，记得回头看一眼）</p><h3 id="2-动态链接和位置无关代码（position-independent-code-）"><a href="#2-动态链接和位置无关代码（position-independent-code-）" class="headerlink" title="2.动态链接和位置无关代码（position-independent code  ）"></a>2.动态链接和位置无关代码（position-independent code  ）</h3><p>有几个因素会使得动态链接库比静态链接库慢，会在下面详细解释。</p><p>position-independent code 常用在unix系统中的so文件，mac系统默认情况下经常使用位置无关代码，position-independent code  效率低下，尤其在32位模式下，原因下面会详细解释。</p><h3 id="3-文件访问"><a href="#3-文件访问" class="headerlink" title="3.文件访问"></a>3.文件访问</h3><p>在IO密集型程序中，访问磁盘常常是占用时间极多的，在访问文件时有以下几个小建议：</p><p>顺序前向访问文件比随机访问快。读取或者写入大的数据块比多次读写小数据要快。可以将文件镜像到内存的缓冲区中，并一次性读写。</p><p>访问最近访问的文件要比第一次访问文件要快的多。因为该文件被复制到磁盘缓存。</p><p>对于包含数值数据的大文件，以二进制形式存储，比数据以ASCII形式存储更加紧凑和高效。</p><p>如果在等待磁盘操作完成时处理器可以执行其他工作，则将文件访问放入单独的线程中可能是有利的。</p><h3 id="4-内存访问"><a href="#4-内存访问" class="headerlink" title="4.内存访问"></a>4.内存访问</h3><p>访存通常是一个重要的优化项目，着手点在于cache。通常情况下，cpu有一级缓存二级缓存还可能有三级缓存。下列情况下，很可能内存访问是程序中最大的时间消耗：程序中所有数据的组合大于二级缓存且数据分散在内存中或者以非顺序方式访问。</p><p>如果数据被存入cache，读写只需要2-3个时钟周期，但如果没有cache，则需要几百个时钟周期。</p><h3 id="5-上下文切换"><a href="#5-上下文切换" class="headerlink" title="5.上下文切换"></a>5.上下文切换</h3><p>上下文切换在多线程程序中主要指多个线程之间的切换，频繁上下文切换会降低性能</p><h3 id="6-依赖关系链"><a href="#6-依赖关系链" class="headerlink" title="6.依赖关系链"></a>6.依赖关系链</h3><p>依赖关系链是一系列的计算，每个计算取决于前一个的结果，依赖关系链会组织CPU同时进行多次计算并阻止乱序执行（乱序执行是指如果制定了先A再B的计算，微处理器可以在计算A完成之前开始B的计算，显然这只有在计算B之前不需要A的值才可能），关于如何有效中断依赖关系链，后面会详细说明。</p><h3 id="7-执行单元吞吐量"><a href="#7-执行单元吞吐量" class="headerlink" title="7.执行单元吞吐量"></a>7.执行单元吞吐量</h3><p>执行单元吞吐量（throughout）和latency（延迟？应该为等待单个计算完成的时间）有本质的差别。例如，在现代CPU上执行浮点加法可能需要3到5个时钟周期。但是有可能在每个时钟周期开始一个新的浮点加法。 这意味着</p><ul><li>如果每次加法都取决于前面加法的结果，那么每三个时钟周期只有一次加法。</li><li>但是如果所有的加法都是独立的，那么你可以在每个时钟周期进行一次加法。</li></ul><p>因此当计算密集型程序满足前面提到的各种情形不是耗时的主要原因并且没有长依赖关系链，此时性能受单元吞吐量限制，而不是lantency或者IO</p><p>现代微处理器的执行核心切分为几个执行单元。通常，</p><ul><li>有两个或更多个整数单元，</li><li>一个或两个浮点加法单元</li><li>以及一个或两个浮点乘法单元。</li></ul><p>这意味着可以在同一时间进行整数加法，浮点加法和浮点乘法运算。</p><p>所以如果一段代码进行浮点运算，最好混合浮点加法或者整数运算，在浮点运算之间，可以进行整数运算而不降低性能，这是因为整数运算使用不同的执行单元。</p><h2 id="四-选择最优算法"><a href="#四-选择最优算法" class="headerlink" title="四.选择最优算法"></a>四.选择最优算法</h2><p>当优化一个计算密集型程序时，首先要找到最好的算法，在编写代码前，要考虑其他人是否已经做过这项工作（造好的轮子），Anger给出的例子</p><ul><li>Boost的集合包，包含用于许多通用的，经过良好测试的库 <a href="www.boost.org">www.boost.org</a>。</li><li>“英特尔数学核心函数库”（”Intel Math Kernel Library”）包含许多常见数学计算函数，包括线性代数和统计学</li><li>“英特尔性能基元”（”Intel Performance Primitives”）函数库包含许多用于音频和视频处理，信号处理，数据压缩和加密的函数 <a href="www.intel.com">www.intel.com</a>。</li></ul><p>如果使用英特尔函数库，要确保它在非英特尔处理器上正常工作。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;optimizing-cpp&quot;&gt;&lt;a href=&quot;#optimizing-cpp&quot; class=&quot;headerlink&quot; title=&quot;optimizing_cpp&quot;&gt;&lt;/a&gt;optimizing_cpp&lt;/h1&gt;&lt;h2 id=&quot;一、简介&quot;&gt;&lt;a</summary>
        
      
    
    
    
    
    <category term="hpc" scheme="https://mightcoder.com/tags/hpc/"/>
    
    <category term="cpp" scheme="https://mightcoder.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>二分查找</title>
    <link href="https://mightcoder.com/2022/03/15/%E3%80%90leetcode%E3%80%91%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <id>https://mightcoder.com/2022/03/15/%E3%80%90leetcode%E3%80%91%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</id>
    <published>2022-03-15T02:34:43.000Z</published>
    <updated>2022-07-15T08:13:03.055Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h1><p>从今天开始使用另一种刷题方式和记笔记方式，按照刷题笔记的模块划分把一类题刷明白，并且按照模块总结笔记总结经验，还要保证不断复习！</p><h2 id="一-最基础的二分查找"><a href="#一-最基础的二分查找" class="headerlink" title="一.最基础的二分查找"></a>一.最基础的二分查找</h2><p>先粘代码，查找某个数都是这个格式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>,right=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left&lt;=right)&#123;</span><br><span class="line">            <span class="type">int</span> mid=left + (right - left) / <span class="number">2</span> ;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]==target)&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;target)&#123;</span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                right=mid<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>有两个点是需要注意，容易犯错的</p><h3 id="1-while循环中的条件"><a href="#1-while循环中的条件" class="headerlink" title="1.while循环中的条件"></a>1.while循环中的条件</h3><p>在上面的代码中while循环里的条件是<code>left&lt;=right</code>，而不是<code>left&lt;right</code>的原因是如果使用<code>left&lt;right</code>当left和right相等时，比如left&#x3D;right&#x3D;2，会跳出循环，这样就漏掉了这个数。因此要谨记是小于等于。</p><h3 id="2-left-mid-1-right-mid-1"><a href="#2-left-mid-1-right-mid-1" class="headerlink" title="2.left&#x3D;mid+1 right&#x3D;mid-1"></a>2.left&#x3D;mid+1 right&#x3D;mid-1</h3><p>这里更新left和right的值没有使用<code>left=mid,right=mid</code>的原因是，我们进入循环的第一个if判断已经判断出mid不是我们的target了，所以在后续的更新中不需要从mid开始，而是从<code>mid-1,mid+1</code>开始。</p><h3 id="3-其他tips"><a href="#3-其他tips" class="headerlink" title="3.其他tips"></a>3.其他tips</h3><p>有一个要知道的前提是我们搜索的范围是<code>[left,right]</code>，全闭区间，所以<code>left=0，right=nums.size()-1</code></p><p>另外还有一个点很容易忽略，就是在上面的代码中定义mid时使用的是<code>int mid=left + (right - left) / 2 ;</code>而不是<code>int mid=(left+right)/2;</code>。这里是一个很细微的细节，因为测试用例中可能会有范围非常大的情况，大到left+right超出int的范围溢出，而上面的这种写法很好的避免了溢出，并且结果与<code>int mid=(left+right)/2;</code>相同。</p><blockquote><p>总结：定义left,right，while循环，定义mid，判断mid，根据nums[mid]与target大小更新left和right</p><p>注意：1.while里写<code>left&lt;=right</code>2.<code>left=mid+1.right=mid-1</code></p></blockquote><h2 id="二、二分查找寻找左侧边界"><a href="#二、二分查找寻找左侧边界" class="headerlink" title="二、二分查找寻找左侧边界"></a>二、二分查找寻找左侧边界</h2><p>在有些情况下，并不是找到目标值的索引就够了，比如有序数组<code>nums=[1,2,2,2,3]</code>,target为3，此时我想得到target的左侧边界，上面的算法就不奏效了，需要改进。</p><p>先粘代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarysearch</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> left=<span class="number">0</span>,right=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left&lt;=right)&#123;</span><br><span class="line">        <span class="type">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]&lt;target)&#123;</span><br><span class="line">            left=mid+<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&gt;target)&#123;</span><br><span class="line">            right=mid<span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            right=mid<span class="number">-1</span>;<span class="comment">//收缩右侧边界</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span>(left&gt;nums.<span class="built_in">size</span>()<span class="number">-1</span>||nums[left]!=target)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>while循环里的条件和当<code>nums[mid]&lt;target，nums[mid]&gt;target</code>时更新left和right的方式不变，唯一发生改变的是当<code>nums[mid]=target</code>时不会返回mid，而是<code>right=mid-1</code>更新right，收缩右侧边界。</p><p>这段代码跳出循环的条件依旧是<code>left==right+1</code>，有以下四种情况：①当数组中存在target时，<code>right=mid-1</code>会使right的值等于left-1，跳出while循环；②当<code>nums</code>中所有数都小于target，最终left&#x3D;num.size()，跳出while循环；③当<code>nums</code>中所有数都大于target，最终right&#x3D;-1，跳出while循环；④当target不存在但是<code>nums</code>中有比它大和小的数时，此时的left等于<code>nums</code>中小于target的个数（<strong>这是一个很重要的特性</strong>）。</p><p>所以跳出循环后要根据left的值判断是哪种跳出循环的情况。若<code>left&gt;=nums.size()</code>,表示<code>nums</code>中所有数都小于target，对应第②种情况；若<code>nums[left]!=target</code>表示left没有移动或者移动了却没有找到target，对应第③④种情况；这两种都不是说明已经找到了target的左侧边界，返回<code>left</code>；</p><blockquote><p>总结：在二分查找基础上，修改当<code>nums[mid]==target</code>时执行的语句为<code>right=mid-1</code>，以此来收缩右侧边界，并且在跳出循环后要判断<code>left&gt;nums.size()-1||nums[left]!=target</code>，都不符合才返回-1。<br>此外，当<code>nums</code>中没有target时，left代表了<code>nums</code>中大于target的个数！！</p><p>注意：记得当<code>nums[mid]==target</code>时执行的语句为<code>right=mid-1</code>，记得最后要判断left的值，看有没有移动到大于<code>nums.size()-1</code>的地方，或者没有移动（通过<code>nums[left]!=target</code>来判断），最后再返回left</p></blockquote><h2 id="三、二分查找寻找右侧边界"><a href="#三、二分查找寻找右侧边界" class="headerlink" title="三、二分查找寻找右侧边界"></a>三、二分查找寻找右侧边界</h2><p>跟查找左侧边界类似，只需要修改几个地方</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarysearch</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> left=<span class="number">0</span>,right=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left&lt;=right)&#123;</span><br><span class="line">        <span class="type">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]&lt;target)&#123;</span><br><span class="line">            left=mid+<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&gt;target)&#123;</span><br><span class="line">            right=mid<span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            left=mid+<span class="number">1</span>;<span class="comment">//收缩左侧边界</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span>(right&lt;<span class="number">0</span>||nums[right]!=target)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跳出while循环只有三种情况，与寻找左侧边界时类似</p><blockquote><p>注意：在寻找左侧边界的基础上记得改成<code>left=mid+1</code>收缩左侧边界，跳出循环后条件也变成了判断right,<code>right&lt;0||nums[right]!=target</code></p></blockquote><p>练习：</p><p>二分查找寻找左侧边界和右侧边界</p><blockquote><p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p><p>如果数组中不存在目标值 target，返回 [-1, -1]。</p></blockquote><p>我们很简单的先找左侧边界再找右侧边界就可以了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">binarySearchLeft</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]==target)&#123;</span><br><span class="line">                right=mid<span class="number">-1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;target)&#123;</span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&gt;target)&#123;</span><br><span class="line">                right=mid<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left&gt;nums.<span class="built_in">size</span>()<span class="number">-1</span>||nums[left]!=target)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">binarySearchRight</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]==target)&#123;</span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;target)&#123;</span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&gt;target)&#123;</span><br><span class="line">                right=mid<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right&lt;<span class="number">0</span>||nums[right]!=target)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span>&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="built_in">binarySearchLeft</span>(nums,target), <span class="built_in">binarySearchRight</span>(nums,target)&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>二分查找寻找左侧边界中left含义的应用</p><blockquote><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>请必须使用时间复杂度为 O(log n) 的算法。</p></blockquote><p>善用left含义的定义，代表的含义是<code>nums</code>中大于target的个数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">searchInsert</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>,right=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left&lt;=right)&#123;</span><br><span class="line">            <span class="type">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&lt;target)&#123;</span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&gt;target)&#123;</span><br><span class="line">                right=mid<span class="number">-1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]==target)&#123;</span><br><span class="line">                right=mid<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="四、二分搜索问题的泛化"><a href="#四、二分搜索问题的泛化" class="headerlink" title="四、二分搜索问题的泛化"></a>四、二分搜索问题的泛化</h2><p>传统的二分搜索算法解决的是在有序数组中寻找某个值的下标或者左右界，但是除了这种问题，二分搜索还能进行泛化，转变为解决：</p><blockquote><p>一个自变量x，一个关于x的函数f(x)，一个目标值target。<br>并且题目要求满足：<br>1.f(x)必须是x上的单调函数<br>2.题目要求f(x)&#x3D;&#x3D;target时x的值</p></blockquote><p>接下来以力扣857题为例</p><blockquote><p>珂珂喜欢吃香蕉。这里有 N 堆香蕉，第 i 堆中有 piles[i] 根香蕉。警卫已经离开了，将在 H 小时后回来。</p><p>珂珂可以决定她吃香蕉的速度 K （单位：根&#x2F;小时）。每个小时，她将会选择一堆香蕉，从中吃掉 K 根。如果这堆香蕉少于 K 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。  </p><p>珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。</p><p>返回她可以在 H 小时内吃掉所有香蕉的最小速度 K（K 为整数）。</p></blockquote><p>这里我们比较容易的看出target就是H，x应该是K，则我们需要构造一个函数F(x)来与target比较，那么这个函数应该是求根据速度求时间的函数，上代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;algorithm&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//建模，x为进食速度，F(x)为计算进食所需时间的函数，target就是给我们的时间H</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x,vector&lt;<span class="type">int</span>&gt;&amp; piles)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> time=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;piles.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            time+=piles[i]/x;</span><br><span class="line">            <span class="keyword">if</span>(piles[i]%x!=<span class="number">0</span>)</span><br><span class="line">                time++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> time;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minEatingSpeed</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; piles, <span class="type">int</span> h)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;piles.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(piles[i]&gt;max)</span><br><span class="line">                max=piles[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里left和right的取值要进行考虑，left和right应该是速度，最小应该为1，最大应该为piles中的最大值，因为一次吃一堆，再大也没有用了</span></span><br><span class="line">        <span class="comment">//但是取最大值要进行计算，或者直接取piles数组中数字取值的最大值，根据题意可以得知是10000</span></span><br><span class="line">        <span class="type">int</span> left=<span class="number">1</span>,right=max;</span><br><span class="line">        <span class="keyword">while</span> (left&lt;=right)&#123;</span><br><span class="line">            <span class="type">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">f</span>(mid,piles)&lt;h)</span><br><span class="line">                right=mid<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">f</span>(mid,piles)&gt;h)</span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>另一道题目也是类似的思路</p><blockquote><p>传送带上的包裹必须在 days 天内从一个港口运送到另一个港口。</p><p>传送带上的第 i 个包裹的重量为 weights[i]。每一天，我们都会按给出重量（weights）的顺序往传送带上装载包裹。我们装载的重量不会超过船的最大运载重量。</p><p>返回能在 days 天内将传送带上的所有包裹送达的船的最低运载能力。</p></blockquote><p>套路都是类似的，只不过每次求left和right时需要思考一下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//建模，target为days，x应该为运载能力，f(x)为求某运载能力所需的时间</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x,vector&lt;<span class="type">int</span>&gt;&amp; weights)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> days=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;weights.<span class="built_in">size</span>();)&#123;</span><br><span class="line">            <span class="type">int</span> cap=x;</span><br><span class="line">            <span class="keyword">while</span> (i&lt;weights.<span class="built_in">size</span>())&#123;</span><br><span class="line">                <span class="keyword">if</span>(cap&lt;weights[i])</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    cap-=weights[i];</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            days++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> days;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">shipWithinDays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; weights, <span class="type">int</span> days)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> max=<span class="number">0</span>,sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;weights.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            sum+=weights[i];</span><br><span class="line">            <span class="keyword">if</span>(max&lt;weights[i])</span><br><span class="line">                max=weights[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//上下界如何选取？下届应该是weight中的最大值，因为每次必须带走一件货物，所以下届应该是最大值，最大载重就是一次将weight中所有货物带走，因此是weight中所有重量之和</span></span><br><span class="line">        <span class="type">int</span> left=max,right=sum;</span><br><span class="line">        <span class="keyword">while</span> (left&lt;=right)&#123;</span><br><span class="line">            <span class="type">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">f</span>(mid,weights)&gt;days)</span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">f</span>(mid,weights)&lt;days)</span><br><span class="line">                right=mid<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意，这种方法虽然方便记忆，但是效率上不是很高，在力扣上执行的速度偏慢，如果可以的话，还是去学下题解中由二分搜索转为判定问题的方法。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;二分搜索&quot;&gt;&lt;a href=&quot;#二分搜索&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    
    <category term="leetcode" scheme="https://mightcoder.com/tags/leetcode/"/>
    
    <category term="数组" scheme="https://mightcoder.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="二分查找" scheme="https://mightcoder.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>【live house】2021.6.4 王以太 《演说家》</title>
    <link href="https://mightcoder.com/2021/12/05/%E3%80%90live%20house%E3%80%912021-6-4-%E7%8E%8B%E4%BB%A5%E5%A4%AA-%E3%80%8A%E6%BC%94%E8%AF%B4%E5%AE%B6%E3%80%8B/"/>
    <id>https://mightcoder.com/2021/12/05/%E3%80%90live%20house%E3%80%912021-6-4-%E7%8E%8B%E4%BB%A5%E5%A4%AA-%E3%80%8A%E6%BC%94%E8%AF%B4%E5%AE%B6%E3%80%8B/</id>
    <published>2021-12-05T15:57:59.000Z</published>
    <updated>2022-07-15T08:13:03.053Z</updated>
    
    <content type="html"><![CDATA[<p>  2021的第一场livehouse，王以太的《演说家》，全是我喜欢的歌，和软件园的四个朋友一起去的，超嗨，唯二不足的就是大麦的场地太平了，后面的都看不太见，另外开场太晚了，王以太 唱的都太急了。</p><p>  另外艾福杰尼唱的真是稳，牛的。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="img"></p><p><img src="https://s2.loli.net/2021/12/06/2duRiG8f1twUXa3.jpg" alt="img"></p><p><img src="https://s2.loli.net/2021/12/06/938kNz4eFxMoUBl.jpg" alt="img"></p><p><img src="https://might-image-bed.oss-cn-hangzhou.aliyuncs.com/imgbed/1638720144951.jpeg" alt="img"></p><p><img src="https://s2.loli.net/2021/12/06/6qmPeZtsy5X8SAK.jpg" alt="img"></p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;  2021的第一场livehouse，王以太的《演说家》，全是我喜欢的歌，和软件园的四个朋友一起去的，超嗨，唯二不足的就是大麦的场地太平了，后面的都看不太见，另外开场太晚了，王以太 唱的都太急了。&lt;/p&gt;
&lt;p&gt;  另外艾福杰尼唱的真是稳，牛的。&lt;/p&gt;
&lt;p&gt;&lt;img</summary>
        
      
    
    
    
    
    <category term="livehouse" scheme="https://mightcoder.com/tags/livehouse/"/>
    
  </entry>
  
  <entry>
    <title>【话剧】恋爱的犀牛</title>
    <link href="https://mightcoder.com/2021/12/05/%E3%80%90%E8%AF%9D%E5%89%A7%E3%80%91%E6%81%8B%E7%88%B1%E7%9A%84%E7%8A%80%E7%89%9B/"/>
    <id>https://mightcoder.com/2021/12/05/%E3%80%90%E8%AF%9D%E5%89%A7%E3%80%91%E6%81%8B%E7%88%B1%E7%9A%84%E7%8A%80%E7%89%9B/</id>
    <published>2021-12-05T14:12:54.000Z</published>
    <updated>2022-07-15T08:13:03.055Z</updated>
    
    <content type="html"><![CDATA[<h1 id="【话剧】恋爱的犀牛"><a href="#【话剧】恋爱的犀牛" class="headerlink" title="【话剧】恋爱的犀牛"></a>【话剧】恋爱的犀牛</h1><p>​    今晚文学院的话剧社来软件园演出，正好闲着便去看了一场恋爱的犀牛，第一次看话剧，的确感觉奇特，以前一直好奇为什么会有人喜欢去现场看话剧，现在流媒体这么发达，电影电视剧都看不完，况且许多话剧也已经上传到了网络上，何苦花钱跑到线下去看呢。看过之后才明白线下看话剧的感觉：与电影电视剧不同，大多数电影电视剧都是力求自然真实，而话剧却是充满戏剧感，人物的念白动作以及音乐都很夸张，就像是一本文学书中的人物活过来一样，话剧这种形式是很贴近文学的表演形式。此外，在线下听到演员的声音看到演员的表演也让人有种别样的感觉，尤其是每一幕间隔现场演奏的音乐，现场的效果真是太赞了!从此话剧便和livehouse脱口秀一样成为我看演出的第三个选择了。</p><p>​    说回话剧本身，《恋爱的犀牛》是一部很有名气的话剧，甚至我这个从未了解过话剧的人都听说过（当然是因为段宏毅演过一个版本），本以为看名字是个爱情故事，没想到确实是爱情故事，只不过却是如此癫狂的爱情。</p><p>​    这部话剧是99年上演的，描述的是那个时代的人 对于爱情的思考和执着，然而放到2021年，或许名字会被另一个庸俗的名字替代，《恋爱的舔狗》，今天的我来思考这部话剧的描述的爱情，已经很难在现实中找到原型了，别误会，我并非感到可惜，只是觉得自然，我不止一次的想向马陆发问，为什么你爱她她就要接受你呢，这世间最让自己恶心的就是自作多情，最令别人恶心的就是自作多情而不自知。越是得不到一个东西，就越会想要，就越会把它看得珍贵。马陆自己认为明明是一切，自己的爱是一切，但明明只把这爱情当狗屎，可笑的是她的爱在陈飞眼里也只是狗屎而已。当我们跳出文艺青年伤痛文学的氛围，回到现实的大地，我更希望爱情失意者们都能清醒一点，别那么自以为是和自作动情，爱情很好，但只有两个人的时候才算好。</p><p>​    上天会厚待那些勇敢的、坚强的、多情的人，多希望这不是自我安慰。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;【话剧】恋爱的犀牛&quot;&gt;&lt;a href=&quot;#【话剧】恋爱的犀牛&quot; class=&quot;headerlink&quot; title=&quot;【话剧】恋爱的犀牛&quot;&gt;&lt;/a&gt;【话剧】恋爱的犀牛&lt;/h1&gt;&lt;p&gt;​   </summary>
        
      
    
    
    
    
    <category term="话剧" scheme="https://mightcoder.com/tags/%E8%AF%9D%E5%89%A7/"/>
    
  </entry>
  
  <entry>
    <title>个人网站搭建</title>
    <link href="https://mightcoder.com/2021/11/30/%E3%80%90leetcode%E3%80%91%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/"/>
    <id>https://mightcoder.com/2021/11/30/%E3%80%90leetcode%E3%80%91%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/</id>
    <published>2021-11-30T11:04:18.000Z</published>
    <updated>2021-11-30T13:13:33.837Z</updated>
    
    <content type="html"><![CDATA[<h1 id="个人网站搭建"><a href="#个人网站搭建" class="headerlink" title="个人网站搭建"></a>个人网站搭建</h1><h3 id="一、选择搭建方案"><a href="#一、选择搭建方案" class="headerlink" title="一、选择搭建方案"></a>一、选择搭建方案</h3><h4 id="1、上手即用型"><a href="#1、上手即用型" class="headerlink" title="1、上手即用型"></a>1、上手即用型</h4><p>这类网站拥有自助建站服务，不需要接触代码，只需要选择自己喜欢的模板，然后在后台使用可视化编辑器添加文章和图片即可，适合没有技术基础，想要快速建站的用户</p><p>优点：不需要编程基础     快捷     美观</p><p>缺点：拓展性极差，只能使用已有的模板，无法添加特定功能      对数据的掌控型差，无法自己控制后台   页面受限于模板，无法添加酷炫自主的东西     价格较高</p><p>例如：<a href="https://www.squarespace.com/">Squarespace</a>   <a href="https://www.weebly.com/">Weebly</a>   <a href="https://www.wix.com/">Wix</a>   <a href="https://typlog.com/">Typlog</a>   godaddy的建站神器也可</p><h4 id="2-初涉专业型"><a href="#2-初涉专业型" class="headerlink" title="2.初涉专业型"></a>2.初涉专业型</h4><p>这类建站方式需要一定的编程基础，可以在已有模板的基础上添加自己的模块和设计，并且有丰富的第三方插件实现多样的功能，同样的，这些建站方式也可以建造出美观酷炫的网站</p><p>优点：拓展性强     较为方便    美观酷炫    拓展性强</p><p>缺点：需要编程基础   可能需要自己的服务器   部署较为麻烦</p><p>主要分为以下两个类型：静态生成技术  内容管理系统</p><h5 id="（1）静态网站生成技术"><a href="#（1）静态网站生成技术" class="headerlink" title="（1）静态网站生成技术"></a>（1）静态网站生成技术</h5><p>在终端执行命令快速生成静态网站，静态网站是最初的建站方式，浏览者所看到的每个页面是建站者上传到服务器上的一个 html文件，每增加、删除、修改一个页面，都必须重新对服务器的文件进行一次下载上传。</p><p>通过这些工具，你只需要用 Markdown 撰写你的博文，设置好 Hexo，它就可以帮你生成整个网站的源码；接着，将源码上传到 Github 之后，大家就可以访问你的博客了。</p><p>这种方式简单，易于操作，且可以利用GitHub.io   coding等等托管平台发布pages，从而无需自己购买域名和云服务器</p><p>例如 Jekyll、Hugo、Hexo等</p><p>另外还有gridea这样的GUI书写工具，帮助你在本地写好博客后轻松管理网站内容</p><p>更进一步的时候，你可以利用Hexo生成前端源码后上传到自己的服务器上。</p><h5 id="（2）内容管理系统"><a href="#（2）内容管理系统" class="headerlink" title="（2）内容管理系统"></a>（2）内容管理系统</h5><p>这类建站方式建立的网站不只是静态的html，可以包含很多功能，一般都带有后台，需要配置域名、服务器、数据库</p><p>例如：<a href="https://wordpress.com/">WordPress</a>   <a href="https://cargo.site/">Cargo</a>  <a href="https://ghost.org/">Ghost</a></p><p>作为一个有着 17 年历史的开源博客程序，WordPress 可以算得上是最著名的博客方案，没有之一。WordPress 有着异常庞大的用户社群，你可以在网上找到无数的主题和插件，可以说，其他博客服务有的任何功能，WordPress 几乎都能做到。根据维基百科，截至 2019 年，世界上排名前 1000 万的网站中，超过 30% 都使用 WordPress 搭建。WordPress 官方的建站服务 wordpress.com 可以让你不需要自己购买服务器，只要注册一个帐号，就能够简单地创建自己的博客站点。</p><h4 id="3-大神自建类"><a href="#3-大神自建类" class="headerlink" title="3.大神自建类"></a>3.大神自建类</h4><p>自己建立网站其实完全可以自己手写前端界面、自撸后端代码、连接数据库、部署服务器，绑定域名、发布从前端页面到后端数据完全掌握在自己手里的个人网站</p><h3 id="二、购买域名和服务器"><a href="#二、购买域名和服务器" class="headerlink" title="二、购买域名和服务器"></a>二、购买域名和服务器</h3><h4 id="1-域名购买"><a href="#1-域名购买" class="headerlink" title="1.域名购买"></a>1.域名购买</h4><p>域名可以去国内的万网和腾讯云、国外的godaddy.com购买，需要注意的是国内购买域名需要备案，而国外则不需要，可以综合比对价格和是否愿意备案后决定在哪里购买</p><h4 id="2服务器购买"><a href="#2服务器购买" class="headerlink" title="2服务器购买"></a>2服务器购买</h4><p>部署思路：coding网站托管+别名&#x3D;用自己域名访问托管在coding上的网站</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;个人网站搭建&quot;&gt;&lt;a href=&quot;#个人网站搭建&quot; class=&quot;headerlink&quot; title=&quot;个人网站搭建&quot;&gt;&lt;/a&gt;个人网站搭建&lt;/h1&gt;&lt;h3 id=&quot;一、选择搭建方案&quot;&gt;&lt;a href=&quot;#一、选择搭建方案&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    
    <category term="blog" scheme="https://mightcoder.com/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>个人博客建立啦</title>
    <link href="https://mightcoder.com/2021/11/29/hello-world/"/>
    <id>https://mightcoder.com/2021/11/29/hello-world/</id>
    <published>2021-11-28T16:00:00.000Z</published>
    <updated>2023-11-29T11:39:29.466Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一篇博客"><a href="#第一篇博客" class="headerlink" title="第一篇博客"></a>第一篇博客</h1><p>  以后所有的技术博客还有闲聊都会在这里发布了，希望自己更新的勤一点。</p><p>  希望DNS解析别崩了QAQ</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;第一篇博客&quot;&gt;&lt;a href=&quot;#第一篇博客&quot; class=&quot;headerlink&quot; title=&quot;第一篇博客&quot;&gt;&lt;/a&gt;第一篇博客&lt;/h1&gt;&lt;p&gt;  以后所有的技术博客还有闲聊都会在这里发布了，希望自己更新的勤一点。&lt;/p&gt;
&lt;p&gt; </summary>
        
      
    
    
    
    
    <category term="闲聊" scheme="https://mightcoder.com/tags/%E9%97%B2%E8%81%8A/"/>
    
  </entry>
  
</feed>
